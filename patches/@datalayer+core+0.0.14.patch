diff --git a/node_modules/@datalayer/core/lib/README.md b/node_modules/@datalayer/core/lib/README.md
new file mode 100644
index 0000000..911ff75
--- /dev/null
+++ b/node_modules/@datalayer/core/lib/README.md
@@ -0,0 +1,1021 @@
+# Datalayer Core - TypeScript/React Components
+
+This directory contains the comprehensive TypeScript/React frontend architecture for Datalayer Core. It provides a complete component library, state management, hooks, utilities, and API integration for building modern web applications on the Datalayer platform.
+
+## üìÅ Directory Structure
+
+```
+src/
+‚îú‚îÄ‚îÄ api/                    # API layer and Jupyter integration
+‚îú‚îÄ‚îÄ components/             # React component library (70+ components)
+‚îú‚îÄ‚îÄ config/                 # Configuration utilities
+‚îú‚îÄ‚îÄ examples/              # Usage examples
+‚îú‚îÄ‚îÄ hooks/                 # Custom React hooks (25+ hooks)
+‚îú‚îÄ‚îÄ i18n/                  # Internationalization
+‚îú‚îÄ‚îÄ models/                # TypeScript type definitions (70+ models)
+‚îú‚îÄ‚îÄ routes/                # Routing configuration
+‚îú‚îÄ‚îÄ state/                 # Zustand state management
+‚îú‚îÄ‚îÄ stories/               # Storybook stories
+‚îú‚îÄ‚îÄ theme/                 # Theme and styling
+‚îú‚îÄ‚îÄ utils/                 # Utility functions (20+ utilities)
+‚îî‚îÄ‚îÄ mocks/                 # Testing mocks
+```
+
+## üöÄ Getting Started
+
+### Installation
+
+```bash
+npm install
+```
+
+### Development
+
+```bash
+# Start development server
+npm run dev
+
+# Run Storybook for component development
+npm run storybook
+
+# Run tests
+npm run test
+
+# Build for production
+npm run build
+```
+
+## üß© Components
+
+### UI Components
+
+#### Avatars
+
+```tsx
+import { BoringAvatar, UserProfileAvatar } from '@datalayer/core';
+
+// Generate unique avatars
+<BoringAvatar
+  size={40}
+  name="John Doe"
+  variant="marble"
+  colors={["#92A1C6", "#146A7C", "#F0AB3D"]}
+/>
+
+// User profile avatar with fallback
+<UserProfileAvatar
+  user={{ name: "John Doe", avatarUrl: "https://..." }}
+  size="large"
+/>
+```
+
+#### Buttons
+
+```tsx
+import {
+  LongActionButton,
+  DownloadCSVButton,
+  UploadButton
+} from '@datalayer/core';
+
+// Long-running action with loading state
+<LongActionButton
+  onClick={async () => await longRunningTask()}
+  loadingText="Processing..."
+  variant="primary"
+>
+  Start Analysis
+</LongActionButton>
+
+// CSV download functionality
+<DownloadCSVButton
+  data={[
+    { name: "John", age: 30 },
+    { name: "Jane", age: 25 }
+  ]}
+  filename="users.csv"
+/>
+
+// File upload with validation
+<UploadButton
+  accept=".csv,.json"
+  maxSize={10 * 1024 * 1024} // 10MB
+  onUpload={(files) => handleFiles(files)}
+  multiple
+>
+  Upload Files
+</UploadButton>
+```
+
+#### Display Components
+
+```tsx
+import {
+  CenteredSpinner,
+  DatalayerBox,
+  CodePreview,
+  Markdown
+} from '@datalayer/core';
+
+// Loading spinner
+<CenteredSpinner size="large" />
+
+// Branded container
+<DatalayerBox variant="elevated">
+  <h2>Dashboard Content</h2>
+</DatalayerBox>
+
+// Syntax-highlighted code
+<CodePreview
+  code={`
+    const hello = (name: string) => {
+      console.log(\`Hello, \${name}!\`);
+    };
+  `}
+  language="typescript"
+  showLineNumbers
+/>
+
+// Markdown rendering
+<Markdown content="# Hello World\nThis is **bold** text." />
+```
+
+### Data Visualization
+
+#### Charts (ECharts Integration)
+
+```tsx
+import { EChartsReact } from '@datalayer/core';
+
+const chartOptions = {
+  title: { text: 'Sample Chart' },
+  xAxis: { type: 'category', data: ['Mon', 'Tue', 'Wed'] },
+  yAxis: { type: 'value' },
+  series: [
+    {
+      data: [120, 200, 150],
+      type: 'line',
+    },
+  ],
+};
+
+<EChartsReact option={chartOptions} style={{ height: '400px' }} />;
+```
+
+#### Progress Components
+
+```tsx
+import {
+  ProgressBar,
+  ProgressRing,
+  ConsumptionBar,
+  CreditsIndicator
+} from '@datalayer/core';
+
+// Linear progress bar
+<ProgressBar value={75} max={100} label="Upload Progress" />
+
+// Circular progress ring
+<ProgressRing
+  value={60}
+  size={80}
+  strokeWidth={8}
+  color="#0066CC"
+/>
+
+// Resource consumption
+<ConsumptionBar
+  used={750}
+  total={1000}
+  unit="MB"
+  warningThreshold={0.8}
+/>
+
+// Credits display
+<CreditsIndicator
+  current={150}
+  total={500}
+  showUsage
+/>
+```
+
+### Jupyter Integration
+
+#### Notebook Components
+
+```tsx
+import {
+  JupyterNotebook,
+  JupyterNotebookToolbar,
+  RuntimePickerNotebook
+} from '@datalayer/core';
+
+// Full notebook viewer
+<JupyterNotebook
+  notebookId="notebook-123"
+  readonly={false}
+  showLineNumbers
+  theme="light"
+/>
+
+// Notebook toolbar
+<JupyterNotebookToolbar
+  notebook={notebookData}
+  onSave={handleSave}
+  onRun={handleRun}
+  onExport={handleExport}
+/>
+
+// Runtime selection for notebooks
+<RuntimePickerNotebook
+  currentRuntime="python-runtime-1"
+  onRuntimeChange={handleRuntimeChange}
+  availableRuntimes={runtimes}
+/>
+```
+
+#### Runtime Management
+
+```tsx
+import {
+  RuntimePickerBase,
+  RuntimeLauncherDialog,
+  RuntimeVariables,
+  RuntimeReservationControl
+} from '@datalayer/core';
+
+// Basic runtime picker
+<RuntimePickerBase
+  runtimes={availableRuntimes}
+  selectedRuntime={currentRuntime}
+  onSelect={setCurrentRuntime}
+/>
+
+// Runtime launcher modal
+<RuntimeLauncherDialog
+  isOpen={showLauncher}
+  onClose={() => setShowLauncher(false)}
+  onLaunch={handleRuntimeLaunch}
+  environments={environments}
+/>
+
+// Runtime variables inspector
+<RuntimeVariables
+  runtimeId="runtime-123"
+  variables={runtimeVariables}
+  onVariableUpdate={handleVariableUpdate}
+/>
+```
+
+### Navigation & Layout
+
+#### Navigation Bar
+
+```tsx
+import { SubdomainNavBar } from '@datalayer/core';
+
+<SubdomainNavBar
+  user={currentUser}
+  organization={currentOrg}
+  navigation={[
+    { label: 'Dashboard', href: '/dashboard' },
+    { label: 'Notebooks', href: '/notebooks' },
+    { label: 'Runtimes', href: '/runtimes' },
+  ]}
+  onSignOut={handleSignOut}
+/>;
+```
+
+#### Sub Navigation
+
+```tsx
+import { SubNav } from '@datalayer/core';
+
+<SubNav
+  items={[
+    { key: 'overview', label: 'Overview', href: '/overview' },
+    { key: 'settings', label: 'Settings', href: '/settings' },
+    { key: 'members', label: 'Members', href: '/members' },
+  ]}
+  activeKey="overview"
+/>;
+```
+
+### Forms & Inputs
+
+#### Context Selectors
+
+```tsx
+import { OrganizationSelect, SpaceSelect } from '@datalayer/core';
+
+// Organization selector
+<OrganizationSelect
+  organizations={userOrganizations}
+  selected={currentOrganization}
+  onSelect={setCurrentOrganization}
+/>
+
+// Space selector
+<SpaceSelect
+  spaces={availableSpaces}
+  selected={currentSpace}
+  onSelect={setCurrentSpace}
+  organization={currentOrganization}
+/>
+```
+
+### Storage & File Management
+
+```tsx
+import { ContentsBrowser, ContentsItems } from '@datalayer/core';
+
+// File browser component
+<ContentsBrowser
+  path="/notebooks"
+  onNavigate={handlePathChange}
+  onFileSelect={handleFileSelect}
+  allowUpload
+  allowNewFolder
+/>
+
+// File list component
+<ContentsItems
+  items={fileItems}
+  selectedItems={selectedFiles}
+  onSelectionChange={setSelectedFiles}
+  onItemAction={handleItemAction}
+/>
+```
+
+## üé£ Custom Hooks
+
+### Authentication Hooks
+
+```tsx
+import { useUser, useIAM, useAuthorization } from '@datalayer/core';
+
+function UserProfile() {
+  const { user, loading, error } = useUser();
+  const { isAuthenticated, login, logout } = useIAM();
+  const { hasPermission } = useAuthorization();
+
+  if (loading) return <div>Loading...</div>;
+  if (!isAuthenticated) return <button onClick={login}>Login</button>;
+
+  return (
+    <div>
+      <h1>Welcome, {user?.name}</h1>
+      {hasPermission('admin') && <AdminPanel />}
+      <button onClick={logout}>Logout</button>
+    </div>
+  );
+}
+```
+
+### Platform Integration Hooks
+
+```tsx
+import { useDatalayer, useRuntimes, useNotebookAIAgent } from '@datalayer/core';
+
+function RuntimeDashboard() {
+  // Main Datalayer platform integration
+  const { client, isConnected } = useDatalayer();
+
+  // Runtime management
+  const {
+    runtimes,
+    loading,
+    createRuntime,
+    deleteRuntime,
+    startRuntime,
+    stopRuntime,
+  } = useRuntimes();
+
+  // AI agent for notebooks
+  const { agent, executeCode, getCompletion } = useNotebookAIAgent();
+
+  const handleCreateRuntime = async () => {
+    await createRuntime({
+      name: 'new-runtime',
+      environment: 'python-3.11',
+    });
+  };
+
+  return (
+    <div>
+      <h2>Runtimes ({runtimes.length})</h2>
+      <button onClick={handleCreateRuntime}>Create Runtime</button>
+      {runtimes.map(runtime => (
+        <div key={runtime.id}>
+          <span>
+            {runtime.name} - {runtime.status}
+          </span>
+          <button onClick={() => startRuntime(runtime.id)}>Start</button>
+          <button onClick={() => stopRuntime(runtime.id)}>Stop</button>
+        </div>
+      ))}
+    </div>
+  );
+}
+```
+
+### UI/UX Hooks
+
+```tsx
+import {
+  useToast,
+  useBackdrop,
+  useScreenshot,
+  useUpload,
+  useVisibilityObserver,
+} from '@datalayer/core';
+
+function InteractiveComponent() {
+  const { showToast } = useToast();
+  const { showBackdrop, hideBackdrop } = useBackdrop();
+  const { takeScreenshot } = useScreenshot();
+  const { uploadFiles, uploading, progress } = useUpload();
+  const { ref, isVisible } = useVisibilityObserver();
+
+  const handleAction = async () => {
+    showBackdrop('Processing...');
+    try {
+      await someAsyncAction();
+      showToast('Success!', 'success');
+    } catch (error) {
+      showToast('Error occurred', 'error');
+    } finally {
+      hideBackdrop();
+    }
+  };
+
+  const handleScreenshot = async () => {
+    const screenshot = await takeScreenshot(ref.current);
+    // Use screenshot data
+  };
+
+  return (
+    <div ref={ref}>
+      <button onClick={handleAction}>Perform Action</button>
+      <button onClick={handleScreenshot}>Take Screenshot</button>
+      {isVisible && <div>Component is visible!</div>}
+
+      <input type="file" onChange={e => uploadFiles(e.target.files)} multiple />
+      {uploading && <div>Upload progress: {progress}%</div>}
+    </div>
+  );
+}
+```
+
+### Cache and Performance Hooks
+
+```tsx
+import { useCache, useWindowSize } from '@datalayer/core';
+
+function CachedDataComponent() {
+  const { width, height } = useWindowSize();
+
+  const { data, loading, error, refresh } = useCache(
+    'expensive-data',
+    async () => {
+      const response = await fetch('/api/expensive-data');
+      return response.json();
+    },
+    { ttl: 5 * 60 * 1000 }, // 5 minutes cache
+  );
+
+  // Responsive behavior based on window size
+  const isMobile = width < 768;
+
+  return (
+    <div className={isMobile ? 'mobile-layout' : 'desktop-layout'}>
+      {loading ? (
+        <div>Loading...</div>
+      ) : error ? (
+        <div>Error: {error.message}</div>
+      ) : (
+        <div>
+          <pre>{JSON.stringify(data, null, 2)}</pre>
+          <button onClick={refresh}>Refresh</button>
+        </div>
+      )}
+    </div>
+  );
+}
+```
+
+## üóÇÔ∏è State Management (Zustand)
+
+### Core State
+
+```tsx
+import { useCoreState } from '@datalayer/core';
+
+function AppHeader() {
+  const {
+    theme,
+    setTheme,
+    sidebarOpen,
+    setSidebarOpen,
+    notifications,
+    addNotification,
+  } = useCoreState();
+
+  return (
+    <header>
+      <button onClick={() => setSidebarOpen(!sidebarOpen)}>
+        Toggle Sidebar
+      </button>
+      <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
+        Toggle Theme
+      </button>
+      <div className="notifications">
+        {notifications.map(notification => (
+          <div key={notification.id}>{notification.message}</div>
+        ))}
+      </div>
+    </header>
+  );
+}
+```
+
+### Organization & Space State
+
+```tsx
+import { useOrganizationState, useSpaceState } from '@datalayer/core';
+
+function OrganizationDashboard() {
+  const {
+    currentOrganization,
+    setCurrentOrganization,
+    organizations,
+    fetchOrganizations,
+  } = useOrganizationState();
+
+  const { spaces, currentSpace, setCurrentSpace, createSpace, deleteSpace } =
+    useSpaceState();
+
+  useEffect(() => {
+    fetchOrganizations();
+  }, []);
+
+  const handleCreateSpace = async () => {
+    await createSpace({
+      name: 'New Space',
+      description: 'A new workspace',
+      organizationId: currentOrganization?.id,
+    });
+  };
+
+  return (
+    <div>
+      <h1>{currentOrganization?.name}</h1>
+      <div>
+        <h2>Spaces</h2>
+        <button onClick={handleCreateSpace}>Create Space</button>
+        {spaces.map(space => (
+          <div key={space.id}>
+            <span>{space.name}</span>
+            <button onClick={() => setCurrentSpace(space)}>Select</button>
+            <button onClick={() => deleteSpace(space.id)}>Delete</button>
+          </div>
+        ))}
+      </div>
+    </div>
+  );
+}
+```
+
+### Runtime State
+
+```tsx
+import { useRuntimesState } from '@datalayer/core';
+
+function RuntimeManager() {
+  const {
+    runtimes,
+    loading,
+    error,
+    selectedRuntime,
+    setSelectedRuntime,
+    createRuntime,
+    updateRuntime,
+    deleteRuntime,
+    fetchRuntimes,
+  } = useRuntimesState();
+
+  const handleRuntimeAction = async (runtimeId: string, action: string) => {
+    try {
+      await updateRuntime(runtimeId, { action });
+    } catch (error) {
+      console.error('Runtime action failed:', error);
+    }
+  };
+
+  return (
+    <div>
+      <h2>Runtime Management</h2>
+      {loading && <div>Loading runtimes...</div>}
+      {error && <div>Error: {error}</div>}
+
+      {runtimes.map(runtime => (
+        <div key={runtime.id} className="runtime-card">
+          <h3>{runtime.name}</h3>
+          <p>Status: {runtime.status}</p>
+          <p>Environment: {runtime.environment}</p>
+
+          <div className="runtime-actions">
+            <button onClick={() => handleRuntimeAction(runtime.id, 'start')}>
+              Start
+            </button>
+            <button onClick={() => handleRuntimeAction(runtime.id, 'stop')}>
+              Stop
+            </button>
+            <button onClick={() => handleRuntimeAction(runtime.id, 'restart')}>
+              Restart
+            </button>
+            <button onClick={() => deleteRuntime(runtime.id)}>Delete</button>
+          </div>
+        </div>
+      ))}
+    </div>
+  );
+}
+```
+
+## üõ†Ô∏è Utilities
+
+### Array Utilities
+
+```tsx
+import {
+  uniqueBy,
+  groupBy,
+  sortBy,
+  chunk,
+  flatten,
+} from '@datalayer/core/utils';
+
+// Remove duplicates by property
+const uniqueUsers = uniqueBy(users, 'id');
+
+// Group items by property
+const usersByRole = groupBy(users, 'role');
+
+// Sort with multiple criteria
+const sortedUsers = sortBy(users, ['lastName', 'firstName']);
+
+// Split array into chunks
+const batches = chunk(largeArray, 10);
+
+// Flatten nested arrays
+const flatList = flatten(nestedArrays);
+```
+
+### Date Utilities
+
+```tsx
+import {
+  formatRelativeTime,
+  formatDate,
+  parseDate,
+  addDays,
+  isToday,
+} from '@datalayer/core/utils';
+
+// Relative time formatting
+const relativeTime = formatRelativeTime(new Date('2023-01-01'));
+// "2 months ago"
+
+// Date formatting
+const formattedDate = formatDate(new Date(), 'yyyy-MM-dd');
+// "2023-03-15"
+
+// Date parsing
+const parsedDate = parseDate('2023-03-15');
+
+// Date arithmetic
+const futureDate = addDays(new Date(), 7);
+
+// Date checks
+const checkToday = isToday(someDate);
+```
+
+### File Utilities
+
+```tsx
+import {
+  downloadFile,
+  readFileAsText,
+  validateFileType,
+  formatFileSize,
+  getFileExtension,
+} from '@datalayer/core/utils';
+
+// Download file
+downloadFile(data, 'report.csv', 'text/csv');
+
+// Read file content
+const content = await readFileAsText(file);
+
+// Validate file type
+const isValidImage = validateFileType(file, ['image/png', 'image/jpeg']);
+
+// Format file size
+const sizeString = formatFileSize(file.size);
+// "2.5 MB"
+
+// Get file extension
+const extension = getFileExtension(file.name);
+// "png"
+```
+
+### String Utilities
+
+```tsx
+import {
+  capitalize,
+  camelCase,
+  kebabCase,
+  truncate,
+  stripHtml,
+  generateSlug,
+} from '@datalayer/core/utils';
+
+// String transformations
+const title = capitalize('hello world');
+// "Hello world"
+
+const camelCased = camelCase('hello-world-test');
+// "helloWorldTest"
+
+const kebabCased = kebabCase('HelloWorldTest');
+// "hello-world-test"
+
+// String manipulation
+const truncated = truncate('Long text here...', 10);
+// "Long text..."
+
+const plainText = stripHtml('<p>Hello <strong>world</strong></p>');
+// "Hello world"
+
+const slug = generateSlug('Hello World! 123');
+// "hello-world-123"
+```
+
+### Number Utilities
+
+```tsx
+import {
+  formatNumber,
+  formatCurrency,
+  formatPercentage,
+  clamp,
+  randomBetween,
+} from '@datalayer/core/utils';
+
+// Number formatting
+const formattedNum = formatNumber(1234567);
+// "1,234,567"
+
+const currency = formatCurrency(99.99, 'USD');
+// "$99.99"
+
+const percentage = formatPercentage(0.756, 2);
+// "75.60%"
+
+// Number manipulation
+const clamped = clamp(15, 0, 10);
+// 10
+
+const random = randomBetween(1, 100);
+// Random number between 1 and 100
+```
+
+## üé® Theme & Styling
+
+### Theme Provider
+
+```tsx
+import { DatalayerThemeProvider } from '@datalayer/core';
+
+function App() {
+  return (
+    <DatalayerThemeProvider theme="light">
+      <YourAppContent />
+    </DatalayerThemeProvider>
+  );
+}
+```
+
+### Theme Configuration
+
+```tsx
+import { createDatalayerTheme } from '@datalayer/core';
+
+const customTheme = createDatalayerTheme({
+  palette: {
+    primary: {
+      main: '#1976d2',
+      light: '#42a5f5',
+      dark: '#1565c0',
+    },
+    secondary: {
+      main: '#dc004e',
+    },
+  },
+  typography: {
+    fontFamily: '"Roboto", "Helvetica", "Arial", sans-serif',
+  },
+  spacing: 8,
+  breakpoints: {
+    xs: 0,
+    sm: 600,
+    md: 960,
+    lg: 1280,
+    xl: 1920,
+  },
+});
+```
+
+## üß™ Testing
+
+### Component Testing
+
+```tsx
+import { render, screen, fireEvent } from '@testing-library/react';
+import { MyComponent } from './MyComponent';
+
+describe('MyComponent', () => {
+  it('renders correctly', () => {
+    render(<MyComponent title="Test" />);
+    expect(screen.getByText('Test')).toBeInTheDocument();
+  });
+
+  it('handles click events', () => {
+    const handleClick = jest.fn();
+    render(<MyComponent onClick={handleClick} />);
+
+    fireEvent.click(screen.getByRole('button'));
+    expect(handleClick).toHaveBeenCalled();
+  });
+});
+```
+
+### Hook Testing
+
+```tsx
+import { renderHook, act } from '@testing-library/react';
+import { useCounter } from './useCounter';
+
+describe('useCounter', () => {
+  it('increments counter', () => {
+    const { result } = renderHook(() => useCounter(0));
+
+    act(() => {
+      result.current.increment();
+    });
+
+    expect(result.current.count).toBe(1);
+  });
+});
+```
+
+## üìö Storybook
+
+### Component Stories
+
+```tsx
+import type { Meta, StoryObj } from '@storybook/react';
+import { Button } from './Button';
+
+const meta: Meta<typeof Button> = {
+  title: 'Components/Button',
+  component: Button,
+  parameters: {
+    layout: 'centered',
+  },
+  tags: ['autodocs'],
+};
+
+export default meta;
+type Story = StoryObj<typeof meta>;
+
+export const Primary: Story = {
+  args: {
+    variant: 'primary',
+    children: 'Button',
+  },
+};
+
+export const Secondary: Story = {
+  args: {
+    variant: 'secondary',
+    children: 'Button',
+  },
+};
+```
+
+## üîß Configuration
+
+### Development Configuration
+
+```typescript
+// vite.config.ts
+import { defineConfig } from 'vite';
+import react from '@vitejs/plugin-react';
+
+export default defineConfig({
+  plugins: [react()],
+  resolve: {
+    alias: {
+      '@': resolve(__dirname, 'src'),
+    },
+  },
+});
+```
+
+### TypeScript Configuration
+
+```json
+// tsconfig.json
+{
+  "compilerOptions": {
+    "target": "ES2020",
+    "lib": ["ES2020", "DOM", "DOM.Iterable"],
+    "module": "ESNext",
+    "skipLibCheck": true,
+    "moduleResolution": "bundler",
+    "allowImportingTsExtensions": true,
+    "resolveJsonModule": true,
+    "isolatedModules": true,
+    "noEmit": true,
+    "jsx": "react-jsx",
+    "strict": true,
+    "noUnusedLocals": true,
+    "noUnusedParameters": true,
+    "noFallthroughCasesInSwitch": true
+  },
+  "include": ["src"],
+  "references": [{ "path": "./tsconfig.node.json" }]
+}
+```
+
+## üì¶ Building & Distribution
+
+### Build Process
+
+```bash
+# Build library
+npm run build:lib
+
+# Build application
+npm run build
+
+# Generate TypeDoc documentation
+npm run typedoc
+```
+
+### Package Exports
+
+The package exports components, hooks, utilities, and types:
+
+```typescript
+import {
+  // Components
+  DatalayerBox,
+  UserProfileAvatar,
+  JupyterNotebook,
+
+  // Hooks
+  useUser,
+  useRuntimes,
+  useDatalayer,
+
+  // Utilities
+  formatDate,
+  downloadFile,
+  generateSlug,
+
+  // Types
+  User,
+  Runtime,
+  Organization,
+} from '@datalayer/core';
+```
+
+## ü§ù Contributing
+
+1. Follow the existing code structure and patterns
+2. Add comprehensive TypeScript types
+3. Include Storybook stories for new components
+4. Write tests for all functionality
+5. Update documentation as needed
+
+## üìÑ License
+
+This project is licensed under the Modified BSD License.
+
+---
+
+Built with ‚ù§Ô∏è using React, TypeScript, and modern web technologies.
diff --git a/node_modules/@datalayer/core/lib/components/checkout/StripeCheckout.js b/node_modules/@datalayer/core/lib/components/checkout/StripeCheckout.js
index e5fbff4..d0bf961 100644
--- a/node_modules/@datalayer/core/lib/components/checkout/StripeCheckout.js
+++ b/node_modules/@datalayer/core/lib/components/checkout/StripeCheckout.js
@@ -7,34 +7,26 @@ import { createElement, useCallback, useEffect, useState } from 'react';
 import { Button, Flash, FormControl, Spinner, Text } from '@primer/react';
 import { Box } from '@datalayer/primer-addons';
 import { useCache } from '../../hooks';
-import { useIAMStore } from '../../state';
 /**
  * Stripe checkout.
  */
 export function StripeCheckout({ checkoutPortal, }) {
-    const { iamRunUrl } = useIAMStore();
-    const { createCheckoutSession, refreshStripePrices } = useCache();
+    const { useCreateCheckoutSession, useStripePrices } = useCache();
     const [stripe, setStripe] = useState(null);
     const [components, setComponents] = useState(null);
     const [items, setItems] = useState(null);
     const [product, setProduct] = useState(null);
     const [checkout, setCheckout] = useState(false);
-    // Refresh Stripe items.
+    // Get Stripe prices using TanStack Query hook
+    const { data: pricesData } = useStripePrices();
+    // Update items when prices data changes
     useEffect(() => {
-        refreshStripePrices()
-            .then(response => {
-            if (response.success) {
-                setItems(response.prices);
-            }
-            else {
-                setItems([]);
-            }
-        })
-            .catch(error => {
-            console.error('Failed to fetch product items.', error);
-            setItems([]);
-        });
-    }, []);
+        if (pricesData) {
+            setItems(pricesData);
+        }
+    }, [pricesData]);
+    // Get checkout session mutation
+    const checkoutSessionMutation = useCreateCheckoutSession();
     // Load stripe components.
     useEffect(() => {
         import('@stripe/react-stripe-js').then(module => {
@@ -45,15 +37,19 @@ export function StripeCheckout({ checkoutPortal, }) {
     useEffect(() => {
         if (checkoutPortal?.metadata?.stripe_key) {
             import('@stripe/stripe-js').then(module => {
-                setStripe(module.loadStripe(checkoutPortal.metadata.stripe_key));
+                setStripe(module.loadStripe(checkoutPortal.metadata?.stripe_key ?? ''));
             });
         }
     }, [checkoutPortal?.metadata?.stripe_key]);
-    const fetchClientSecret = useCallback(() => {
+    const fetchClientSecret = useCallback(async () => {
         const location = document.location;
-        // Create a Checkout Session.
-        return createCheckoutSession(product, location);
-    }, [iamRunUrl, location, product?.id]);
+        // Create a Checkout Session using TanStack Query mutation
+        const result = await checkoutSessionMutation.mutateAsync({
+            product,
+            location,
+        });
+        return result;
+    }, [checkoutSessionMutation, product]);
     const options = { fetchClientSecret };
     let view = (_jsx(Box, { sx: { minHeight: '40px' }, children: _jsx(Spinner, {}) }));
     if (checkout) {
diff --git a/node_modules/@datalayer/core/lib/components/context/OrganizationSelect.js b/node_modules/@datalayer/core/lib/components/context/OrganizationSelect.js
index 550747d..8575de7 100644
--- a/node_modules/@datalayer/core/lib/components/context/OrganizationSelect.js
+++ b/node_modules/@datalayer/core/lib/components/context/OrganizationSelect.js
@@ -3,7 +3,7 @@ import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-run
  * Copyright (c) 2023-2025 Datalayer, Inc.
  * Distributed under the terms of the Modified BSD License.
  */
-import { useState, useEffect, useCallback } from 'react';
+import { useCallback, useEffect } from 'react';
 import { Select } from '@primer/react';
 import { useCache, useUser } from './../../hooks';
 import { useLayoutStore } from '../../state';
@@ -11,25 +11,22 @@ const NO_ORGANIZATION_SELECTED_VALUE = 'NO_ORGANIZATION_SELECTED_VALUE';
 export const OrganizationSelect = () => {
     const user = useUser();
     const { organization, updateLayoutOrganization, updateLayoutSpace } = useLayoutStore();
-    const { refreshUserOrganizations, getUserOrganizations } = useCache();
-    const [organizations, setOrganizations] = useState(getUserOrganizations());
-    const [_, setSelection] = useState(organization);
+    const { useRefreshUserOrganizations, useUserOrganizations } = useCache();
+    const { mutate: refreshUserOrganizationsMutate } = useRefreshUserOrganizations();
+    const { data: organizations = [] } = useUserOrganizations();
     useEffect(() => {
-        refreshUserOrganizations(user).then(resp => {
-            if (resp.success) {
-                setOrganizations(getUserOrganizations());
-            }
-        });
-    }, [user]);
-    const onSelectionChange = useCallback((e) => {
-        const selectedOrganization = e.target.value;
+        if (user) {
+            refreshUserOrganizationsMutate();
+        }
+    }, [user, refreshUserOrganizationsMutate]);
+    const onSelectionChange = useCallback((event) => {
+        const selectedOrganization = event.target.value;
         const org = selectedOrganization === NO_ORGANIZATION_SELECTED_VALUE
             ? undefined
             : organizations[parseInt(selectedOrganization, 10)];
-        setSelection(org);
         updateLayoutOrganization(org);
         updateLayoutSpace(undefined);
-    }, [setSelection, organizations]);
-    return (_jsx(_Fragment, { children: _jsxs(Select, { block: true, width: "medium", onChange: onSelectionChange, children: [_jsx(Select.Option, { value: NO_ORGANIZATION_SELECTED_VALUE, selected: organization === undefined, children: "Please select an organization..." }), organizations.map((org, index) => (_jsx(Select.Option, { value: `${index}`, selected: org.id === organization?.id, children: org.name })))] }) }));
+    }, [organizations, updateLayoutOrganization, updateLayoutSpace]);
+    return (_jsx(_Fragment, { children: _jsxs(Select, { block: true, width: "medium", onChange: onSelectionChange, children: [_jsx(Select.Option, { value: NO_ORGANIZATION_SELECTED_VALUE, selected: organization === undefined, children: "Please select an organization..." }), organizations.map((org, index) => (_jsx(Select.Option, { value: `${index}`, selected: org.id === organization?.id, children: org.name }, org.id)))] }) }));
 };
 export default OrganizationSelect;
diff --git a/node_modules/@datalayer/core/lib/components/context/SpaceSelect.js b/node_modules/@datalayer/core/lib/components/context/SpaceSelect.js
index d7877c9..459f945 100644
--- a/node_modules/@datalayer/core/lib/components/context/SpaceSelect.js
+++ b/node_modules/@datalayer/core/lib/components/context/SpaceSelect.js
@@ -3,7 +3,7 @@ import { jsx as _jsx, jsxs as _jsxs, Fragment as _Fragment } from "react/jsx-run
  * Copyright (c) 2023-2025 Datalayer, Inc.
  * Distributed under the terms of the Modified BSD License.
  */
-import { useState, useEffect, useCallback } from 'react';
+import { useCallback, useEffect } from 'react';
 import { FormControl, Select } from '@primer/react';
 import { Box } from '@datalayer/primer-addons';
 import { useCache, useUser } from './../../hooks';
@@ -11,33 +11,32 @@ import { useLayoutStore } from '../../state';
 export const SpaceSelect = () => {
     const user = useUser();
     const { organization, space, updateLayoutSpace } = useLayoutStore();
-    const { refreshUserSpaces, getUserSpaces, refreshOrganizationSpaces, getOrganizationSpaces, } = useCache();
-    const [spaces, setSpaces] = useState([]);
-    const [_, setSelection] = useState(space);
+    const { useRefreshUserSpaces, useUserSpaces, useRefreshOrganizationSpaces, useOrganizationSpaces, } = useCache();
+    const { mutate: refreshUserSpacesMutate } = useRefreshUserSpaces();
+    const { mutate: refreshOrganizationSpacesMutate } = useRefreshOrganizationSpaces();
+    const { data: organizationSpaces = [] } = useOrganizationSpaces(organization?.id ?? '');
+    const { data: userSpaces = [] } = useUserSpaces();
+    const spaces = organization ? organizationSpaces : userSpaces;
     useEffect(() => {
-        if (organization) {
-            refreshOrganizationSpaces(organization.id).then(resp => {
-                if (resp.success) {
-                    setSpaces(getOrganizationSpaces(organization.id));
-                }
-            });
+        if (organization?.id) {
+            refreshOrganizationSpacesMutate(organization.id);
         }
-        else {
-            refreshUserSpaces().then(resp => {
-                if (resp.success) {
-                    setSpaces(getUserSpaces());
-                }
-            });
+        else if (user) {
+            refreshUserSpacesMutate();
         }
-    }, [user, organization]);
-    const onSelectionChange = useCallback((e) => {
-        const selectedSpace = e.target.value;
-        const org = selectedSpace === undefined
+    }, [
+        organization?.id,
+        refreshOrganizationSpacesMutate,
+        refreshUserSpacesMutate,
+        user,
+    ]);
+    const onSelectionChange = useCallback((event) => {
+        const selectedSpaceIndex = Number.parseInt(event.target.value, 10);
+        const selectedSpace = Number.isNaN(selectedSpaceIndex) || selectedSpaceIndex < 0
             ? undefined
-            : spaces[parseInt(selectedSpace, 10)];
-        setSelection(org);
-        updateLayoutSpace(org);
-    }, [setSelection, spaces]);
-    return (_jsx(_Fragment, { children: _jsx(Box, { as: "form", children: _jsxs(FormControl, { children: [_jsx(FormControl.Label, { children: "Select a space" }), _jsx(FormControl.Caption, { children: "This will go with you while you navigate" }), _jsx(Select, { block: true, width: "medium", onChange: onSelectionChange, placeholder: "Please select an space...", children: spaces.map((sp, index) => (_jsx(Select.Option, { value: `${index}`, selected: sp.id === space?.id, children: sp.name }))) })] }) }) }));
+            : spaces[selectedSpaceIndex];
+        updateLayoutSpace(selectedSpace);
+    }, [spaces, updateLayoutSpace]);
+    return (_jsx(_Fragment, { children: _jsx(Box, { as: "form", children: _jsxs(FormControl, { children: [_jsx(FormControl.Label, { children: "Select a space" }), _jsx(FormControl.Caption, { children: "This will go with you while you navigate" }), _jsx(Select, { block: true, width: "medium", onChange: onSelectionChange, placeholder: "Please select an space...", children: spaces.map((sp, index) => (_jsx(Select.Option, { value: `${index}`, selected: sp.id === space?.id, children: sp.name }, sp.id))) })] }) }) }));
 };
 export default SpaceSelect;
diff --git a/node_modules/@datalayer/core/lib/components/display/VisuallyHidden.d.ts b/node_modules/@datalayer/core/lib/components/display/VisuallyHidden.d.ts
index 9814d57..23d68bc 100644
--- a/node_modules/@datalayer/core/lib/components/display/VisuallyHidden.d.ts
+++ b/node_modules/@datalayer/core/lib/components/display/VisuallyHidden.d.ts
@@ -1,5 +1,4 @@
-import { SxProp } from '@primer/react';
 export interface IVisuallyHiddenProps {
     isVisible?: boolean;
 }
-export declare const VisuallyHidden: import("styled-components").StyledComponent<"span", any, IVisuallyHiddenProps & SxProp, never>;
+export declare const VisuallyHidden: any;
diff --git a/node_modules/@datalayer/core/lib/components/subnav/SubNav.d.ts b/node_modules/@datalayer/core/lib/components/subnav/SubNav.d.ts
index c21cad7..9e3947b 100644
--- a/node_modules/@datalayer/core/lib/components/subnav/SubNav.d.ts
+++ b/node_modules/@datalayer/core/lib/components/subnav/SubNav.d.ts
@@ -68,7 +68,7 @@ export declare const SubNav: React.NamedExoticComponent<{
     readonly type: ({ id, children, className, "data-testid": testId, fullWidth, hasShadow, }: SubNavProps) => import("react/jsx-runtime").JSX.Element;
 } & {
     Heading: ({ href, children, className, "data-testid": testID, ...props }: SubNavHeadingProps) => import("react/jsx-runtime").JSX.Element;
-    Link: React.ForwardRefExoticComponent<Omit<SubNavLinkProps, "ref"> & React.RefAttributes<HTMLDivElement | HTMLAnchorElement>>;
+    Link: React.ForwardRefExoticComponent<Omit<SubNavLinkProps, "ref"> & React.RefAttributes<HTMLAnchorElement | HTMLDivElement>>;
     Action: typeof _SubNavAction;
     SubMenu: typeof SubMenu;
     testIds: {
diff --git a/node_modules/@datalayer/core/lib/examples/README.md b/node_modules/@datalayer/core/lib/examples/README.md
new file mode 100644
index 0000000..416da27
--- /dev/null
+++ b/node_modules/@datalayer/core/lib/examples/README.md
@@ -0,0 +1,209 @@
+# Datalayer Core TypeScript/React Examples
+
+This directory contains interactive examples demonstrating how to use Datalayer Core's TypeScript/React components and services.
+
+## Getting Started
+
+### Prerequisites
+
+1. **Datalayer API Token**: Get your token from [Datalayer Platform](https://datalayer.app/)
+2. **Node.js**: Version 18+ recommended
+3. **npm**: Comes with Node.js
+
+### Setup
+
+1. Install dependencies:
+
+```bash
+npm install
+```
+
+2. Configure your environment:
+
+```bash
+# Create .env file with your token
+echo "VITE_DATALAYER_API_KEY=your-token-here" > .env
+```
+
+3. Start the examples server:
+
+```bash
+npm run example
+```
+
+4. Open http://localhost:3000/ in your browser
+
+## Available Examples
+
+### DatalayerNotebookExample
+
+**File**: `DatalayerNotebookExample.tsx`
+
+Demonstrates full integration with Datalayer services:
+
+- **DatalayerServiceManager**: Connects to Datalayer infrastructure for kernel management
+- **DatalayerCollaborationProvider**: Enables real-time collaboration
+- **Runtime creation**: Automatically provisions compute resources
+- **Graceful fallback**: Works with limited functionality when credentials are missing
+
+Key features:
+
+- Toggle collaboration on/off
+- Switch between read-only and edit modes
+- Automatic kernel provisioning with Datalayer credits
+- WebSocket connections for real-time updates
+
+### NotebookExample
+
+**File**: `NotebookExample.tsx`
+
+Basic Jupyter notebook implementation:
+
+- Standard notebook interface
+- Local or remote kernel support
+- Cell execution and output display
+- Markdown and code cell support
+
+### CellExample
+
+**File**: `CellExample.tsx`
+
+Individual code cell execution:
+
+- Standalone cell component
+- Syntax highlighting
+- Output rendering
+- Error handling
+
+## Configuration
+
+### Selecting an Example
+
+Edit `vite.examples.config.ts` to choose which example to run:
+
+```typescript
+const EXAMPLE =
+  // 'CellExample';
+  'DatalayerNotebookExample'; // Current selection
+// 'NotebookExample';
+```
+
+### Environment Variables
+
+The examples support these environment variables:
+
+- `VITE_DATALAYER_API_KEY`: Your Datalayer authentication token (required for full functionality)
+- `EXAMPLE`: Override the selected example via command line
+
+### Vite Configuration
+
+The `vite.examples.config.ts` file includes:
+
+- Proxy configuration for CORS handling
+- Environment variable injection
+- Hot module replacement
+- TypeScript/React support
+
+## Architecture
+
+### Services
+
+**DatalayerServiceManager** (`src/services/DatalayerServiceManager.ts`)
+
+- Creates and manages Jupyter service connections
+- Handles runtime provisioning via Datalayer API
+- Manages authentication and token handling
+- Returns configured ServiceManager for notebook use
+
+**DatalayerCollaborationProvider** (`src/collaboration/DatalayerCollaborationProvider.ts`)
+
+- Implements real-time collaboration using WebSockets
+- Manages shared document state
+- Handles user presence and cursors
+- Integrates with Jupyter's collaboration framework
+
+### State Management
+
+Uses Zustand for state management:
+
+- `DatalayerState`: Main application state
+- `datalayerConfig`: Configuration including tokens and URLs
+- `serviceManager`: Active service connections
+
+### API Integration
+
+The examples use the Datalayer Runtime API:
+
+- Endpoint: `/api/runtimes/v1/runtimes`
+- Authentication: Bearer token in Authorization header
+- Creates compute runtimes with specified resources
+- Returns ingress URLs for kernel connections
+
+## Troubleshooting
+
+### CORS Issues
+
+The Vite dev server includes a proxy configuration to handle CORS:
+
+```javascript
+proxy: {
+  '/api': {
+    target: 'https://prod1.datalayer.run',
+    changeOrigin: true,
+    secure: true,
+  },
+}
+```
+
+### Missing Token
+
+If you see "Datalayer configuration is missing" warning:
+
+1. Check your `.env` file has `VITE_DATALAYER_API_KEY` set
+2. Restart the dev server after adding the token
+3. Verify the token is valid at [Datalayer Platform](https://datalayer.app/)
+
+### Server Errors
+
+If you get 500 errors from the API:
+
+- Check the Datalayer platform status
+- Verify your token has sufficient permissions
+- Ensure you have available credits
+- Try a different environment (e.g., `python-cpu-env`)
+
+## Development
+
+### Adding a New Example
+
+1. Create a new component in `src/examples/`
+2. Import and register it in `main.tsx`
+3. Add to the example selector in `vite.examples.config.ts`
+4. Update this README with documentation
+
+### Testing
+
+Run the test suite:
+
+```bash
+npm run test
+```
+
+Type checking:
+
+```bash
+npm run type-check
+```
+
+Linting:
+
+```bash
+npm run lint
+```
+
+## Resources
+
+- [Datalayer Documentation](https://docs.datalayer.app/)
+- [Jupyter React Components](https://jupyter-react.datalayer.tech/)
+- [TypeScript API Reference](https://core.datalayer.tech/typescript/)
+- [Platform API Reference](https://prod1.datalayer.run/api/runtimes/v1/ui/)
diff --git a/node_modules/@datalayer/core/lib/hooks/useAuthorization.js b/node_modules/@datalayer/core/lib/hooks/useAuthorization.js
index d96e3e5..24ddc39 100644
--- a/node_modules/@datalayer/core/lib/hooks/useAuthorization.js
+++ b/node_modules/@datalayer/core/lib/hooks/useAuthorization.js
@@ -16,8 +16,10 @@ export const useAuthorization = () => {
     };
     // Account -------------------------------------------------------------------
     const checkUserAccountPermissions = (user, accountHandle) => {
-        if (user.handle !== accountHandle) {
-            goToApplicationStateError(`Permissions check failed for account handle: ${accountHandle} and user: ${user}`);
+        // Note: user object from API has handle_s property, not handle
+        const userHandle = user.handle_s || user.handle;
+        if (userHandle !== accountHandle) {
+            goToApplicationStateError(`Permissions check failed for account handle: ${accountHandle} and user handle: ${userHandle}`);
         }
     };
     // Platform -------------------------------------------------------------------
diff --git a/node_modules/@datalayer/core/lib/hooks/useCache.d.ts b/node_modules/@datalayer/core/lib/hooks/useCache.d.ts
index c019ba3..51e1ac9 100644
--- a/node_modules/@datalayer/core/lib/hooks/useCache.d.ts
+++ b/node_modules/@datalayer/core/lib/hooks/useCache.d.ts
@@ -1,6 +1,41 @@
-import { IAnyOrganization, IAnySpace, IAssignment, ICell, IContact, ICourse, IDataset, IDatasource, IDocument, IEnvironment, IExercise, IIAMToken, IInbound, IInvite, IItemType, ILesson, ILinkedInUser, INotebook, IOrganization, IOutbound, IPage, ISchool, ISecret, ISpaceItem, IStudent, ITeam, IUsage, IUser, IUserOnboarding, IUserSettings, LinkedInUser, WaitingListFormData } from '../models';
-import { IPrice } from './../components/checkout';
-import { type IRESTBaseResponse } from '../models';
+/**
+ * TanStack Query-based cache hook for Datalayer API
+ *
+ * This is a modernized replacement for useCache.tsx that leverages TanStack Query
+ * for automatic cache management, background refetching, and optimistic updates.
+ *
+ * Key improvements over useCache:
+ * - Automatic cache management (no manual Map objects)
+ * - Built-in loading/error states
+ * - Automatic refetching and deduplication
+ * - Optimistic updates support
+ * - Better TypeScript inference
+ * - React Query DevTools integration
+ *
+ * @example
+ * ```tsx
+ * const { useUser, useUpdateUser } = useCache2();
+ *
+ * function UserProfile({ userId }: { userId: string }) {
+ *   const { data: user, isPending, isError, error } = useUser(userId);
+ *   const updateUser = useUpdateUser();
+ *
+ *   if (isPending) return <Spinner />;
+ *   if (isError) return <Error message={error.message} />;
+ *
+ *   return (
+ *     <div>
+ *       <h1>{user.displayName}</h1>
+ *       <button onClick={() => updateUser.mutate({ email: 'new@email.com' })}>
+ *         Update Email
+ *       </button>
+ *     </div>
+ *   );
+ * }
+ * ```
+ */
+import { UseQueryOptions, UseMutationOptions } from '@tanstack/react-query';
+import { IAnyOrganization, IAnySpace, IAssignment, ICell, IContact, ICourse, IDataset, IDatasource, IDocument, IEnvironment, IExercise, IIAMToken, ILesson, INotebook, IOrganization, IPage, ISchool, ISecret, ITeam, IUser, IUserOnboarding, IUserSettings } from '../models';
 type CacheProps = {
     loginRoute?: string;
 };
@@ -11,257 +46,504 @@ type ISearchOpts = {
     public: boolean;
 };
 /**
- * Callbacks to RUN service.
+ * Centralized query key factories for all entities
+ * Following TanStack Query best practices for key structure
+ * @see https://tanstack.com/query/latest/docs/framework/react/guides/query-keys
+ */
+export declare const queryKeys: {
+    readonly auth: {
+        readonly me: () => readonly ["auth", "me"];
+        readonly whoami: () => readonly ["auth", "whoami"];
+    };
+    readonly users: {
+        readonly all: () => readonly ["users"];
+        readonly lists: () => readonly ["users", "list"];
+        readonly list: (filters?: string) => readonly ["users", "list", {
+            readonly filters: string | undefined;
+        }];
+        readonly details: () => readonly ["users", "detail"];
+        readonly detail: (id: string) => readonly ["users", "detail", string];
+        readonly byHandle: (handle: string) => readonly ["users", "handle", string];
+        readonly search: (pattern: string) => readonly ["users", "search", string];
+        readonly settings: (userId: string) => readonly ["users", "detail", string, "settings"];
+        readonly onboarding: (userId: string) => readonly ["users", "detail", string, "onboarding"];
+        readonly surveys: (userId: string) => readonly ["users", "detail", string, "surveys"];
+        readonly credits: (userId: string) => readonly ["users", "detail", string, "credits"];
+    };
+    readonly organizations: {
+        readonly all: () => readonly ["organizations"];
+        readonly lists: () => readonly ["organizations", "list"];
+        readonly details: () => readonly ["organizations", "detail"];
+        readonly detail: (id: string) => readonly ["organizations", "detail", string];
+        readonly byHandle: (handle: string) => readonly ["organizations", "handle", string];
+        readonly userOrgs: () => readonly ["organizations", "user"];
+        readonly members: (orgId: string) => readonly ["organizations", "detail", string, "members"];
+    };
+    readonly teams: {
+        readonly all: () => readonly ["teams"];
+        readonly details: () => readonly ["teams", "detail"];
+        readonly detail: (id: string) => readonly ["teams", "detail", string];
+        readonly byHandle: (handle: string) => readonly ["teams", "handle", string];
+        readonly byOrganization: (orgId: string) => readonly ["teams", "organization", string];
+        readonly members: (teamId: string) => readonly ["teams", "detail", string, "members"];
+    };
+    readonly spaces: {
+        readonly all: () => readonly ["spaces"];
+        readonly details: () => readonly ["spaces", "detail"];
+        readonly detail: (id: string) => readonly ["spaces", "detail", string];
+        readonly byHandle: (handle: string) => readonly ["spaces", "handle", string];
+        readonly byOrganization: (orgId: string) => readonly ["spaces", "organization", string];
+        readonly orgSpaceByHandle: (orgId: string, handle: string) => readonly ["spaces", "organization", string, "handle", string];
+        readonly byOrganizationAndHandle: (orgHandle: string, spaceHandle: string) => readonly ["spaces", "organization", string, "space", string];
+        readonly userSpaces: () => readonly ["spaces", "user"];
+        readonly items: (spaceId: string) => readonly ["spaces", "detail", string, "items"];
+        readonly members: (spaceId: string) => readonly ["spaces", "detail", string, "members"];
+    };
+    readonly notebooks: {
+        readonly all: () => readonly ["notebooks"];
+        readonly details: () => readonly ["notebooks", "detail"];
+        readonly detail: (id: string) => readonly ["notebooks", "detail", string];
+        readonly bySpace: (spaceId: string) => readonly ["notebooks", "space", string];
+        readonly model: (notebookId: string) => readonly ["notebooks", "detail", string, "model"];
+    };
+    readonly documents: {
+        readonly all: () => readonly ["documents"];
+        readonly details: () => readonly ["documents", "detail"];
+        readonly detail: (id: string) => readonly ["documents", "detail", string];
+        readonly bySpace: (spaceId: string) => readonly ["documents", "space", string];
+        readonly model: (documentId: string) => readonly ["documents", "detail", string, "model"];
+    };
+    readonly cells: {
+        readonly all: () => readonly ["cells"];
+        readonly details: () => readonly ["cells", "detail"];
+        readonly detail: (id: string) => readonly ["cells", "detail", string];
+        readonly bySpace: (spaceId: string) => readonly ["cells", "space", string];
+    };
+    readonly datasets: {
+        readonly all: () => readonly ["datasets"];
+        readonly details: () => readonly ["datasets", "detail"];
+        readonly detail: (id: string) => readonly ["datasets", "detail", string];
+        readonly bySpace: (spaceId: string) => readonly ["datasets", "space", string];
+    };
+    readonly lessons: {
+        readonly all: () => readonly ["lessons"];
+        readonly details: () => readonly ["lessons", "detail"];
+        readonly detail: (id: string) => readonly ["lessons", "detail", string];
+        readonly bySpace: (spaceId: string) => readonly ["lessons", "space", string];
+    };
+    readonly exercises: {
+        readonly all: () => readonly ["exercises"];
+        readonly details: () => readonly ["exercises", "detail"];
+        readonly detail: (id: string) => readonly ["exercises", "detail", string];
+        readonly bySpace: (spaceId: string) => readonly ["exercises", "space", string];
+    };
+    readonly assignments: {
+        readonly all: () => readonly ["assignments"];
+        readonly details: () => readonly ["assignments", "detail"];
+        readonly detail: (id: string) => readonly ["assignments", "detail", string];
+        readonly bySpace: (spaceId: string) => readonly ["assignments", "space", string];
+        readonly forStudent: (assignmentId: string, courseId: string, studentId: string) => readonly ["assignments", "detail", string, "course", string, "student", string];
+        readonly studentVersion: (assignmentId: string) => readonly ["assignments", "detail", string, "studentVersion"];
+    };
+    readonly environments: {
+        readonly all: () => readonly ["environments"];
+        readonly details: () => readonly ["environments", "detail"];
+        readonly detail: (id: string) => readonly ["environments", "detail", string];
+        readonly bySpace: (spaceId: string) => readonly ["environments", "space", string];
+    };
+    readonly pages: {
+        readonly all: () => readonly ["pages"];
+        readonly details: () => readonly ["pages", "detail"];
+        readonly detail: (id: string) => readonly ["pages", "detail", string];
+    };
+    readonly datasources: {
+        readonly all: () => readonly ["datasources"];
+        readonly details: () => readonly ["datasources", "detail"];
+        readonly detail: (id: string) => readonly ["datasources", "detail", string];
+    };
+    readonly secrets: {
+        readonly all: () => readonly ["secrets"];
+        readonly details: () => readonly ["secrets", "detail"];
+        readonly detail: (id: string) => readonly ["secrets", "detail", string];
+    };
+    readonly tokens: {
+        readonly all: () => readonly ["tokens"];
+        readonly details: () => readonly ["tokens", "detail"];
+        readonly detail: (id: string) => readonly ["tokens", "detail", string];
+    };
+    readonly contacts: {
+        readonly all: () => readonly ["contacts"];
+        readonly details: () => readonly ["contacts", "detail"];
+        readonly detail: (id: string) => readonly ["contacts", "detail", string];
+        readonly byHandle: (handle: string) => readonly ["contacts", "handle", string];
+        readonly search: (query: string) => readonly ["contacts", "search", string];
+    };
+    readonly invites: {
+        readonly all: () => readonly ["invites"];
+        readonly byToken: (token: string) => readonly ["invites", "token", string];
+        readonly byAccount: (accountId: string) => readonly ["invites", "account", string];
+    };
+    readonly courses: {
+        readonly all: () => readonly ["courses"];
+        readonly details: () => readonly ["courses", "detail"];
+        readonly detail: (id: string) => readonly ["courses", "detail", string];
+        readonly public: () => readonly ["courses", "public"];
+        readonly instructor: (instructorId: string) => readonly ["courses", "instructor", string];
+        readonly enrollments: () => readonly ["courses", "enrollments", "me"];
+        readonly students: (courseId: string) => readonly ["courses", "detail", string, "students"];
+        readonly student: (courseId: string, studentId: string) => readonly ["courses", "detail", string, "student", string];
+    };
+    readonly schools: {
+        readonly all: () => readonly ["schools"];
+    };
+    readonly inbounds: {
+        readonly all: () => readonly ["inbounds"];
+        readonly detail: (id: string) => readonly ["inbounds", string];
+        readonly byHandle: (handle: string) => readonly ["inbounds", "handle", string];
+    };
+    readonly outbounds: {
+        readonly all: () => readonly ["outbounds"];
+        readonly detail: (id: string) => readonly ["outbounds", string];
+    };
+    readonly items: {
+        readonly all: () => readonly ["items"];
+        readonly public: () => readonly ["items", "public"];
+        readonly bySpace: (spaceId: string) => readonly ["items", "space", string];
+        readonly search: (opts: ISearchOpts) => readonly ["items", "search", ISearchOpts];
+    };
+    readonly layout: {
+        readonly byAccount: (accountHandle: string, spaceHandle?: string) => readonly ["layout", string, string] | readonly ["layout", string];
+    };
+    readonly usages: {
+        readonly user: () => readonly ["usages", "user"];
+        readonly userById: (userId: string) => readonly ["usages", "user", string];
+        readonly platform: () => readonly ["usages", "platform"];
+    };
+    readonly prices: {
+        readonly stripe: () => readonly ["prices", "stripe"];
+    };
+    readonly growth: {
+        readonly kpi: () => readonly ["growth", "kpi"];
+    };
+    readonly oauth2: {
+        readonly authorizationUrl: (queryArgs: Record<string, string>) => readonly ["oauth2", "authz", "url", Record<string, string>];
+        readonly authorizationLinkUrl: (queryArgs: Record<string, string>) => readonly ["oauth2", "authz", "url", "link", Record<string, string>];
+    };
+};
+/**
+ * TanStack Query-based cache hook for Datalayer API
+ *
+ * This hook provides React Query-based data fetching and mutations for all
+ * Datalayer entities. Unlike the original useCache hook, this returns hook
+ * factories that components can use directly.
  *
- * It assumes to be used within a {@link Router} component. If not
- * you must set the options `loginRoute` to `null` (raise an error _Unauthorized_
- * instead of redirecting to the login page).
+ * @param options - Configuration options
+ * @param options.loginRoute - Route to redirect to on authentication failure (default: '/login')
+ *
+ * @returns Object containing all query and mutation hook factories
  */
 export declare const useCache: ({ loginRoute }?: CacheProps) => {
-    addMemberToOrganization: (organizationId: string, userId: string) => Promise<any>;
-    addMemberToOrganizationSpace: (organizationId: string, spaceId: string, accountId: string) => Promise<any>;
-    addMemberToTeam: (teamId: string, userId: string) => Promise<any>;
-    addRoleToOrganizationMember: (organizationId: string, userId: string, roleName: string) => Promise<any>;
-    addRoleToTeamMember: (teamId: string, userId: string, roleName: string) => Promise<any>;
-    assignRoleToUser: (userId: any, roleName: any) => Promise<any>;
-    assignTagToContact: (contactId: any, tagName: any) => Promise<any>;
-    burnCredit: (credits: any) => Promise<any>;
-    changePassword: (handle: any, password: any, passwordConfirm: any) => Promise<any>;
-    clearAllCaches: () => void;
-    clearCachedDatasources: () => void;
-    clearCachedInvites: () => void;
-    clearCachedItems: () => void;
-    clearCachedOrganizations: () => void;
-    clearCachedPages: () => void;
-    clearCachedPublicItems: () => void;
-    clearCachedSecrets: () => void;
-    clearCachedTeams: () => void;
-    clearCachedTokens: () => void;
-    cloneAssignment: (assignmentId: string) => Promise<any>;
-    cloneCell: (cellId: string) => Promise<any>;
-    cloneDocument: (documentId: string) => Promise<any>;
-    cloneExercise: (exerciseId: string) => Promise<any>;
-    cloneLesson: (lessonId: string) => Promise<any>;
-    cloneNotebook: (notebookId: string) => Promise<any>;
-    createNotebook: (spaceId: string, name: string, description?: string, notebookType?: string) => Promise<any>;
-    confirmCourseItemCompletion: (courseId: any, itemType: IItemType, itemId: string, completed: boolean) => Promise<any>;
-    confirmEmailUpdate: (token: any) => Promise<any>;
-    confirmJoinWithToken: (userHandle: any, token: any) => Promise<any>;
-    confirmPassworkWithToken: (userHandle: any, token: any) => Promise<any>;
-    createCheckoutSession: (product: any, location: any) => Promise<any>;
-    createContact: (contact: IContact) => Promise<any>;
-    createDatasource: (datasource: Omit<IDatasource, "id">) => Promise<any>;
-    createOrganization: (organization: Partial<IOrganization>) => Promise<any>;
-    createPage: (page: Omit<IPage, "id">) => Promise<any>;
-    createSecret: (secret: Omit<ISecret, "id">) => Promise<any>;
-    createSpace: (space: Partial<IAnySpace>, organization?: IAnyOrganization) => Promise<any>;
-    createTeam: (team: Partial<ITeam>, organization: IAnyOrganization) => Promise<any>;
-    createToken: (token: Omit<IIAMToken, "id" | "value">) => Promise<any>;
-    createTokenForPasswordChange: (handle: any, password: any, passwordConfirm: any) => Promise<any>;
-    deleteContact: (contactId: string) => Promise<any>;
-    deleteItem: (itemId: string) => Promise<any>;
-    deleteOutbound: (outboundId: string) => Promise<any>;
-    deletePage: (page: IPage) => Promise<any>;
-    deleteSecret: (secret: ISecret) => Promise<any>;
-    disableUserMFA: () => Promise<any>;
-    draftBulkEmailsOutbounds: (params: any) => Promise<any>;
-    enableUserMFA: () => Promise<any>;
-    enrichContactEmail: (contactId: any, useDomain: any) => Promise<any>;
-    enrichContactLinkedin: (contactId: any) => Promise<any>;
-    enrollStudentToCourse: (courseId: string, studentId: string) => Promise<any>;
-    exportSpace: (spaceId: string) => Promise<any>;
-    getAssignment: (assignmentId: any) => IAssignment | undefined;
-    getAssignmentForStudent: (assignmentId: string) => IAssignment | undefined;
-    getAssignmentStudentVersion: (assignmentId: any) => Promise<any>;
-    getCell: (id: string) => ICell | undefined;
-    getContactByHandle: (contactHandle: string) => IContact | undefined;
-    getContactById: (contactId: string) => IContact | undefined;
-    getCourse: (courseId: string) => ICourse | undefined;
-    getCoursesEnrollments: () => ICourse[];
-    getDataset: (id: any) => IDataset | undefined;
-    getDatasource: (datasourceId: string) => IDatasource | undefined;
-    getDatasources: () => IDatasource[];
-    getDocument: (id: any) => IDocument | undefined;
-    getEnvironment: (id: string) => IEnvironment | undefined;
-    getExercise: (id: string) => IExercise | undefined;
-    getGitHubProfile: (accessToken: string) => Promise<any>;
-    getGrowthKPI: () => Promise<any>;
-    getInbound: (id: string) => IInbound | undefined;
-    getInboundByHandle: (handle: string) => IInbound | undefined;
-    getInbounds: () => Promise<any>;
-    getInstructorCourses: () => ICourse[];
-    getInvite: (token: string) => IInvite | undefined;
-    getInvites: () => IInvite[];
-    getLesson: (id: any) => ILesson | undefined;
-    getLinkedinProfile: (accessToken: string) => Promise<LinkedInUser>;
-    getMe: (token?: string) => Promise<IUser | null>;
-    getNotebook: (notebookId: any) => INotebook | undefined;
-    getOAuth2AuthorizationLinkURL: (queryArgs: Record<string, string>) => Promise<{
-        success: boolean;
-        autorization_url: string;
-    }>;
-    getOAuth2AuthorizationURL: (queryArgs: Record<string, string>) => Promise<{
-        success: boolean;
-        autorization_url: string;
-    }>;
-    getOrganizationByHandle: (organizationHandle: string) => IOrganization | undefined;
-    getOrganizationById: (organizationId: string) => IOrganization | undefined;
-    getOrganizationSpace: (organizationId: string, spaceId: string) => IAnySpace | undefined;
-    getOrganizationSpaceByHandle: (organizationHandle: string, spaceHandle: string) => IAnySpace | undefined;
-    getOrganizationSpaces: (organizationId: string) => IAnySpace[];
-    getOutbound: (id: string) => IOutbound | undefined;
-    getOutbounds: () => Promise<any>;
-    getPage: (pageId: string) => IPage | undefined;
-    getPages: () => IPage[];
-    getPlatformUsages: () => Promise<{
-        success: boolean;
-        message: string;
-        usages?: IUsage[];
-    }>;
-    getPublicCourses: () => ICourse[];
-    getPublicItems: () => ISpaceItem[];
-    getSchools: () => ISchool[];
-    getSecret: (secretId: string) => ISecret | undefined;
-    getSecrets: () => ISecret[];
-    getSpaceAssignment: (id: any) => IAssignment | undefined;
-    getSpaceAssignments: () => IAssignment[];
-    getSpaceCells: () => ICell[];
-    getSpaceDatasets: () => IDataset[];
-    getSpaceDocument: (id: any) => IDocument | undefined;
-    getSpaceDocuments: () => IDocument[];
-    getSpaceEnvironments: () => IEnvironment[];
-    getSpaceExercises: () => IExercise[];
-    getSpaceItems: () => ISpaceItem[];
-    getSpaceLesson: (id: any) => ILesson | undefined;
-    getSpaceLessons: () => ILesson[];
-    getSpaceNotebook: (id: any) => INotebook | undefined;
-    getSpaceNotebooks: () => INotebook[];
-    getStudent: (courseId: any, studentId: any) => IStudent | undefined;
-    getTeamByHandle: (teamHandle: string) => ITeam | undefined;
-    getTeamById: (teamId: string) => ITeam | undefined;
-    getTeamsByOrganizationId: (organizationId: string) => ITeam[] | undefined;
-    getToken: (tokenId: string) => IIAMToken | undefined;
-    getTokens: () => IIAMToken[];
-    getUsages: () => Promise<{
-        success: boolean;
-        message: string;
-        usages?: IUsage[];
-    }>;
-    getUsagesForUser: (userId: string) => Promise<{
-        success: boolean;
-        message: string;
-        usages?: IUsage[];
-    }>;
-    getUser: (id: string) => IUser | undefined;
-    getUserByHandle: (handle: string) => IUser | undefined;
-    getUserCredits: (userId: any) => Promise<any>;
-    getUserOrganizationById: (organizationId: string) => IAnyOrganization | undefined;
-    getUserOrganizations: () => IAnyOrganization[];
-    getUserSpace: (userId: string) => IAnySpace | undefined;
-    getUserSpaceByHandle: (userHandle: string) => IAnySpace | undefined;
-    getUserSpaces: () => IAnySpace[];
-    getUserSurveys: (userId: string) => Promise<any>;
-    gradeAssignmentForStudent: (courseId: string, user: IUser, assignmentId: string, model: any) => Promise<any>;
-    joinWithInvite: (formValues: any, token: any) => Promise<any>;
-    launchBulkEmailsOutbounds: (outboundId: string) => Promise<any>;
-    linkUserWithContact: (userId: any, contactId: any) => Promise<any>;
-    login: (handle: any, password: any) => Promise<any>;
-    logout: () => Promise<any>;
-    makeItemPrivate: (id: string) => Promise<any>;
-    makeItemPublic: (id: string) => Promise<any>;
-    makeSpacePrivate: (spaceId: string) => Promise<any>;
-    makeSpacePublic: (spaceId: string) => Promise<any>;
-    postLinkedinShare: (linkedinUser: ILinkedInUser, postText: string, accessToken: string) => Promise<any>;
-    postLinkedinShareWithUpload: (linkedinUser: ILinkedInUser, postText: string, uploadObject: string, accessToken: string) => Promise<any>;
-    proxyGET: (url: string, token: string) => Promise<any>;
-    proxyPOST: (url: string, body: object, token: string) => Promise<any>;
-    proxyPUT: (url: string, body: object, token: string) => Promise<any>;
-    putInvite: (token: string) => Promise<any>;
-    refreshAccount: (accountHandle: string) => Promise<any>;
-    refreshAssignment: (assignmentId: string) => Promise<any>;
-    refreshAssignmentForStudent: (courseId: string, user: IUser, assignmentId: string) => Promise<any>;
-    refreshCell: (id: string) => Promise<any>;
-    refreshContact: (contactId: string) => Promise<any>;
-    refreshCourse: (courseId: string) => Promise<any>;
-    refreshCoursesEnrollments: () => Promise<any>;
-    refreshDataset: (id: string) => Promise<any>;
-    refreshDatasource: (datasourceId: string) => Promise<any>;
-    refreshDatasources: () => Promise<any>;
-    refreshDocument: (id: string) => Promise<any>;
-    refreshEnvironment: (id: string) => Promise<any>;
-    refreshExercise: (id: string) => Promise<any>;
-    refreshInbound: (userId: string) => Promise<any>;
-    refreshInstructorCourses: () => Promise<any>;
-    refreshInvite: (token: string) => Promise<any>;
-    refreshInvites: (accountId: string) => Promise<any>;
-    refreshLayout: (accountHandle: string, spaceHandle?: string, user?: IUser) => Promise<any>;
-    refreshLesson: (id: string) => Promise<any>;
-    refreshNotebook: (notebookId: string) => Promise<any>;
-    refreshOrganization: (user: IUser, organizationId: string) => Promise<any>;
-    refreshOrganizationSpace: (organizationId: string, spaceId: string) => Promise<any>;
-    refreshOrganizationSpaces: (organizationId: string) => Promise<any>;
-    refreshOutbound: (outboundId: string) => Promise<any>;
-    refreshPage: (pageId: string) => Promise<any>;
-    refreshPages: () => Promise<any>;
-    refreshPublicCourses: () => Promise<any>;
-    refreshPublicItems: () => Promise<any>;
-    refreshSchools: () => Promise<any>;
-    refreshSecret: (secretId: string) => Promise<any>;
-    refreshSecrets: () => Promise<any>;
-    refreshSpaceAssignments: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
-    refreshSpaceCells: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
-    refreshSpaceDatasets: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
-    refreshSpaceDocuments: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
-    refreshSpaceEnvironments: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
-    refreshSpaceExercises: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
-    refreshSpaceItems: (spaceId: string) => Promise<any>;
-    refreshSpaceLessons: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
-    refreshSpaceNotebooks: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
-    refreshStripePrices: () => Promise<IRESTBaseResponse & {
-        prices: IPrice[];
-    }>;
-    refreshStudent: (courseId: any, studentHandle: any) => Promise<any>;
-    refreshTeam: (teamId: string, organizationId: string) => Promise<any>;
-    refreshTeams: (organizationId: string) => Promise<any>;
-    refreshToken: (tokenId: string) => Promise<any>;
-    refreshTokens: () => Promise<any>;
-    refreshUser: (userId: string) => Promise<any>;
-    refreshUserOrganizations: (user: IUser) => Promise<any>;
-    refreshUserSpace: (userId: string, spaceId: string) => Promise<any>;
-    refreshUserSpaces: () => Promise<any>;
-    registerToWaitingList: (formData: WaitingListFormData) => void;
-    removeMemberFromOrganization: (organizationId: string, userId: string) => Promise<any>;
-    removeMemberFromOrganizationSpace: (organizationId: string, spaceId: string, accountId: string) => Promise<any>;
-    removeMemberFromTeam: (teamId: string, userId: string) => Promise<any>;
-    removeRoleFromOrganizationMember: (organizationId: string, userId: string, roleName: string) => Promise<any>;
-    removeRoleFromTeamMember: (teamId: string, userId: string, roleName: string) => Promise<any>;
-    removeStudentFromCourse: (courseId: string, studentId: string) => Promise<any>;
-    requestEmailUpdate: (email: any) => Promise<any>;
-    requestInvite: (firstName: string, lastName: string, email: string, socialUrl: string) => Promise<any>;
-    requestJoin: (handle: any, email: any, firstName: any, lastName: any, password: any, passwordConfirm: any) => Promise<any>;
-    requestJoinToken: (handle: any, email: any, firstName: any, lastName: any, password: any, passwordConfirm: any) => Promise<any>;
-    requestPlatformSupport: (subject: any, message: any, email: any, brand: any) => Promise<any>;
-    requestPlatformSupport2: (accountHandle: any, firstName: any, lastName: any, email: any, message: any) => Promise<any>;
-    resetAssignmentForStudent: (courseId: string, user: IUser, assignmentId: string) => Promise<any>;
-    searchContacts: (query: string) => Promise<any>;
-    searchPublicItems: (opts?: ISearchOpts) => Promise<any>;
-    searchUsers: (namingPattern: string) => Promise<any>;
-    sendInvite: (invite: IInvite) => Promise<any>;
-    sendInviteToContact: (contact: IContact, message: string) => Promise<any>;
-    sendLinkedinConnectionRequest: (contact: IContact, message: string) => Promise<any>;
-    sendOutboundEmailToUser: (userId: string, recipient: string, subject: string, content: string) => Promise<any>;
-    setCourseItems: (courseId: any, itemIds: any) => Promise<any>;
-    subscribeUserToOutbounds: (userId: string) => Promise<any>;
-    toInbound: (u: any) => IInbound | undefined;
-    toOutbound: (u: any) => IOutbound | undefined;
-    tryBulkEmailsOutbounds: (outboundId: string) => Promise<any>;
-    unassignRoleFromUser: (userId: any, roleName: any) => Promise<any>;
-    unassignTagFromContact: (contactId: any, tagName: any) => Promise<any>;
-    unlinkUserFromContact: (userId: any, contactId: any) => Promise<any>;
-    unsubscribeContactFromOutbounds: (contactId: string) => Promise<any>;
-    unsubscribeInviteeFromOutbounds: (token: string) => Promise<any>;
-    unsubscribeUserFromOutbounds: (userId: string) => Promise<any>;
-    updateCell: (cell: {
+    useLogin: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        handle: string;
+        password: string;
+    }, unknown>;
+    useLogout: () => import("@tanstack/react-query").UseMutationResult<any, Error, void, unknown>;
+    useMe: (token?: string) => import("@tanstack/react-query").UseQueryResult<IUser | null | undefined, Error>;
+    useUpdateMe: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        email: string;
+        firstName: string;
+        lastName: string;
+    }, unknown>;
+    useWhoami: () => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useChangePassword: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        handle: string;
+        password: string;
+        passwordConfirm: string;
+    }, unknown>;
+    useRequestEmailUpdate: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useConfirmEmailUpdate: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useRequestJoin: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        handle: string;
+        email: string;
+        firstName: string;
+        lastName: string;
+        password: string;
+        passwordConfirm: string;
+    }, unknown>;
+    useRequestJoinToken: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        handle: string;
+        email: string;
+        firstName: string;
+        lastName: string;
+        password: string;
+        passwordConfirm: string;
+    }, unknown>;
+    useJoinWithInvite: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        formValues: any;
+        token: string;
+    }, unknown>;
+    useConfirmJoinWithToken: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        userHandle: string;
+        token: string;
+    }, unknown>;
+    useCreateTokenForPasswordChange: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        handle: string;
+        password: string;
+        passwordConfirm: string;
+    }, unknown>;
+    useConfirmPasswordWithToken: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        userHandle: string;
+        token: string;
+    }, unknown>;
+    useOAuth2AuthorizationURL: () => import("@tanstack/react-query").UseMutationResult<string, Error, Record<string, string>, unknown>;
+    useOAuth2AuthorizationLinkURL: () => import("@tanstack/react-query").UseMutationResult<string, Error, Record<string, string>, unknown>;
+    useGetGitHubProfile: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useGetLinkedinProfile: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    usePostLinkedinShare: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        linkedinUserUrn: string;
+        postText: string;
+        accessToken: string;
+    }, unknown>;
+    usePostLinkedinShareWithUpload: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        linkedinUserUrn: string;
+        postText: string;
+        uploadObject: string;
+        accessToken: string;
+    }, unknown>;
+    useRegisterToWaitingList: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        firstName: string;
+        lastName: string;
+        email: string;
+        affiliation?: string;
+    }, unknown>;
+    useProxyGET: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        url: string;
+        token: string;
+    }, unknown>;
+    useProxyPOST: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        url: string;
+        body: object;
+        token: string;
+    }, unknown>;
+    useProxyPUT: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        url: string;
+        body: object;
+        token: string;
+    }, unknown>;
+    useUser: (userId: string) => import("@tanstack/react-query").UseQueryResult<IUser | undefined, Error>;
+    useUserByHandle: (handle: string) => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useSearchUsers: (namingPattern: string) => import("@tanstack/react-query").UseQueryResult<IUser[], Error>;
+    useUpdateUserOnboarding: () => import("@tanstack/react-query").UseMutationResult<any, Error, IUserOnboarding, unknown>;
+    useUpdateUserSettings: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        userId: string;
+        settings: IUserSettings;
+    }, unknown>;
+    useRefreshUser: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useUserCredits: (userId: string) => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useUpdateUserCredits: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        userId: string;
+        credits: number;
+        brand?: string;
+    }, unknown>;
+    useAssignRoleToUser: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        userId: string;
+        roleName: string;
+    }, unknown>;
+    useUnassignRoleFromUser: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        userId: string;
+        roleName: string;
+    }, unknown>;
+    useUpdateUserCreditsQuota: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        userId: string;
+        quota?: number;
+    }, unknown>;
+    useUsages: (options?: Omit<UseQueryOptions<unknown[]>, "queryKey" | "queryFn">) => import("@tanstack/react-query").UseQueryResult<unknown[], Error>;
+    useUsagesForUser: (userId: string, options?: Omit<UseQueryOptions<unknown[]>, "queryKey" | "queryFn">) => import("@tanstack/react-query").UseQueryResult<unknown[], Error>;
+    usePlatformUsages: (options?: Omit<UseQueryOptions<unknown[]>, "queryKey" | "queryFn">) => import("@tanstack/react-query").UseQueryResult<unknown[], Error>;
+    useOrganization: (organizationId: string) => import("@tanstack/react-query").UseQueryResult<IOrganization, Error>;
+    useOrganizationByHandle: (handle: string) => import("@tanstack/react-query").UseQueryResult<IOrganization | null, Error>;
+    useUserOrganizations: () => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useCreateOrganization: () => import("@tanstack/react-query").UseMutationResult<any, Error, Partial<IOrganization>, unknown>;
+    useUpdateOrganization: () => import("@tanstack/react-query").UseMutationResult<any, Error, Partial<IAnyOrganization>, unknown>;
+    useAddMemberToOrganization: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        organizationId: string;
+        userId: string;
+    }, unknown>;
+    useRemoveMemberFromOrganization: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        organizationId: string;
+        userId: string;
+    }, unknown>;
+    useAddRoleToOrganizationMember: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        organizationId: string;
+        userId: string;
+        roleName: string;
+    }, unknown>;
+    useRemoveRoleFromOrganizationMember: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        organizationId: string;
+        userId: string;
+        roleName: string;
+    }, unknown>;
+    useRefreshOrganization: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useRefreshUserOrganizations: () => import("@tanstack/react-query").UseMutationResult<any, Error, void, unknown>;
+    useUserOrganizationById: (organizationId: string) => any;
+    useClearCachedOrganizations: (options?: UseMutationOptions<void, Error, void>) => import("@tanstack/react-query").UseMutationResult<void, Error, void, unknown>;
+    useTeam: (teamId: string, organizationId: string) => import("@tanstack/react-query").UseQueryResult<ITeam, Error>;
+    useTeamByHandle: (handle: string) => import("@tanstack/react-query").UseQueryResult<ITeam | null, Error>;
+    useTeamsByOrganization: (organizationId: string) => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useCreateTeam: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        team: Partial<ITeam>;
+        organization: IAnyOrganization;
+    }, unknown>;
+    useUpdateTeam: () => import("@tanstack/react-query").UseMutationResult<any, Error, Partial<ITeam>, unknown>;
+    useAddMemberToTeam: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        teamId: string;
+        userId: string;
+    }, unknown>;
+    useRemoveMemberFromTeam: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        teamId: string;
+        userId: string;
+    }, unknown>;
+    useAddRoleToTeamMember: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        teamId: string;
+        userId: string;
+        roleName: string;
+    }, unknown>;
+    useRemoveRoleFromTeamMember: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        teamId: string;
+        userId: string;
+        roleName: string;
+    }, unknown>;
+    useRefreshTeam: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        teamId: string;
+        organizationId: string;
+    }, unknown>;
+    useRefreshTeams: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useClearCachedTeams: (options?: UseMutationOptions<void, Error, void>) => import("@tanstack/react-query").UseMutationResult<void, Error, void, unknown>;
+    useSchools: () => import("@tanstack/react-query").UseQueryResult<ISchool[], Error>;
+    useRefreshSchools: (options?: UseMutationOptions<unknown, Error, void>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, void, unknown>;
+    useSpace: (spaceId: string) => import("@tanstack/react-query").UseQueryResult<IAnySpace, Error>;
+    useOrganizationSpace: (organizationId: string, spaceId: string) => import("@tanstack/react-query").UseQueryResult<IAnySpace, Error>;
+    useOrganizationSpaceByHandle: (organizationId: string, handle: string) => import("@tanstack/react-query").UseQueryResult<IAnySpace | null, Error>;
+    useOrganizationSpaces: (organizationId: string) => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useUserSpace: (spaceId: string) => import("@tanstack/react-query").UseQueryResult<IAnySpace | null, Error>;
+    useUserSpaceByHandle: (handle: string) => import("@tanstack/react-query").UseQueryResult<{} | null, Error>;
+    useUserSpaces: () => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useCreateSpace: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        space: Partial<IAnySpace>;
+        organization?: IAnyOrganization;
+    }, unknown>;
+    useUpdateSpace: () => import("@tanstack/react-query").UseMutationResult<any, Error, Partial<IAnySpace>, unknown>;
+    useUpdateOrganizationSpace: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        organizationId: string;
+        spaceId: string;
+        updates: Partial<IAnySpace>;
+    }, unknown>;
+    useAddMemberToOrganizationSpace: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        organizationId: string;
+        spaceId: string;
+        accountId: string;
+    }, unknown>;
+    useRemoveMemberFromOrganizationSpace: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        organizationId: string;
+        spaceId: string;
+        accountId: string;
+    }, unknown>;
+    useMakeSpacePublic: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useMakeSpacePrivate: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useRefreshOrganizationSpace: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        organizationId: string;
+        spaceId: string;
+    }, unknown>;
+    useRefreshOrganizationSpaces: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useRefreshUserSpaces: () => import("@tanstack/react-query").UseMutationResult<any, Error, void, unknown>;
+    useRefreshUserSpace: (options?: UseMutationOptions<unknown, Error, {
+        userId: string;
+        spaceId: string;
+    }>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, {
+        userId: string;
+        spaceId: string;
+    }, unknown>;
+    useRefreshLayout: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        accountHandle: string;
+        spaceHandle?: string;
+    }, unknown>;
+    useExportSpace: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useCourse: (courseId: string) => import("@tanstack/react-query").UseQueryResult<ICourse | undefined, Error>;
+    useUpdateCourse: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        courseId: string;
+        name: string;
+        description: string;
+    }, unknown>;
+    usePublicCourses: () => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useInstructorCourses: (userId?: string) => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useCourseEnrollments: () => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useEnrollStudentToCourse: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        courseId: string;
+        studentId: string;
+    }, unknown>;
+    useRemoveStudentFromCourse: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        courseId: string;
+        studentId: string;
+    }, unknown>;
+    useStudent: (courseId: string, studentId: string, options?: Omit<UseQueryOptions<unknown>, "queryKey" | "queryFn">) => import("@tanstack/react-query").UseQueryResult<unknown, Error>;
+    useConfirmCourseItemCompletion: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        courseId: string;
+        itemType: string;
+        itemId: string;
+        completed: boolean;
+    }, unknown>;
+    useSetCourseItems: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        courseId: string;
+        itemIds: string[];
+    }, unknown>;
+    useRefreshCourse: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useRefreshPublicCourses: (options?: UseMutationOptions<unknown, Error, void>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, void, unknown>;
+    useRefreshInstructorCourses: (options?: UseMutationOptions<unknown, Error, void>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, void, unknown>;
+    useRefreshCoursesEnrollments: (options?: UseMutationOptions<unknown, Error, void>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, void, unknown>;
+    useRefreshStudent: (options?: UseMutationOptions<unknown, Error, {
+        courseId: string;
+        studentHandle: string;
+    }>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, {
+        courseId: string;
+        studentHandle: string;
+    }, unknown>;
+    useNotebook: (notebookId: string) => import("@tanstack/react-query").UseQueryResult<INotebook, Error>;
+    useNotebooksBySpace: (spaceId: string) => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useCreateNotebook: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        spaceId: string;
+        name: string;
+        description?: string;
+        notebookType?: string;
+    }, unknown>;
+    useUpdateNotebook: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        id: string;
+        name: string;
+        description: string;
+    }, unknown>;
+    useUpdateNotebookModel: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        notebookId: string;
+        nbformat: unknown;
+    }, unknown>;
+    useCloneNotebook: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useRefreshNotebook: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useRefreshSpaceNotebooks: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useDocument: (documentId: string) => import("@tanstack/react-query").UseQueryResult<IDocument, Error>;
+    useDocumentsBySpace: (spaceId: string) => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useUpdateDocument: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        id: string;
+        name: string;
+        description: string;
+    }, unknown>;
+    useUpdateDocumentModel: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        id: string;
+        model: unknown;
+    }, unknown>;
+    useCloneDocument: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useRefreshDocument: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useRefreshSpaceDocuments: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useCell: (cellId: string) => import("@tanstack/react-query").UseQueryResult<ICell | undefined, Error>;
+    useCellsBySpace: (spaceId: string) => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useUpdateCell: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
         id: string;
         name: string;
         description: string;
@@ -269,40 +551,405 @@ export declare const useCache: ({ loginRoute }?: CacheProps) => {
         outputshotUrl?: string;
         outputshotData?: string;
         spaceId: string;
-    }) => Promise<any>;
-    updateContact: (contactId: any, contact: IContact) => Promise<any>;
-    updateCourse: (courseId: any, name: any, description: any) => Promise<any>;
-    updateDataset: (id: any, name: any, description: any) => Promise<any>;
-    updateDatasource: (datasource: IDatasource) => Promise<any>;
-    updateDocument: (id: any, name: any, description: any) => Promise<any>;
-    updateDocumentModel: (id: any, model: any) => Promise<any>;
-    updateExercise: ({ id, name, description, help, codePre, codeSolution, codeQuestion, codeTest, }: {
-        id: any;
-        name: any;
-        description: any;
-        help: any;
-        codePre: any;
-        codeSolution: any;
-        codeQuestion: any;
-        codeTest: any;
-    }) => Promise<any>;
-    updateExercisePoints: (id: any, codeStudent: any, points: any) => Promise<any>;
-    updateMe: (email: any, firstName: any, lastName: any) => Promise<any>;
-    updateNotebook: (id: any, name: any, description: any) => Promise<any>;
-    updateNotebookModel: (notebookId: any, nbformat: any) => Promise<any>;
-    updateOrganization: (organization: Partial<IAnyOrganization>) => Promise<any>;
-    updateOrganizationSpace: (organization: IAnyOrganization, space: Partial<IAnySpace>) => Promise<any>;
-    updatePage: (page: Pick<IPage, "id" | "name" | "description" | "tags">) => Promise<any>;
-    updateSecret: (secret: ISecret) => Promise<any>;
-    updateSpace: (space: Partial<IAnySpace>) => Promise<any>;
-    updateTeam: (team: Partial<ITeam>) => Promise<any>;
-    updateToken: (token: IIAMToken) => Promise<any>;
-    updateUserCredits: (userId: any, credits: any, brand: any) => Promise<any>;
-    updateUserCreditsQuota: (userId: string, quota?: number) => Promise<any>;
-    updateUserOnboarding: (onboarding: IUserOnboarding) => Promise<any>;
-    updateUserSettings: (userId: string, settings: IUserSettings) => Promise<any>;
-    validateUserMFACode: (userUid: any, code: string) => Promise<any>;
-    whoami: () => Promise<any>;
+    }, unknown>;
+    useCloneCell: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useRefreshCell: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useRefreshSpaceCells: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useDataset: (datasetId: string) => import("@tanstack/react-query").UseQueryResult<IDataset | undefined, Error>;
+    useDatasetsBySpace: (spaceId: string) => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useUpdateDataset: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        id: string;
+        name: string;
+        description: string;
+        spaceId?: string;
+    }, unknown>;
+    useRefreshDataset: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useRefreshSpaceDatasets: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useEnvironment: (environmentId: string) => import("@tanstack/react-query").UseQueryResult<IEnvironment | undefined, Error>;
+    useEnvironmentsBySpace: (spaceId: string) => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useRefreshEnvironment: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useRefreshSpaceEnvironments: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useLesson: (lessonId: string) => import("@tanstack/react-query").UseQueryResult<ILesson | undefined, Error>;
+    useLessonsBySpace: (spaceId: string) => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useCloneLesson: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useRefreshLesson: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useRefreshSpaceLessons: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useExercise: (exerciseId: string) => import("@tanstack/react-query").UseQueryResult<IExercise | undefined, Error>;
+    useExercisesBySpace: (spaceId: string) => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useUpdateExercise: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        id: string;
+        name: string;
+        description: string;
+        help?: string;
+        codePre?: string;
+        codeSolution?: string;
+        codeQuestion?: string;
+        codeTest?: string;
+    }, unknown>;
+    useCloneExercise: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useUpdateExercisePoints: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        exerciseId: string;
+        codeStudent: string;
+        points: number;
+    }, unknown>;
+    useRefreshExercise: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useRefreshSpaceExercises: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useAssignment: (assignmentId: string) => import("@tanstack/react-query").UseQueryResult<IAssignment | undefined, Error>;
+    useAssignmentsBySpace: (spaceId: string) => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useCloneAssignment: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useAssignmentForStudent: (assignmentId: string, courseId: string, userId: string, options?: Omit<UseQueryOptions<unknown>, "queryKey" | "queryFn">) => import("@tanstack/react-query").UseQueryResult<unknown, Error>;
+    useAssignmentStudentVersion: (assignmentId: string, options?: Omit<UseQueryOptions<unknown>, "queryKey" | "queryFn">) => import("@tanstack/react-query").UseQueryResult<unknown, Error>;
+    useGradeAssignmentForStudent: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        assignmentId: string;
+        courseId: string;
+        userId: string;
+        model: unknown;
+    }, unknown>;
+    useResetAssignmentForStudent: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        assignmentId: string;
+        courseId: string;
+        userId: string;
+    }, unknown>;
+    useRefreshAssignment: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useRefreshAssignmentForStudent: (options?: UseMutationOptions<unknown, Error, {
+        courseId: string;
+        userId: string;
+        assignmentId: string;
+    }>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, {
+        courseId: string;
+        userId: string;
+        assignmentId: string;
+    }, unknown>;
+    useRefreshSpaceAssignments: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useDeleteItem: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useSpaceItems: (spaceId: string) => import("@tanstack/react-query").UseQueryResult<any[], Error>;
+    useMakeItemPublic: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useMakeItemPrivate: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useSearchPublicItems: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        q?: string;
+        types?: string[];
+        max?: number;
+    }, unknown>;
+    usePublicItems: (options?: UseQueryOptions<unknown, Error>) => import("@tanstack/react-query").UseQueryResult<unknown, Error>;
+    useRefreshPublicItems: (options?: UseMutationOptions<unknown, Error, void>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, void, unknown>;
+    useRefreshSpaceItems: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useClearCachedPublicItems: (options?: UseMutationOptions<void, Error, void>) => import("@tanstack/react-query").UseMutationResult<void, Error, void, unknown>;
+    useClearCachedItems: (options?: UseMutationOptions<void, Error, void>) => import("@tanstack/react-query").UseMutationResult<void, Error, void, unknown>;
+    usePage: (pageId: string) => import("@tanstack/react-query").UseQueryResult<IPage | undefined, Error>;
+    usePages: () => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useCreatePage: () => import("@tanstack/react-query").UseMutationResult<any, Error, Omit<IPage, "id">, unknown>;
+    useUpdatePage: () => import("@tanstack/react-query").UseMutationResult<any, Error, Pick<IPage, "id" | "name" | "tags" | "description">, unknown>;
+    useDeletePage: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useDatasource: (datasourceId: string) => import("@tanstack/react-query").UseQueryResult<IDatasource | null | undefined, Error>;
+    useDatasources: () => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useCreateDatasource: () => import("@tanstack/react-query").UseMutationResult<any, Error, Omit<IDatasource, "id">, unknown>;
+    useUpdateDatasource: () => import("@tanstack/react-query").UseMutationResult<any, Error, IDatasource, unknown>;
+    useSecret: (secretId: string) => import("@tanstack/react-query").UseQueryResult<ISecret | null | undefined, Error>;
+    useSecrets: () => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useCreateSecret: () => import("@tanstack/react-query").UseMutationResult<any, Error, Omit<ISecret, "id">, unknown>;
+    useUpdateSecret: () => import("@tanstack/react-query").UseMutationResult<any, Error, ISecret, unknown>;
+    useDeleteSecret: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useToken: (tokenId: string) => import("@tanstack/react-query").UseQueryResult<IIAMToken | null | undefined, Error>;
+    useTokens: () => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useCreateToken: () => import("@tanstack/react-query").UseMutationResult<any, Error, Omit<IIAMToken, "id" | "value">, unknown>;
+    useUpdateToken: () => import("@tanstack/react-query").UseMutationResult<any, Error, IIAMToken, unknown>;
+    useInvite: (token: string) => import("@tanstack/react-query").UseQueryResult<import("../models").IInvite | undefined, Error>;
+    useInvitesByUser: (accountId: string) => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    usePutInvite: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useRequestInvite: (options?: UseMutationOptions<unknown, Error, {
+        firstName: string;
+        lastName: string;
+        email: string;
+        socialUrl: string;
+    }>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, {
+        firstName: string;
+        lastName: string;
+        email: string;
+        socialUrl: string;
+    }, unknown>;
+    useSendInvite: (options?: UseMutationOptions<unknown, Error, {
+        email: string;
+        firstName: string;
+        lastName: string;
+        message: string;
+        brand: string;
+    }>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, {
+        email: string;
+        firstName: string;
+        lastName: string;
+        message: string;
+        brand: string;
+    }, unknown>;
+    useRefreshInvite: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useRefreshInvites: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useClearCachedInvites: (options?: UseMutationOptions<void, Error, void>) => import("@tanstack/react-query").UseMutationResult<void, Error, void, unknown>;
+    useContact: (contactId: string) => import("@tanstack/react-query").UseQueryResult<IContact | undefined, Error>;
+    useContactByHandle: (handle: string) => import("@tanstack/react-query").UseQueryResult<IContact | null | undefined, Error>;
+    useSearchContacts: (query: string) => import("@tanstack/react-query").UseQueryResult<any, Error>;
+    useCreateContact: () => import("@tanstack/react-query").UseMutationResult<any, Error, IContact, unknown>;
+    useUpdateContact: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        contactId: string;
+        contact: IContact;
+    }, unknown>;
+    useDeleteContact: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useAssignTagToContact: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        contactId: string;
+        tagName: string;
+    }, unknown>;
+    useUnassignTagFromContact: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        contactId: string;
+        tagName: string;
+    }, unknown>;
+    useSendInviteToContact: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        contactId: string;
+        message: string;
+    }, unknown>;
+    useEnrichContactEmail: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        contactId: string;
+        useDomain: boolean;
+    }, unknown>;
+    useEnrichContactLinkedin: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useSendLinkedinConnectionRequest: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        contactId: string;
+        message: string;
+    }, unknown>;
+    useLinkUserWithContact: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        userId: string;
+        contactId: string;
+    }, unknown>;
+    useUnlinkUserFromContact: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        userId: string;
+        contactId: string;
+    }, unknown>;
+    useRefreshContact: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useInbounds: (options?: Omit<UseQueryOptions<unknown[]>, "queryKey" | "queryFn">) => import("@tanstack/react-query").UseQueryResult<unknown[], Error>;
+    useInbound: (id: string, options?: UseQueryOptions<unknown, Error>) => import("@tanstack/react-query").UseQueryResult<unknown, Error>;
+    useInboundByHandle: (handle: string, options?: UseQueryOptions<unknown, Error>) => import("@tanstack/react-query").UseQueryResult<unknown, Error>;
+    useRefreshInbound: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useOutbound: (outboundId: string, options?: Omit<UseQueryOptions<unknown>, "queryKey" | "queryFn">) => import("@tanstack/react-query").UseQueryResult<unknown, Error>;
+    useOutbounds: (options?: Omit<UseQueryOptions<unknown[]>, "queryKey" | "queryFn">) => import("@tanstack/react-query").UseQueryResult<unknown[], Error>;
+    useDraftBulkEmailsOutbounds: () => import("@tanstack/react-query").UseMutationResult<any, Error, unknown, unknown>;
+    useTryBulkEmailsOutbounds: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useLaunchBulkEmailsOutbounds: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useSendOutboundEmailToUser: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        userId: string;
+        recipient: string;
+        subject: string;
+        content: string;
+    }, unknown>;
+    useDeleteOutbound: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useSubscribeUserToOutbounds: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useUnsubscribeUserFromOutbounds: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useUnsubscribeContactFromOutbounds: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useUnsubscribeInviteeFromOutbounds: () => import("@tanstack/react-query").UseMutationResult<any, Error, string, unknown>;
+    useRefreshOutbound: (options?: UseMutationOptions<unknown, Error, string>) => import("@tanstack/react-query").UseMutationResult<unknown, Error, string, unknown>;
+    useEnableUserMFA: () => import("@tanstack/react-query").UseMutationResult<any, Error, void, unknown>;
+    useDisableUserMFA: () => import("@tanstack/react-query").UseMutationResult<any, Error, void, unknown>;
+    useValidateUserMFACode: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        userUid: string;
+        code: string;
+    }, unknown>;
+    useCreateCheckoutSession: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        product: any;
+        location: Location;
+    }, unknown>;
+    useBurnCredit: () => import("@tanstack/react-query").UseMutationResult<any, Error, number, unknown>;
+    useStripePrices: (options?: Omit<UseQueryOptions<unknown[]>, "queryKey" | "queryFn">) => import("@tanstack/react-query").UseQueryResult<unknown[], Error>;
+    useRequestPlatformSupport: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        subject: string;
+        message: string;
+        email: string;
+        brand: string;
+    }, unknown>;
+    useRequestPlatformSupport2: () => import("@tanstack/react-query").UseMutationResult<any, Error, {
+        accountHandle: string;
+        firstName: string;
+        lastName: string;
+        email: string;
+        message: string;
+    }, unknown>;
+    useUserSurveys: (userId: string, options?: Omit<UseQueryOptions<unknown>, "queryKey" | "queryFn">) => import("@tanstack/react-query").UseQueryResult<unknown, Error>;
+    useGrowthKPI: (options?: Omit<UseQueryOptions<unknown>, "queryKey" | "queryFn">) => import("@tanstack/react-query").UseQueryResult<unknown, Error>;
+    queryKeys: {
+        readonly auth: {
+            readonly me: () => readonly ["auth", "me"];
+            readonly whoami: () => readonly ["auth", "whoami"];
+        };
+        readonly users: {
+            readonly all: () => readonly ["users"];
+            readonly lists: () => readonly ["users", "list"];
+            readonly list: (filters?: string) => readonly ["users", "list", {
+                readonly filters: string | undefined;
+            }];
+            readonly details: () => readonly ["users", "detail"];
+            readonly detail: (id: string) => readonly ["users", "detail", string];
+            readonly byHandle: (handle: string) => readonly ["users", "handle", string];
+            readonly search: (pattern: string) => readonly ["users", "search", string];
+            readonly settings: (userId: string) => readonly ["users", "detail", string, "settings"];
+            readonly onboarding: (userId: string) => readonly ["users", "detail", string, "onboarding"];
+            readonly surveys: (userId: string) => readonly ["users", "detail", string, "surveys"];
+            readonly credits: (userId: string) => readonly ["users", "detail", string, "credits"];
+        };
+        readonly organizations: {
+            readonly all: () => readonly ["organizations"];
+            readonly lists: () => readonly ["organizations", "list"];
+            readonly details: () => readonly ["organizations", "detail"];
+            readonly detail: (id: string) => readonly ["organizations", "detail", string];
+            readonly byHandle: (handle: string) => readonly ["organizations", "handle", string];
+            readonly userOrgs: () => readonly ["organizations", "user"];
+            readonly members: (orgId: string) => readonly ["organizations", "detail", string, "members"];
+        };
+        readonly teams: {
+            readonly all: () => readonly ["teams"];
+            readonly details: () => readonly ["teams", "detail"];
+            readonly detail: (id: string) => readonly ["teams", "detail", string];
+            readonly byHandle: (handle: string) => readonly ["teams", "handle", string];
+            readonly byOrganization: (orgId: string) => readonly ["teams", "organization", string];
+            readonly members: (teamId: string) => readonly ["teams", "detail", string, "members"];
+        };
+        readonly spaces: {
+            readonly all: () => readonly ["spaces"];
+            readonly details: () => readonly ["spaces", "detail"];
+            readonly detail: (id: string) => readonly ["spaces", "detail", string];
+            readonly byHandle: (handle: string) => readonly ["spaces", "handle", string];
+            readonly byOrganization: (orgId: string) => readonly ["spaces", "organization", string];
+            readonly orgSpaceByHandle: (orgId: string, handle: string) => readonly ["spaces", "organization", string, "handle", string];
+            readonly byOrganizationAndHandle: (orgHandle: string, spaceHandle: string) => readonly ["spaces", "organization", string, "space", string];
+            readonly userSpaces: () => readonly ["spaces", "user"];
+            readonly items: (spaceId: string) => readonly ["spaces", "detail", string, "items"];
+            readonly members: (spaceId: string) => readonly ["spaces", "detail", string, "members"];
+        };
+        readonly notebooks: {
+            readonly all: () => readonly ["notebooks"];
+            readonly details: () => readonly ["notebooks", "detail"];
+            readonly detail: (id: string) => readonly ["notebooks", "detail", string];
+            readonly bySpace: (spaceId: string) => readonly ["notebooks", "space", string];
+            readonly model: (notebookId: string) => readonly ["notebooks", "detail", string, "model"];
+        };
+        readonly documents: {
+            readonly all: () => readonly ["documents"];
+            readonly details: () => readonly ["documents", "detail"];
+            readonly detail: (id: string) => readonly ["documents", "detail", string];
+            readonly bySpace: (spaceId: string) => readonly ["documents", "space", string];
+            readonly model: (documentId: string) => readonly ["documents", "detail", string, "model"];
+        };
+        readonly cells: {
+            readonly all: () => readonly ["cells"];
+            readonly details: () => readonly ["cells", "detail"];
+            readonly detail: (id: string) => readonly ["cells", "detail", string];
+            readonly bySpace: (spaceId: string) => readonly ["cells", "space", string];
+        };
+        readonly datasets: {
+            readonly all: () => readonly ["datasets"];
+            readonly details: () => readonly ["datasets", "detail"];
+            readonly detail: (id: string) => readonly ["datasets", "detail", string];
+            readonly bySpace: (spaceId: string) => readonly ["datasets", "space", string];
+        };
+        readonly lessons: {
+            readonly all: () => readonly ["lessons"];
+            readonly details: () => readonly ["lessons", "detail"];
+            readonly detail: (id: string) => readonly ["lessons", "detail", string];
+            readonly bySpace: (spaceId: string) => readonly ["lessons", "space", string];
+        };
+        readonly exercises: {
+            readonly all: () => readonly ["exercises"];
+            readonly details: () => readonly ["exercises", "detail"];
+            readonly detail: (id: string) => readonly ["exercises", "detail", string];
+            readonly bySpace: (spaceId: string) => readonly ["exercises", "space", string];
+        };
+        readonly assignments: {
+            readonly all: () => readonly ["assignments"];
+            readonly details: () => readonly ["assignments", "detail"];
+            readonly detail: (id: string) => readonly ["assignments", "detail", string];
+            readonly bySpace: (spaceId: string) => readonly ["assignments", "space", string];
+            readonly forStudent: (assignmentId: string, courseId: string, studentId: string) => readonly ["assignments", "detail", string, "course", string, "student", string];
+            readonly studentVersion: (assignmentId: string) => readonly ["assignments", "detail", string, "studentVersion"];
+        };
+        readonly environments: {
+            readonly all: () => readonly ["environments"];
+            readonly details: () => readonly ["environments", "detail"];
+            readonly detail: (id: string) => readonly ["environments", "detail", string];
+            readonly bySpace: (spaceId: string) => readonly ["environments", "space", string];
+        };
+        readonly pages: {
+            readonly all: () => readonly ["pages"];
+            readonly details: () => readonly ["pages", "detail"];
+            readonly detail: (id: string) => readonly ["pages", "detail", string];
+        };
+        readonly datasources: {
+            readonly all: () => readonly ["datasources"];
+            readonly details: () => readonly ["datasources", "detail"];
+            readonly detail: (id: string) => readonly ["datasources", "detail", string];
+        };
+        readonly secrets: {
+            readonly all: () => readonly ["secrets"];
+            readonly details: () => readonly ["secrets", "detail"];
+            readonly detail: (id: string) => readonly ["secrets", "detail", string];
+        };
+        readonly tokens: {
+            readonly all: () => readonly ["tokens"];
+            readonly details: () => readonly ["tokens", "detail"];
+            readonly detail: (id: string) => readonly ["tokens", "detail", string];
+        };
+        readonly contacts: {
+            readonly all: () => readonly ["contacts"];
+            readonly details: () => readonly ["contacts", "detail"];
+            readonly detail: (id: string) => readonly ["contacts", "detail", string];
+            readonly byHandle: (handle: string) => readonly ["contacts", "handle", string];
+            readonly search: (query: string) => readonly ["contacts", "search", string];
+        };
+        readonly invites: {
+            readonly all: () => readonly ["invites"];
+            readonly byToken: (token: string) => readonly ["invites", "token", string];
+            readonly byAccount: (accountId: string) => readonly ["invites", "account", string];
+        };
+        readonly courses: {
+            readonly all: () => readonly ["courses"];
+            readonly details: () => readonly ["courses", "detail"];
+            readonly detail: (id: string) => readonly ["courses", "detail", string];
+            readonly public: () => readonly ["courses", "public"];
+            readonly instructor: (instructorId: string) => readonly ["courses", "instructor", string];
+            readonly enrollments: () => readonly ["courses", "enrollments", "me"];
+            readonly students: (courseId: string) => readonly ["courses", "detail", string, "students"];
+            readonly student: (courseId: string, studentId: string) => readonly ["courses", "detail", string, "student", string];
+        };
+        readonly schools: {
+            readonly all: () => readonly ["schools"];
+        };
+        readonly inbounds: {
+            readonly all: () => readonly ["inbounds"];
+            readonly detail: (id: string) => readonly ["inbounds", string];
+            readonly byHandle: (handle: string) => readonly ["inbounds", "handle", string];
+        };
+        readonly outbounds: {
+            readonly all: () => readonly ["outbounds"];
+            readonly detail: (id: string) => readonly ["outbounds", string];
+        };
+        readonly items: {
+            readonly all: () => readonly ["items"];
+            readonly public: () => readonly ["items", "public"];
+            readonly bySpace: (spaceId: string) => readonly ["items", "space", string];
+            readonly search: (opts: ISearchOpts) => readonly ["items", "search", ISearchOpts];
+        };
+        readonly layout: {
+            readonly byAccount: (accountHandle: string, spaceHandle?: string) => readonly ["layout", string, string] | readonly ["layout", string];
+        };
+        readonly usages: {
+            readonly user: () => readonly ["usages", "user"];
+            readonly userById: (userId: string) => readonly ["usages", "user", string];
+            readonly platform: () => readonly ["usages", "platform"];
+        };
+        readonly prices: {
+            readonly stripe: () => readonly ["prices", "stripe"];
+        };
+        readonly growth: {
+            readonly kpi: () => readonly ["growth", "kpi"];
+        };
+        readonly oauth2: {
+            readonly authorizationUrl: (queryArgs: Record<string, string>) => readonly ["oauth2", "authz", "url", Record<string, string>];
+            readonly authorizationLinkUrl: (queryArgs: Record<string, string>) => readonly ["oauth2", "authz", "url", "link", Record<string, string>];
+        };
+    };
     notebookUploadLoading: boolean;
     notebookUploadProgress: number;
     resetNotebookUpload: () => void;
diff --git a/node_modules/@datalayer/core/lib/hooks/useCache.js b/node_modules/@datalayer/core/lib/hooks/useCache.js
index fbe2980..f6e2c96 100644
--- a/node_modules/@datalayer/core/lib/hooks/useCache.js
+++ b/node_modules/@datalayer/core/lib/hooks/useCache.js
@@ -2,3148 +2,6122 @@
  * Copyright (c) 2023-2025 Datalayer, Inc.
  * Distributed under the terms of the Modified BSD License.
  */
-import { URLExt } from '@jupyterlab/coreutils';
-import { BOOTSTRAP_USER_ONBOARDING, LinkedInUser, asContact, asDatasource, asInbound, asInvite, asOrganization, asOutbound, asPage, asSecret, asSpace, asSurvey, asTeam, asToken, asUsage, asUser, } from '../models';
+/**
+ * TanStack Query-based cache hook for Datalayer API
+ *
+ * This is a modernized replacement for useCache.tsx that leverages TanStack Query
+ * for automatic cache management, background refetching, and optimistic updates.
+ *
+ * Key improvements over useCache:
+ * - Automatic cache management (no manual Map objects)
+ * - Built-in loading/error states
+ * - Automatic refetching and deduplication
+ * - Optimistic updates support
+ * - Better TypeScript inference
+ * - React Query DevTools integration
+ *
+ * @example
+ * ```tsx
+ * const { useUser, useUpdateUser } = useCache2();
+ *
+ * function UserProfile({ userId }: { userId: string }) {
+ *   const { data: user, isPending, isError, error } = useUser(userId);
+ *   const updateUser = useUpdateUser();
+ *
+ *   if (isPending) return <Spinner />;
+ *   if (isError) return <Error message={error.message} />;
+ *
+ *   return (
+ *     <div>
+ *       <h1>{user.displayName}</h1>
+ *       <button onClick={() => updateUser.mutate({ email: 'new@email.com' })}>
+ *         Update Email
+ *       </button>
+ *     </div>
+ *   );
+ * }
+ * ```
+ */
+import { useQuery, useMutation, useQueryClient, } from '@tanstack/react-query';
+import { BOOTSTRAP_USER_ONBOARDING, asContact, asDatasource, asInvite, asOrganization, asPage, asSecret, asSpace, asTeam, asToken, asUser, } from '../models';
 import { useCoreStore, useIAMStore } from '../state';
 import { asDisplayName, namesAsInitials, asArray } from '../utils';
-import { IAMProvidersSpecs } from '../models';
 import { newUserMock } from './../mocks';
 import { useDatalayer } from './useDatalayer';
 import { useAuthorization } from './useAuthorization';
 import { useUploadForm } from './useUpload';
 import { OUTPUTSHOT_PLACEHOLDER_DEFAULT_SVG } from './assets';
-const CONTACTS_BY_HANDLE = new Map();
-const CONTACTS_BY_ID = new Map();
-const COURSES_BY_ID = new Map();
-const COURSES_ENROLLMENTS_BY_ID = new Map();
-const COURSES_INSTRUCTORS_BY_ID = new Map();
-const DATASOURCES_BY_ID = new Map();
-const INBOUNDS_BY_HANDLE = new Map();
-const INBOUNDS_BY_ID = new Map();
-const INVITES_BY_TOKEN = new Map();
-const ORGANISATIONS_BY_HANDLE = new Map();
-const ORGANISATIONS_BY_ID = new Map();
-const ORGANISATIONS_FOR_USER_BY_ID = new Map();
-const OUTBOUNDS_BY_ID = new Map();
-const PAGES_BY_ID = new Map();
-const PUBLIC_COURSES_BY_ID = new Map();
-const PUBLIC_ITEMS_BY_ID = new Map();
-const SCHOOLS_BY_ID = new Map();
-const SECRETS_BY_ID = new Map();
-const SPACES_BY_HANDLE_BY_ORGANISATION_HANDLE = new Map();
-const SPACES_BY_ID_BY_ORGANISATION_ID = new Map();
-const SPACES_FOR_USER_BY_HANDLE = new Map();
-const SPACES_FOR_USER_BY_ID = new Map();
-const SPACE_ASSIGNMENTS_BY_ID = new Map();
-const SPACE_CELLS_BY_ID = new Map();
-const SPACE_DATASETS_BY_ID = new Map();
-const SPACE_DOCUMENTS_BY_ID = new Map();
-const SPACE_ENVIRONMENTS_BY_ID = new Map();
-const SPACE_EXERCISES_BY_ID = new Map();
-const SPACE_ITEMS_CACHE = new Map();
-const SPACE_LESSONS_BY_ID = new Map();
-const SPACE_NOTEBOOKS_BY_ID = new Map();
-const STUDENTS_BY_ID = new Map();
-const STUDENT_ASSIGNMENTS_BY_ID = new Map();
-const TEAMS_BY_HANDLE = new Map();
-const TEAMS_BY_ID = new Map();
-const TEAMS_BY_ORGANIZATION_BY_ID = new Map();
-const TOKENS_BY_ID = new Map();
-const USERS_BY_HANDLE = new Map();
-const USERS_BY_ID = new Map();
-const DEFAULT_SEARCH_OPTS = {
-    q: '*',
-    types: ['page'],
-    max: 3,
-    public: true,
+// Kept for potential future use
+// Default query options for all queries
+const DEFAULT_QUERY_OPTIONS = {
+    staleTime: 5 * 60 * 1000, // 5 minutes
+    gcTime: 10 * 60 * 1000, // 10 minutes (formerly cacheTime)
+    retry: 1,
+    refetchOnMount: false, // Don't refetch on mount if data is still fresh
+    refetchOnWindowFocus: true,
+    refetchOnReconnect: true,
+    // Ensure queries prioritize cache over network when data is fresh
+    networkMode: 'online',
 };
+// ============================================================================
+// Query Key Factories
+// ============================================================================
 /**
- * Callbacks to RUN service.
+ * Centralized query key factories for all entities
+ * Following TanStack Query best practices for key structure
+ * @see https://tanstack.com/query/latest/docs/framework/react/guides/query-keys
+ */
+export const queryKeys = {
+    // Authentication & Profile
+    auth: {
+        me: () => ['auth', 'me'],
+        whoami: () => ['auth', 'whoami'],
+    },
+    // Users
+    users: {
+        all: () => ['users'],
+        lists: () => [...queryKeys.users.all(), 'list'],
+        list: (filters) => [...queryKeys.users.lists(), { filters }],
+        details: () => [...queryKeys.users.all(), 'detail'],
+        detail: (id) => [...queryKeys.users.details(), id],
+        byHandle: (handle) => [...queryKeys.users.all(), 'handle', handle],
+        search: (pattern) => [...queryKeys.users.all(), 'search', pattern],
+        settings: (userId) => [...queryKeys.users.detail(userId), 'settings'],
+        onboarding: (userId) => [...queryKeys.users.detail(userId), 'onboarding'],
+        surveys: (userId) => [...queryKeys.users.detail(userId), 'surveys'],
+        credits: (userId) => [...queryKeys.users.detail(userId), 'credits'],
+    },
+    // Organizations
+    organizations: {
+        all: () => ['organizations'],
+        lists: () => [...queryKeys.organizations.all(), 'list'],
+        details: () => [...queryKeys.organizations.all(), 'detail'],
+        detail: (id) => [...queryKeys.organizations.details(), id],
+        byHandle: (handle) => [...queryKeys.organizations.all(), 'handle', handle],
+        userOrgs: () => [...queryKeys.organizations.all(), 'user'],
+        members: (orgId) => [...queryKeys.organizations.detail(orgId), 'members'],
+    },
+    // Teams
+    teams: {
+        all: () => ['teams'],
+        details: () => [...queryKeys.teams.all(), 'detail'],
+        detail: (id) => [...queryKeys.teams.details(), id],
+        byHandle: (handle) => [...queryKeys.teams.all(), 'handle', handle],
+        byOrganization: (orgId) => [...queryKeys.teams.all(), 'organization', orgId],
+        members: (teamId) => [...queryKeys.teams.detail(teamId), 'members'],
+    },
+    // Spaces
+    spaces: {
+        all: () => ['spaces'],
+        details: () => [...queryKeys.spaces.all(), 'detail'],
+        detail: (id) => [...queryKeys.spaces.details(), id],
+        byHandle: (handle) => [...queryKeys.spaces.all(), 'handle', handle],
+        byOrganization: (orgId) => [...queryKeys.spaces.all(), 'organization', orgId],
+        orgSpaceByHandle: (orgId, handle) => [
+            ...queryKeys.spaces.all(),
+            'organization',
+            orgId,
+            'handle',
+            handle,
+        ],
+        byOrganizationAndHandle: (orgHandle, spaceHandle) => [
+            ...queryKeys.spaces.all(),
+            'organization',
+            orgHandle,
+            'space',
+            spaceHandle,
+        ],
+        userSpaces: () => [...queryKeys.spaces.all(), 'user'],
+        items: (spaceId) => [...queryKeys.spaces.detail(spaceId), 'items'],
+        members: (spaceId) => [...queryKeys.spaces.detail(spaceId), 'members'],
+    },
+    // Notebooks
+    notebooks: {
+        all: () => ['notebooks'],
+        details: () => [...queryKeys.notebooks.all(), 'detail'],
+        detail: (id) => [...queryKeys.notebooks.details(), id],
+        bySpace: (spaceId) => [...queryKeys.notebooks.all(), 'space', spaceId],
+        model: (notebookId) => [...queryKeys.notebooks.detail(notebookId), 'model'],
+    },
+    // Documents
+    documents: {
+        all: () => ['documents'],
+        details: () => [...queryKeys.documents.all(), 'detail'],
+        detail: (id) => [...queryKeys.documents.details(), id],
+        bySpace: (spaceId) => [...queryKeys.documents.all(), 'space', spaceId],
+        model: (documentId) => [...queryKeys.documents.detail(documentId), 'model'],
+    },
+    // Cells
+    cells: {
+        all: () => ['cells'],
+        details: () => [...queryKeys.cells.all(), 'detail'],
+        detail: (id) => [...queryKeys.cells.details(), id],
+        bySpace: (spaceId) => [...queryKeys.cells.all(), 'space', spaceId],
+    },
+    // Datasets
+    datasets: {
+        all: () => ['datasets'],
+        details: () => [...queryKeys.datasets.all(), 'detail'],
+        detail: (id) => [...queryKeys.datasets.details(), id],
+        bySpace: (spaceId) => [...queryKeys.datasets.all(), 'space', spaceId],
+    },
+    // Lessons
+    lessons: {
+        all: () => ['lessons'],
+        details: () => [...queryKeys.lessons.all(), 'detail'],
+        detail: (id) => [...queryKeys.lessons.details(), id],
+        bySpace: (spaceId) => [...queryKeys.lessons.all(), 'space', spaceId],
+    },
+    // Exercises
+    exercises: {
+        all: () => ['exercises'],
+        details: () => [...queryKeys.exercises.all(), 'detail'],
+        detail: (id) => [...queryKeys.exercises.details(), id],
+        bySpace: (spaceId) => [...queryKeys.exercises.all(), 'space', spaceId],
+    },
+    // Assignments
+    assignments: {
+        all: () => ['assignments'],
+        details: () => [...queryKeys.assignments.all(), 'detail'],
+        detail: (id) => [...queryKeys.assignments.details(), id],
+        bySpace: (spaceId) => [...queryKeys.assignments.all(), 'space', spaceId],
+        forStudent: (assignmentId, courseId, studentId) => [
+            ...queryKeys.assignments.detail(assignmentId),
+            'course',
+            courseId,
+            'student',
+            studentId,
+        ],
+        studentVersion: (assignmentId) => [
+            ...queryKeys.assignments.detail(assignmentId),
+            'studentVersion',
+        ],
+    },
+    // Environments
+    environments: {
+        all: () => ['environments'],
+        details: () => [...queryKeys.environments.all(), 'detail'],
+        detail: (id) => [...queryKeys.environments.details(), id],
+        bySpace: (spaceId) => [...queryKeys.environments.all(), 'space', spaceId],
+    },
+    // Pages
+    pages: {
+        all: () => ['pages'],
+        details: () => [...queryKeys.pages.all(), 'detail'],
+        detail: (id) => [...queryKeys.pages.details(), id],
+    },
+    // Datasources
+    datasources: {
+        all: () => ['datasources'],
+        details: () => [...queryKeys.datasources.all(), 'detail'],
+        detail: (id) => [...queryKeys.datasources.details(), id],
+    },
+    // Secrets
+    secrets: {
+        all: () => ['secrets'],
+        details: () => [...queryKeys.secrets.all(), 'detail'],
+        detail: (id) => [...queryKeys.secrets.details(), id],
+    },
+    // Tokens
+    tokens: {
+        all: () => ['tokens'],
+        details: () => [...queryKeys.tokens.all(), 'detail'],
+        detail: (id) => [...queryKeys.tokens.details(), id],
+    },
+    // Contacts
+    contacts: {
+        all: () => ['contacts'],
+        details: () => [...queryKeys.contacts.all(), 'detail'],
+        detail: (id) => [...queryKeys.contacts.details(), id],
+        byHandle: (handle) => [...queryKeys.contacts.all(), 'handle', handle],
+        search: (query) => [...queryKeys.contacts.all(), 'search', query],
+    },
+    // Invites
+    invites: {
+        all: () => ['invites'],
+        byToken: (token) => [...queryKeys.invites.all(), 'token', token],
+        byAccount: (accountId) => [...queryKeys.invites.all(), 'account', accountId],
+    },
+    // Courses
+    courses: {
+        all: () => ['courses'],
+        details: () => [...queryKeys.courses.all(), 'detail'],
+        detail: (id) => [...queryKeys.courses.details(), id],
+        public: () => [...queryKeys.courses.all(), 'public'],
+        instructor: (instructorId) => [...queryKeys.courses.all(), 'instructor', instructorId],
+        enrollments: () => [...queryKeys.courses.all(), 'enrollments', 'me'],
+        students: (courseId) => [...queryKeys.courses.detail(courseId), 'students'],
+        student: (courseId, studentId) => [...queryKeys.courses.detail(courseId), 'student', studentId],
+    },
+    // Schools
+    schools: {
+        all: () => ['schools'],
+    },
+    // Inbounds
+    inbounds: {
+        all: () => ['inbounds'],
+        detail: (id) => [...queryKeys.inbounds.all(), id],
+        byHandle: (handle) => [...queryKeys.inbounds.all(), 'handle', handle],
+    },
+    // Outbounds
+    outbounds: {
+        all: () => ['outbounds'],
+        detail: (id) => [...queryKeys.outbounds.all(), id],
+    },
+    // Items (generic)
+    items: {
+        all: () => ['items'],
+        public: () => [...queryKeys.items.all(), 'public'],
+        bySpace: (spaceId) => [...queryKeys.items.all(), 'space', spaceId],
+        search: (opts) => [...queryKeys.items.all(), 'search', opts],
+    },
+    // Layout
+    layout: {
+        byAccount: (accountHandle, spaceHandle) => spaceHandle
+            ? ['layout', accountHandle, spaceHandle]
+            : ['layout', accountHandle],
+    },
+    // Usages
+    usages: {
+        user: () => ['usages', 'user'],
+        userById: (userId) => ['usages', 'user', userId],
+        platform: () => ['usages', 'platform'],
+    },
+    // Prices
+    prices: {
+        stripe: () => ['prices', 'stripe'],
+    },
+    // Growth
+    growth: {
+        kpi: () => ['growth', 'kpi'],
+    },
+    // OAuth2
+    oauth2: {
+        authorizationUrl: (queryArgs) => ['oauth2', 'authz', 'url', queryArgs],
+        authorizationLinkUrl: (queryArgs) => ['oauth2', 'authz', 'url', 'link', queryArgs],
+    },
+};
+// ============================================================================
+// Main Hook
+// ============================================================================
+/**
+ * TanStack Query-based cache hook for Datalayer API
+ *
+ * This hook provides React Query-based data fetching and mutations for all
+ * Datalayer entities. Unlike the original useCache hook, this returns hook
+ * factories that components can use directly.
  *
- * It assumes to be used within a {@link Router} component. If not
- * you must set the options `loginRoute` to `null` (raise an error _Unauthorized_
- * instead of redirecting to the login page).
+ * @param options - Configuration options
+ * @param options.loginRoute - Route to redirect to on authentication failure (default: '/login')
+ *
+ * @returns Object containing all query and mutation hook factories
  */
 export const useCache = ({ loginRoute = '/login' } = {}) => {
     const coreStore = useCoreStore();
     const { configuration } = coreStore;
     const { user } = useIAMStore();
+    const queryClient = useQueryClient();
     const { requestDatalayer } = useDatalayer({ loginRoute });
     const { checkIsOrganizationMember } = useAuthorization();
     // Hook for notebook upload/creation
     const { isLoading: notebookUploadLoading, uploadAndSubmit: uploadNotebook, progress: notebookUploadProgress, reset: resetNotebookUpload, } = useUploadForm(`${coreStore.configuration.spacerRunUrl}/api/spacer/v1/notebooks`);
-    // Caches -------------------------------------------------------------------
-    const clearAllCaches = () => {
-        CONTACTS_BY_HANDLE.clear();
-        CONTACTS_BY_ID.clear();
-        COURSES_BY_ID.clear();
-        COURSES_ENROLLMENTS_BY_ID.clear();
-        COURSES_INSTRUCTORS_BY_ID.clear();
-        DATASOURCES_BY_ID.clear();
-        INBOUNDS_BY_HANDLE.clear();
-        INBOUNDS_BY_ID.clear();
-        INVITES_BY_TOKEN.clear();
-        ORGANISATIONS_BY_HANDLE.clear();
-        ORGANISATIONS_BY_ID.clear();
-        ORGANISATIONS_FOR_USER_BY_ID.clear();
-        PAGES_BY_ID.clear();
-        OUTBOUNDS_BY_ID.clear();
-        PUBLIC_COURSES_BY_ID.clear();
-        PUBLIC_ITEMS_BY_ID.clear();
-        SCHOOLS_BY_ID.clear();
-        SECRETS_BY_ID.clear();
-        SPACES_BY_HANDLE_BY_ORGANISATION_HANDLE.clear();
-        SPACES_BY_ID_BY_ORGANISATION_ID.clear();
-        SPACES_FOR_USER_BY_HANDLE.clear();
-        SPACES_FOR_USER_BY_ID.clear();
-        SPACE_ASSIGNMENTS_BY_ID.clear();
-        SPACE_CELLS_BY_ID.clear();
-        SPACE_DATASETS_BY_ID.clear();
-        SPACE_DOCUMENTS_BY_ID.clear();
-        SPACE_ENVIRONMENTS_BY_ID.clear();
-        SPACE_EXERCISES_BY_ID.clear();
-        SPACE_ITEMS_CACHE.clear();
-        SPACE_LESSONS_BY_ID.clear();
-        SPACE_NOTEBOOKS_BY_ID.clear();
-        STUDENTS_BY_ID.clear();
-        STUDENT_ASSIGNMENTS_BY_ID.clear();
-        TOKENS_BY_ID.clear();
-        USERS_BY_HANDLE.clear();
-        USERS_BY_ID.clear();
-    };
-    const clearCachedItems = () => {
-        PUBLIC_ITEMS_BY_ID.clear();
-        SPACE_ASSIGNMENTS_BY_ID.clear();
-        SPACE_DATASETS_BY_ID.clear();
-        SPACE_DOCUMENTS_BY_ID.clear();
-        SPACE_ENVIRONMENTS_BY_ID.clear();
-        SPACE_EXERCISES_BY_ID.clear();
-        SPACE_ITEMS_CACHE.clear();
-        SPACE_ITEMS_CACHE.clear();
-        SPACE_LESSONS_BY_ID.clear();
-        SPACE_NOTEBOOKS_BY_ID.clear();
-        SPACE_CELLS_BY_ID.clear();
-        SPACE_CELLS_BY_ID.clear();
-    };
-    // Authentication ------------------------------------------------------------------
-    const login = (handle, password) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/login`,
-            method: 'POST',
-            body: {
-                handle,
-                password,
-            },
-        });
-    };
-    const logout = () => {
-        clearAllCaches();
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/logout`,
-            method: 'GET',
-        });
-    };
-    // Join ------------------------------------------------------------------
-    const requestJoin = (handle, email, firstName, lastName, password, passwordConfirm) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/join/request`,
-            method: 'POST',
-            body: {
-                handle,
-                email,
-                firstName,
-                lastName,
-                password,
-                passwordConfirm,
-            },
-        });
-    };
-    const requestJoinToken = (handle, email, firstName, lastName, password, passwordConfirm) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/join/request/token`,
-            method: 'POST',
-            body: {
-                handle,
-                email,
-                firstName,
-                lastName,
-                password,
-                passwordConfirm,
-            },
-        });
-    };
-    const joinWithInvite = (formValues, token) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/join/invites/token`,
-            method: 'POST',
-            body: {
-                ...formValues,
-                token,
-            },
-        });
-    };
-    const confirmJoinWithToken = (userHandle, token) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/join/users/${userHandle}/tokens/${token}`,
-            method: 'GET',
-        });
-    };
-    // Password ------------------------------------------------------------------
-    const changePassword = (handle, password, passwordConfirm) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/password`,
-            method: 'PUT',
-            body: {
-                handle,
-                password,
-                passwordConfirm,
-            },
-        });
-    };
-    const createTokenForPasswordChange = (handle, password, passwordConfirm) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/password/token`,
-            method: 'POST',
-            body: {
-                handle,
-                password,
-                passwordConfirm,
-            },
-        });
-    };
-    const confirmPassworkWithToken = (userHandle, token) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/password/confirm/users/${userHandle}/tokens/${token}`,
-            method: 'PUT',
-        });
-    };
-    // OAuth2 -------------------------------------------------------------------
-    const getOAuth2AuthorizationURL = async (queryArgs) => {
-        return requestDatalayer({
-            url: URLExt.join(configuration.iamRunUrl, 'api/iam/v1/oauth2/authz/url') +
-                URLExt.objectToQueryString(queryArgs),
-            notifyOnError: false,
+    // ============================================================================
+    // Transformation Functions (kept from original useCache)
+    // Note: These functions use 'any' because they handle dynamic API responses
+    // ============================================================================
+    /* eslint-disable @typescript-eslint/no-explicit-any */
+    const toUser = (u) => {
+        if (u) {
+            return asUser(u);
+        }
+    };
+    const toOrganization = (org) => {
+        return asOrganization(org);
+    };
+    const toSpace = (spc) => {
+        return asSpace(spc);
+    };
+    const toPage = (s) => {
+        if (s) {
+            return asPage(s);
+        }
+    };
+    const toDatasource = (s) => {
+        if (s) {
+            return asDatasource(s);
+        }
+    };
+    const toSecret = (s) => {
+        if (s) {
+            return asSecret(s);
+        }
+    };
+    const toToken = (s) => {
+        if (s) {
+            return asToken(s);
+        }
+    };
+    const toContact = (c) => {
+        if (c) {
+            return asContact(c);
+        }
+    };
+    const toTeam = (org, organizationId) => {
+        return asTeam(org, organizationId);
+    };
+    // Kept for potential future use
+    // Kept for potential future use
+    const toDataset = (raw_dataset) => {
+        const owner = newUserMock();
+        return {
+            id: raw_dataset.uid,
+            type: 'dataset',
+            name: raw_dataset.name_t,
+            description: raw_dataset.description_t,
+            fileName: raw_dataset.file_name_s,
+            datasetExtension: raw_dataset.dataset_extension_s,
+            contentLength: raw_dataset.content_length_i,
+            contentType: raw_dataset.content_type_s,
+            mimeType: raw_dataset.mimetype_s,
+            path: raw_dataset.s3_path_s,
+            cdnUrl: raw_dataset.cdn_url_s,
+            creationDate: new Date(raw_dataset.creation_ts_dt),
+            public: raw_dataset.public_b ?? false,
+            lastPublicationDate: raw_dataset.creation_ts_dt
+                ? new Date(raw_dataset.creation_ts_dt)
+                : undefined,
+            owner,
+            space: {
+                handle: raw_dataset.handle_s,
+            },
+            organization: {
+                handle: raw_dataset.handle_s,
+            },
+        };
+    };
+    const toCell = (cl) => {
+        const owner = newUserMock();
+        return {
+            id: cl.uid,
+            type: 'cell',
+            name: cl.name_t,
+            description: cl.description_t,
+            source: cl.source_t,
+            creationDate: new Date(cl.creation_ts_dt),
+            public: cl.public_b ?? false,
+            lastPublicationDate: cl.last_publication_ts_dt
+                ? new Date(cl.last_publication_ts_dt)
+                : undefined,
+            outputshotUrl: cl.outputshot_url_s || '',
+            outputshotData: OUTPUTSHOT_PLACEHOLDER_DEFAULT_SVG,
+            owner,
+            space: {
+                handle: cl.handle_s,
+            },
+            organization: {
+                handle: cl.handle_s,
+            },
+        };
+    };
+    const toNotebook = (raw_notebook) => {
+        const owner = newUserMock();
+        return {
+            id: raw_notebook.uid,
+            type: 'notebook',
+            name: raw_notebook.name_t,
+            description: raw_notebook.description_t,
+            nbformat: raw_notebook.model_s
+                ? JSON.parse(raw_notebook.model_s)
+                : undefined,
+            public: raw_notebook.public_b ?? false,
+            creationDate: new Date(raw_notebook.creation_ts_dt),
+            lastUpdateDate: raw_notebook.last_update_ts_dt
+                ? new Date(raw_notebook.last_update_ts_dt)
+                : undefined,
+            lastPublicationDate: raw_notebook.creation_ts_dt
+                ? new Date(raw_notebook.creation_ts_dt)
+                : undefined,
+            datasets: [],
+            owner,
+            space: {
+                handle: raw_notebook.handle_s,
+            },
+            organization: {
+                handle: raw_notebook.handle_s,
+            },
+        };
+    };
+    const toDocument = (doc) => {
+        const owner = newUserMock();
+        return {
+            id: doc.uid,
+            type: 'document',
+            name: doc.name_t,
+            description: doc.description_t,
+            model: doc.model_s ? JSON.parse(doc.model_s) : undefined,
+            public: doc.public_b ?? false,
+            creationDate: new Date(doc.creation_ts_dt),
+            lastUpdateDate: doc.last_update_ts_dt
+                ? new Date(doc.last_update_ts_dt)
+                : undefined,
+            lastPublicationDate: doc.creation_ts_dt
+                ? new Date(doc.creation_ts_dt)
+                : undefined,
+            owner,
+            space: {
+                handle: doc.handle_s,
+            },
+            organization: {
+                handle: doc.handle_s,
+            },
+        };
+    };
+    const toLesson = (raw_lesson) => {
+        const owner = newUserMock();
+        return {
+            id: raw_lesson.uid,
+            type: 'lesson',
+            name: raw_lesson.name_t,
+            description: raw_lesson.description_t,
+            nbformat: raw_lesson.model_s ? JSON.parse(raw_lesson.model_s) : undefined,
+            public: raw_lesson.public_b ?? false,
+            creationDate: new Date(raw_lesson.creation_ts_dt),
+            lastUpdateDate: raw_lesson.last_update_ts_dt
+                ? new Date(raw_lesson.last_update_ts_dt)
+                : undefined,
+            lastPublicationDate: raw_lesson.creation_ts_dt
+                ? new Date(raw_lesson.creation_ts_dt)
+                : undefined,
+            owner,
+            space: {
+                handle: raw_lesson.handle_s,
+            },
+            organization: {
+                handle: raw_lesson.handle_s,
+            },
+            datasets: [],
+        };
+    };
+    const toExercise = (ex) => {
+        const owner = newUserMock();
+        return {
+            id: ex.uid,
+            type: 'exercise',
+            name: ex.name_t,
+            description: ex.description_t,
+            help: ex.help_t,
+            codePre: ex.code_pre_t,
+            codeQuestion: ex.code_question_t,
+            codeSolution: ex.code_solution_t,
+            codeTest: ex.code_test_t,
+            public: ex.public_b ?? false,
+            creationDate: new Date(ex.creation_ts_dt),
+            lastUpdateDate: ex.last_update_ts_dt
+                ? new Date(ex.last_update_ts_dt)
+                : undefined,
+            lastPublicationDate: ex.creation_ts_dt
+                ? new Date(ex.creation_ts_dt)
+                : undefined,
+            owner,
+            space: {
+                handle: ex.handle_s,
+            },
+            organization: {
+                handle: ex.handle_s,
+            },
+            datasets: [],
+        };
+    };
+    const toAssignment = (raw_assignment) => {
+        const owner = newUserMock();
+        let studentItem = undefined;
+        if (raw_assignment.student_items) {
+            raw_assignment.student_items.forEach((student_item) => {
+                studentItem = {
+                    id: student_item.uid,
+                    type: 'student_item',
+                    itemId: student_item.item_uid,
+                    itemType: student_item.item_type_s,
+                    nbgrades: student_item.nbgrades,
+                    nbgradesTotalPoints: student_item.nbgrades_total_points_f,
+                    nbgradesTotalScore: student_item.nbgrades_total_score_f,
+                };
+            });
+        }
+        return {
+            id: raw_assignment.uid,
+            type: 'assignment',
+            name: raw_assignment.name_t,
+            description: raw_assignment.description_t,
+            nbformat: raw_assignment.model_s
+                ? JSON.parse(raw_assignment.model_s)
+                : undefined,
+            public: raw_assignment.public_b ?? false,
+            creationDate: new Date(raw_assignment.creation_ts_dt),
+            lastUpdateDate: raw_assignment.last_update_ts_dt
+                ? new Date(raw_assignment.last_update_ts_dt)
+                : undefined,
+            lastPublicationDate: raw_assignment.creation_ts_dt
+                ? new Date(raw_assignment.creation_ts_dt)
+                : undefined,
+            studentItem,
+            datasets: [],
+            owner,
+            space: {
+                handle: raw_assignment.handle_s,
+            },
+            organization: {
+                handle: raw_assignment.handle_s,
+            },
+        };
+    };
+    const toEnvironment = (env) => {
+        const owner = newUserMock();
+        return {
+            id: env.uid,
+            type: 'environment',
+            name: env.name_t,
+            description: env.description_t,
+            creationDate: new Date(env.creation_ts_dt),
+            public: env.public_b ?? false,
+            lastPublicationDate: env.creation_ts_dt
+                ? new Date(env.creation_ts_dt)
+                : undefined,
+            owner,
+            space: {
+                handle: env.handle_s,
+            },
+            organization: {
+                handle: env.handle_s,
+            },
+        };
+    };
+    const toItem = (item) => {
+        if (!item.type_s) {
+            console.error('No type_s found on item', item);
+            return {};
+        }
+        switch (item.type_s) {
+            case 'assignment':
+                return toAssignment(item);
+            case 'cell':
+                return toCell(item);
+            case 'dataset':
+                return toDataset(item);
+            case 'document':
+                return toDocument(item);
+            case 'exercise':
+                return toExercise(item);
+            case 'lesson':
+                return toLesson(item);
+            case 'notebook':
+                return toNotebook(item);
+            case 'page':
+                return toPage(item);
+            default:
+                return {};
+        }
+    };
+    const toCourse = (raw_course) => {
+        const owner = newUserMock();
+        let instructor = undefined;
+        if (raw_course.members) {
+            let raw_instructor = raw_course.members;
+            if (Array.isArray(raw_instructor)) {
+                raw_instructor = raw_instructor[0];
+            }
+            instructor = {
+                id: raw_instructor.uid,
+                handle: raw_instructor.handle_s,
+                email: raw_instructor.email_s,
+                firstName: raw_instructor.first_name_t,
+                lastName: raw_instructor.last_name_t,
+                initials: namesAsInitials(raw_instructor.to_first_name_t, raw_instructor.to_last_name_t),
+                displayName: asDisplayName(raw_instructor.first_name_t, raw_instructor.last_name_t),
+                roles: [],
+                iamProviders: [],
+                setRoles: (_roles) => { },
+                unsubscribedFromOutbounds: false,
+                onboarding: BOOTSTRAP_USER_ONBOARDING,
+                linkedContactId: undefined,
+                events: [],
+                settings: {},
+            };
+        }
+        let students = undefined;
+        if (raw_course.students) {
+            students = new Map();
+            raw_course.students.forEach((raw_stud) => {
+                const student = toUser(raw_stud);
+                if (student && students) {
+                    students.set(student.id, student);
+                }
+            });
+        }
+        let itemIds = new Array();
+        let raw_item_uids = raw_course.item_uids_s;
+        if (raw_item_uids && raw_item_uids !== '()') {
+            raw_item_uids = raw_item_uids.replace('(', '').replace(')', '');
+            itemIds = raw_item_uids.split(' ');
+        }
+        const items = new Array();
+        if (raw_course.items) {
+            raw_course.items.forEach((item) => {
+                const i = toItem(item);
+                items.push(i);
+            });
+        }
+        return {
+            id: raw_course.uid,
+            handle: raw_course.handle_s,
+            type: 'space',
+            variant: 'course',
+            name: raw_course.name_t,
+            description: raw_course.description_t,
+            creationDate: new Date(raw_course.creation_ts_dt),
+            public: raw_course.public_b ?? false,
+            items,
+            itemIds,
+            instructor,
+            students,
+            owner,
+        };
+    };
+    /* eslint-enable @typescript-eslint/no-explicit-any */
+    // ============================================================================
+    // Authentication & Profile Hooks
+    // ============================================================================
+    /**
+     * Login mutation
+     * @example
+     * ```tsx
+     * const login = useLogin();
+     * login.mutate({ handle: 'user', password: 'pass' });
+     * ```
+     */
+    const useLogin = () => {
+        const iamStore = useIAMStore();
+        return useMutation({
+            mutationFn: async ({ handle, password, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/login`,
+                    method: 'POST',
+                    body: { handle, password },
+                });
+            },
+            onSuccess: async (resp) => {
+                // Set the token in IAM state
+                if (resp.token) {
+                    await iamStore.refreshUserByToken(resp.token);
+                }
+                // Invalidate all queries on successful login
+                queryClient.invalidateQueries();
+            },
+        });
+    };
+    /**
+     * Logout mutation
+     * @example
+     * ```tsx
+     * const logout = useLogout();
+     * logout.mutate();
+     * ```
+     */
+    const useLogout = () => {
+        return useMutation({
+            mutationFn: async () => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/logout`,
+                    method: 'GET',
+                });
+            },
+            onSuccess: () => {
+                // Clear all queries on logout
+                queryClient.clear();
+            },
+        });
+    };
+    /**
+     * Get current user profile
+     * @example
+     * ```tsx
+     * const { data: user, isPending } = useMe();
+     * ```
+     */
+    const useMe = (token) => {
+        return useQuery({
+            queryKey: queryKeys.auth.me(),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/me`,
+                    method: 'GET',
+                    token,
+                });
+                if (resp.me) {
+                    return toUser(resp.me);
+                }
+                return null;
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+        });
+    };
+    /**
+     * Update current user profile
+     */
+    const useUpdateMe = () => {
+        return useMutation({
+            mutationFn: async ({ email, firstName, lastName, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/me`,
+                    method: 'PUT',
+                    body: { email, firstName, lastName },
+                });
+            },
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: queryKeys.auth.me() });
+            },
+        });
+    };
+    /**
+     * Whoami query
+     */
+    const useWhoami = () => {
+        return useQuery({
+            queryKey: queryKeys.auth.whoami(),
+            queryFn: async () => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/whoami`,
+                    method: 'GET',
+                });
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+        });
+    };
+    // ============================================================================
+    // User Hooks
+    // ============================================================================
+    /**
+     * Get user by ID
+     * @param userId - User ID
+     * @example
+     * ```tsx
+     * const { data: user, isPending, isError } = useUser('user-123');
+     * ```
+     */
+    const useUser = (userId) => {
+        return useQuery({
+            queryKey: queryKeys.users.detail(userId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/users/${userId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.user) {
+                    const user = toUser(resp.user);
+                    // Also populate handle cache if available
+                    if (user) {
+                        queryClient.setQueryData(queryKeys.users.byHandle(user.handle), user);
+                    }
+                    return user;
+                }
+                throw new Error(resp.message || 'Failed to fetch user');
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!userId,
+        });
+    };
+    /**
+     * Get user by handle
+     * @param handle - User handle
+     */
+    const useUserByHandle = (handle) => {
+        return useQuery({
+            queryKey: queryKeys.users.byHandle(handle),
+            queryFn: async () => {
+                // Implementation depends on your API
+                // For now, using search as workaround
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/users/search`,
+                    method: 'POST',
+                    body: { namingPattern: handle },
+                });
+                if (resp.success && resp.users) {
+                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+                    const users = resp.users.map((u) => toUser(u));
+                    const user = users.find((u) => u.handle === handle);
+                    if (user) {
+                        // Populate ID cache
+                        queryClient.setQueryData(queryKeys.users.detail(user.id), user);
+                    }
+                    return user;
+                }
+                return null;
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!handle,
+        });
+    };
+    /**
+     * Search users by naming pattern
+     */
+    const useSearchUsers = (namingPattern) => {
+        return useQuery({
+            queryKey: queryKeys.users.search(namingPattern),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/users/search`,
+                    method: 'POST',
+                    body: { namingPattern },
+                });
+                if (resp.success && resp.users) {
+                    const users = resp.users.map((u) => {
+                        const user = toUser(u);
+                        // Pre-populate individual caches
+                        if (user) {
+                            queryClient.setQueryData(queryKeys.users.detail(user.id), user);
+                            queryClient.setQueryData(queryKeys.users.byHandle(user.handle), user);
+                        }
+                        return user;
+                    });
+                    return users.filter(Boolean);
+                }
+                return [];
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: namingPattern !== undefined && namingPattern !== null,
+        });
+    };
+    /**
+     * Update user onboarding
+     */
+    const useUpdateUserOnboarding = () => {
+        return useMutation({
+            mutationFn: async (onboarding) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/onboardings`,
+                    method: 'PUT',
+                    body: { onboarding },
+                });
+            },
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: queryKeys.auth.me() });
+            },
+        });
+    };
+    /**
+     * Update user settings
+     */
+    const useUpdateUserSettings = () => {
+        return useMutation({
+            mutationFn: async ({ userId, settings, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/users/${userId}/settings`,
+                    method: 'PUT',
+                    body: {
+                        aiagents_url_s: settings.aiAgentsUrl,
+                        can_invite_b: settings.canInvite || false,
+                    },
+                });
+            },
+            onSuccess: (_, variables) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.users.detail(variables.userId),
+                });
+            },
+        });
+    };
+    // ============================================================================
+    // Organization Hooks
+    // ============================================================================
+    /**
+     * Get organization by ID
+     */
+    const useOrganization = (organizationId) => {
+        return useQuery({
+            queryKey: queryKeys.organizations.detail(organizationId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.organization) {
+                    const org = toOrganization(resp.organization);
+                    // Also populate handle cache
+                    queryClient.setQueryData(queryKeys.organizations.byHandle(org.handle), org);
+                    return org;
+                }
+                throw new Error(resp.message || 'Failed to fetch organization');
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!organizationId && !!user,
+        });
+    };
+    /**
+     * Get organization by handle
+     */
+    const useOrganizationByHandle = (handle) => {
+        return useQuery({
+            queryKey: queryKeys.organizations.byHandle(handle),
+            queryFn: async () => {
+                // Fetch via account endpoint
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/accounts/${handle}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.organization) {
+                    const org = toOrganization(resp.organization);
+                    // Populate ID cache
+                    queryClient.setQueryData(queryKeys.organizations.detail(org.id), org);
+                    return org;
+                }
+                return null;
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!handle,
+        });
+    };
+    /**
+     * Get user's organizations
+     */
+    const useUserOrganizations = () => {
+        return useQuery({
+            queryKey: queryKeys.organizations.userOrgs(),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/organizations`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.organizations) {
+                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+                    const orgs = resp.organizations.map((org) => {
+                        const organization = toOrganization(org);
+                        // Pre-populate caches
+                        queryClient.setQueryData(queryKeys.organizations.detail(organization.id), organization);
+                        queryClient.setQueryData(queryKeys.organizations.byHandle(organization.handle), organization);
+                        return organization;
+                    });
+                    return orgs.filter((org) => user ? checkIsOrganizationMember(user, org) : false);
+                }
+                return [];
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!user,
+        });
+    };
+    /**
+     * Create organization
+     */
+    const useCreateOrganization = () => {
+        return useMutation({
+            mutationFn: async (organization) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/organizations`,
+                    method: 'POST',
+                    body: {
+                        handle: organization.handle,
+                        name: organization.name,
+                        description: organization.description,
+                    },
+                });
+            },
+            onSuccess: resp => {
+                if (resp.organization) {
+                    const org = toOrganization(resp.organization);
+                    // Set detail cache
+                    queryClient.setQueryData(queryKeys.organizations.detail(org.id), org);
+                    // Invalidate all organization queries
+                    queryClient.invalidateQueries({
+                        queryKey: queryKeys.organizations.all(),
+                    });
+                }
+            },
+        });
+    };
+    /**
+     * Update organization with optimistic update
+     */
+    const useUpdateOrganization = () => {
+        return useMutation({
+            mutationFn: async (organization) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organization.id}`,
+                    method: 'PUT',
+                    body: {
+                        name: organization.name,
+                        description: organization.description,
+                    },
+                });
+            },
+            onSuccess: (_, organization) => {
+                const orgId = organization.id ?? '';
+                // Invalidate detail cache
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.organizations.detail(orgId),
+                });
+                // Invalidate all organization queries
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.organizations.all(),
+                });
+            },
+        });
+    };
+    // ============================================================================
+    // Team Hooks
+    // ============================================================================
+    /**
+     * Get team by ID
+     */
+    const useTeam = (teamId, organizationId) => {
+        return useQuery({
+            queryKey: queryKeys.teams.detail(teamId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.team) {
+                    const team = toTeam(resp.team, organizationId);
+                    queryClient.setQueryData(queryKeys.teams.byHandle(team.handle), team);
+                    return team;
+                }
+                throw new Error(resp.message || 'Failed to fetch team');
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!teamId && !!organizationId,
+        });
+    };
+    /**
+     * Get teams by organization
+     */
+    const useTeamsByOrganization = (organizationId) => {
+        return useQuery({
+            queryKey: queryKeys.teams.byOrganization(organizationId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}/teams`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.teams) {
+                    const teams = resp.teams.map((t) => {
+                        const team = toTeam(t, organizationId);
+                        // Pre-populate caches
+                        queryClient.setQueryData(queryKeys.teams.detail(team.id), team);
+                        queryClient.setQueryData(queryKeys.teams.byHandle(team.handle), team);
+                        return team;
+                    });
+                    return teams;
+                }
+                return [];
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!organizationId,
+        });
+    };
+    /**
+     * Create team
+     */
+    const useCreateTeam = () => {
+        return useMutation({
+            mutationFn: async ({ team, organization, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/teams`,
+                    method: 'POST',
+                    body: {
+                        handle: team.handle,
+                        name: team.name,
+                        description: team.description,
+                        organizationId: organization.id,
+                    },
+                });
+            },
+            onSuccess: (resp, _variables) => {
+                if (resp.team) {
+                    const team = toTeam(resp.team, _variables.organization.id);
+                    // Set detail cache
+                    queryClient.setQueryData(queryKeys.teams.detail(team.id), team);
+                    // Invalidate all team queries
+                    queryClient.invalidateQueries({
+                        queryKey: queryKeys.teams.all(),
+                    });
+                }
+            },
+        });
+    };
+    /**
+     * Update team
+     */
+    const useUpdateTeam = () => {
+        return useMutation({
+            mutationFn: async (team) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/teams/${team.id}`,
+                    method: 'PUT',
+                    body: {
+                        name: team.name,
+                        description: team.description,
+                    },
+                });
+            },
+            onSuccess: (_, team) => {
+                // Invalidate detail cache
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.teams.detail(team.id ?? ''),
+                });
+                // Invalidate all team queries
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.teams.all(),
+                });
+            },
+        });
+    };
+    // ============================================================================
+    // Space Hooks
+    // ============================================================================
+    /**
+     * Get space by ID
+     */
+    const useSpace = (spaceId) => {
+        return useQuery({
+            queryKey: queryKeys.spaces.detail(spaceId),
+            queryFn: async () => {
+                // Note: This might need organization context
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.space) {
+                    const space = toSpace(resp.space);
+                    queryClient.setQueryData(queryKeys.spaces.byHandle(space.handle), space);
+                    return space;
+                }
+                throw new Error(resp.message || 'Failed to fetch space');
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!spaceId,
+        });
+    };
+    /**
+     * Get organization space
+     */
+    const useOrganizationSpace = (organizationId, spaceId) => {
+        return useQuery({
+            queryKey: queryKeys.spaces.detail(spaceId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/organizations/${organizationId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.space) {
+                    return toSpace(resp.space);
+                }
+                throw new Error(resp.message || 'Failed to fetch space');
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!spaceId && !!organizationId,
+        });
+    };
+    /**
+     * Get spaces by organization
+     */
+    const useOrganizationSpaces = (organizationId) => {
+        return useQuery({
+            queryKey: queryKeys.spaces.byOrganization(organizationId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/organizations/${organizationId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.spaces) {
+                    const spaces = resp.spaces.map((spc) => {
+                        const space = toSpace(spc);
+                        queryClient.setQueryData(queryKeys.spaces.detail(space.id), space);
+                        return space;
+                    });
+                    return spaces;
+                }
+                return [];
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!organizationId,
+        });
+    };
+    /**
+     * Get user spaces
+     */
+    const useUserSpaces = () => {
+        return useQuery({
+            queryKey: queryKeys.spaces.userSpaces(),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/users/me`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.spaces) {
+                    const spaces = resp.spaces.map((spc) => {
+                        const space = toSpace(spc);
+                        queryClient.setQueryData(queryKeys.spaces.detail(space.id), space);
+                        queryClient.setQueryData(queryKeys.spaces.byHandle(space.handle), space);
+                        return space;
+                    });
+                    return spaces;
+                }
+                return [];
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!user,
+        });
+    };
+    /**
+     * Create space
+     */
+    const useCreateSpace = () => {
+        return useMutation({
+            mutationFn: async ({ space, organization, }) => {
+                const seedSpaceId = space.variant === 'course'
+                    ? space.seedSpace?.id
+                    : undefined;
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces`,
+                    method: 'POST',
+                    body: {
+                        name: space.name,
+                        description: space.description,
+                        variant: space.variant,
+                        public: space.public,
+                        spaceHandle: space.handle,
+                        organizationId: organization?.id,
+                        seedSpaceId,
+                    },
+                });
+            },
+            onSuccess: (resp, _variables) => {
+                if (resp.space) {
+                    const space = toSpace(resp.space);
+                    // Set detail cache
+                    queryClient.setQueryData(queryKeys.spaces.detail(space.id), space);
+                    // Invalidate all space queries
+                    queryClient.invalidateQueries({
+                        queryKey: queryKeys.spaces.all(),
+                    });
+                }
+            },
+        });
+    };
+    /**
+     * Update space with optimistic update
+     */
+    const useUpdateSpace = () => {
+        return useMutation({
+            mutationFn: async (space) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/users/${user?.id}`,
+                    method: 'PUT',
+                    body: {
+                        name: space.name,
+                        description: space.description,
+                    },
+                });
+            },
+            onSuccess: (_, space) => {
+                const spaceId = space.id ?? '';
+                // Invalidate detail cache
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.spaces.detail(spaceId),
+                });
+                // Invalidate all space queries
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.spaces.all(),
+                });
+            },
+        });
+    };
+    // ============================================================================
+    // Notebook Hooks
+    // ============================================================================
+    /**
+     * Get notebook by ID
+     */
+    const useNotebook = (notebookId) => {
+        return useQuery({
+            queryKey: queryKeys.notebooks.detail(notebookId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${notebookId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.notebook) {
+                    return toNotebook(resp.notebook);
+                }
+                throw new Error(resp.message || 'Failed to fetch notebook');
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!notebookId,
+        });
+    };
+    /**
+     * Get notebooks by space
+     */
+    const useNotebooksBySpace = (spaceId) => {
+        return useQuery({
+            queryKey: queryKeys.notebooks.bySpace(spaceId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/notebook`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.items) {
+                    const notebooks = resp.items.map((n) => {
+                        const notebook = toNotebook(n);
+                        queryClient.setQueryData(queryKeys.notebooks.detail(notebook.id), notebook);
+                        return notebook;
+                    });
+                    return notebooks;
+                }
+                return [];
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!spaceId,
+        });
+    };
+    /**
+     * Create notebook
+     */
+    const useCreateNotebook = () => {
+        return useMutation({
+            mutationFn: async ({ spaceId, name, description, notebookType = 'notebook', }) => {
+                const formData = new FormData();
+                formData.append('spaceId', spaceId);
+                formData.append('notebookType', notebookType);
+                formData.append('name', name);
+                formData.append('description', description || '');
+                const resp = await uploadNotebook(formData);
+                return resp;
+            },
+            onSuccess: (resp, _variables) => {
+                if (resp.success && resp.notebook) {
+                    const notebook = toNotebook(resp.notebook);
+                    // Set detail cache
+                    queryClient.setQueryData(queryKeys.notebooks.detail(notebook.id), notebook);
+                    // Invalidate all notebook queries (including bySpace)
+                    queryClient.invalidateQueries({
+                        queryKey: queryKeys.notebooks.all(),
+                    });
+                }
+            },
+        });
+    };
+    /**
+     * Update notebook with optimistic update
+     */
+    const useUpdateNotebook = () => {
+        return useMutation({
+            mutationFn: async ({ id, name, description, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${id}`,
+                    method: 'PUT',
+                    body: { name, description },
+                });
+            },
+            onSuccess: (resp, notebook) => {
+                if (resp.success) {
+                    // Invalidate detail query
+                    queryClient.invalidateQueries({
+                        queryKey: queryKeys.notebooks.detail(notebook.id),
+                    });
+                    // Invalidate all notebook lists (including bySpace queries)
+                    queryClient.invalidateQueries({
+                        queryKey: queryKeys.notebooks.all(),
+                    });
+                }
+            },
+        });
+    };
+    /**
+     * Update notebook model
+     */
+    const useUpdateNotebookModel = () => {
+        return useMutation({
+            mutationFn: async ({ notebookId, nbformat, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${notebookId}/model`,
+                    method: 'PUT',
+                    body: { nbformat },
+                });
+            },
+            onSuccess: (_, variables) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.notebooks.detail(variables.notebookId),
+                });
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.notebooks.model(variables.notebookId),
+                });
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.notebooks.all(),
+                });
+            },
+        });
+    };
+    /**
+     * Clone notebook
+     */
+    const useCloneNotebook = () => {
+        return useMutation({
+            mutationFn: async (notebookId) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${notebookId}/clone`,
+                    method: 'POST',
+                });
+            },
+            onSuccess: resp => {
+                if (resp.success && resp.notebook) {
+                    const notebook = toNotebook(resp.notebook);
+                    // Set detail cache
+                    queryClient.setQueryData(queryKeys.notebooks.detail(notebook.id), notebook);
+                    // Invalidate list to refetch
+                    const spaceId = notebook.space;
+                    if (spaceId) {
+                        const spaceIdStr = typeof spaceId === 'string' ? spaceId : spaceId.id;
+                        if (spaceIdStr) {
+                            queryClient.invalidateQueries({
+                                queryKey: queryKeys.notebooks.bySpace(spaceIdStr),
+                            });
+                        }
+                    }
+                }
+            },
+        });
+    };
+    // ============================================================================
+    // Document Hooks
+    // ============================================================================
+    /**
+     * Get document by ID
+     */
+    const useDocument = (documentId) => {
+        return useQuery({
+            queryKey: queryKeys.documents.detail(documentId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/lexicals/${documentId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.document) {
+                    return toDocument(resp.document);
+                }
+                throw new Error(resp.message || 'Failed to fetch document');
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!documentId,
+        });
+    };
+    /**
+     * Get documents by space
+     */
+    const useDocumentsBySpace = (spaceId) => {
+        return useQuery({
+            queryKey: queryKeys.documents.bySpace(spaceId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/document`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.items) {
+                    const documents = resp.items.map((d) => {
+                        const doc = toDocument(d);
+                        queryClient.setQueryData(queryKeys.documents.detail(doc.id), doc);
+                        return doc;
+                    });
+                    return documents;
+                }
+                return [];
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!spaceId,
+        });
+    };
+    /**
+     * Update document
+     */
+    const useUpdateDocument = () => {
+        return useMutation({
+            mutationFn: async ({ id, name, description, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/lexicals/${id}`,
+                    method: 'PUT',
+                    body: { name, description },
+                });
+            },
+            onSuccess: (resp, doc) => {
+                if (resp.success) {
+                    // Invalidate detail query
+                    queryClient.invalidateQueries({
+                        queryKey: queryKeys.documents.detail(doc.id),
+                    });
+                    // Invalidate all document lists (including bySpace queries)
+                    queryClient.invalidateQueries({
+                        queryKey: queryKeys.documents.all(),
+                    });
+                }
+            },
+        });
+    };
+    /**
+     * Update document model
+     */
+    const useUpdateDocumentModel = () => {
+        return useMutation({
+            mutationFn: async ({ id, model }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/lexicals/${id}/model`,
+                    method: 'PUT',
+                    body: { model },
+                });
+            },
+            onSuccess: (_, variables) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.documents.detail(variables.id),
+                });
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.documents.all(),
+                });
+            },
+        });
+    };
+    /**
+     * Clone document
+     */
+    const useCloneDocument = () => {
+        return useMutation({
+            mutationFn: async (documentId) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/lexicals/${documentId}/clone`,
+                    method: 'POST',
+                });
+            },
+            onSuccess: resp => {
+                if (resp.success && resp.document) {
+                    const doc = toDocument(resp.document);
+                    // Set detail cache
+                    queryClient.setQueryData(queryKeys.documents.detail(doc.id), doc);
+                    // Invalidate list to refetch
+                    const spaceId = doc.space;
+                    if (spaceId) {
+                        const spaceIdStr = typeof spaceId === 'string' ? spaceId : spaceId.id;
+                        if (spaceIdStr) {
+                            queryClient.invalidateQueries({
+                                queryKey: queryKeys.documents.bySpace(spaceIdStr),
+                            });
+                        }
+                    }
+                }
+            },
+        });
+    };
+    // ============================================================================
+    // Page Hooks
+    // ============================================================================
+    /**
+     * Get page by ID
+     */
+    const usePage = (pageId) => {
+        return useQuery({
+            queryKey: queryKeys.pages.detail(pageId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.libraryRunUrl}/api/library/v1/pages/${pageId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.page) {
+                    return toPage(resp.page);
+                }
+                throw new Error(resp.message || 'Failed to fetch page');
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!pageId,
+        });
+    };
+    /**
+     * Get all pages
+     */
+    const usePages = () => {
+        return useQuery({
+            queryKey: queryKeys.pages.all(),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.libraryRunUrl}/api/library/v1/pages`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.pages) {
+                    const pages = resp.pages
+                        .map((p) => {
+                        const page = toPage(p);
+                        if (page) {
+                            queryClient.setQueryData(queryKeys.pages.detail(page.id), page);
+                        }
+                        return page;
+                    })
+                        .filter(Boolean);
+                    return pages;
+                }
+                return [];
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+        });
+    };
+    /**
+     * Create page
+     */
+    const useCreatePage = () => {
+        return useMutation({
+            mutationFn: async (page) => {
+                return requestDatalayer({
+                    url: `${configuration.libraryRunUrl}/api/library/v1/pages`,
+                    method: 'POST',
+                    body: { ...page },
+                });
+            },
+            onSuccess: resp => {
+                if (resp.success && resp.page) {
+                    const page = toPage(resp.page);
+                    if (page) {
+                        // Set detail cache
+                        queryClient.setQueryData(queryKeys.pages.detail(page.id), page);
+                        // Invalidate list to refetch
+                        queryClient.invalidateQueries({
+                            queryKey: queryKeys.pages.all(),
+                        });
+                    }
+                }
+            },
+        });
+    };
+    /**
+     * Update page
+     */
+    const useUpdatePage = () => {
+        return useMutation({
+            mutationFn: async (page) => {
+                return requestDatalayer({
+                    url: `${configuration.libraryRunUrl}/api/library/v1/pages/${page.id}`,
+                    method: 'PUT',
+                    body: {
+                        name: page.name,
+                        description: page.description,
+                        tags: page.tags,
+                    },
+                });
+            },
+            onSuccess: (resp, page) => {
+                if (resp.success) {
+                    // Invalidate detail and list queries
+                    queryClient.invalidateQueries({
+                        queryKey: queryKeys.pages.detail(page.id),
+                    });
+                    queryClient.invalidateQueries({
+                        queryKey: queryKeys.pages.all(),
+                    });
+                }
+            },
+        });
+    };
+    /**
+     * Delete page
+     */
+    const useDeletePage = () => {
+        return useMutation({
+            mutationFn: async (pageId) => {
+                return requestDatalayer({
+                    url: `${configuration.libraryRunUrl}/api/library/v1/pages/${pageId}`,
+                    method: 'DELETE',
+                });
+            },
+            onSuccess: (_, pageId) => {
+                // Remove from detail cache
+                queryClient.removeQueries({ queryKey: queryKeys.pages.detail(pageId) });
+                // Invalidate list to refetch
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.pages.all(),
+                });
+            },
+        });
+    };
+    // ============================================================================
+    // Datasource, Secret, Token Hooks
+    // ============================================================================
+    /**
+     * Get all datasources
+     */
+    const useDatasources = () => {
+        return useQuery({
+            queryKey: queryKeys.datasources.all(),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/datasources`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.datasources) {
+                    const datasources = resp.datasources
+                        .map((d) => {
+                        const datasource = toDatasource(d);
+                        if (datasource) {
+                            queryClient.setQueryData(queryKeys.datasources.detail(datasource.id), datasource);
+                        }
+                        return datasource;
+                    })
+                        .filter(Boolean);
+                    return datasources;
+                }
+                return [];
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+        });
+    };
+    /**
+     * Create datasource
+     */
+    const useCreateDatasource = () => {
+        return useMutation({
+            mutationFn: async (datasource) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/datasources`,
+                    method: 'POST',
+                    body: { ...datasource },
+                });
+            },
+            onSuccess: resp => {
+                if (resp.success && resp.datasource) {
+                    const ds = toDatasource(resp.datasource);
+                    if (ds) {
+                        queryClient.setQueryData(queryKeys.datasources.detail(ds.id), ds);
+                    }
+                }
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.datasources.all(),
+                });
+            },
+        });
+    };
+    /**
+     * Get all secrets
+     */
+    const useSecrets = () => {
+        return useQuery({
+            queryKey: queryKeys.secrets.all(),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/secrets`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.secrets) {
+                    const secrets = resp.secrets
+                        .map((s) => {
+                        const secret = toSecret(s);
+                        if (secret) {
+                            queryClient.setQueryData(queryKeys.secrets.detail(secret.id), secret);
+                        }
+                        return secret;
+                    })
+                        .filter(Boolean);
+                    return secrets;
+                }
+                return [];
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+        });
+    };
+    /**
+     * Create secret
+     */
+    const useCreateSecret = () => {
+        return useMutation({
+            mutationFn: async (secret) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/secrets`,
+                    method: 'POST',
+                    body: { ...secret },
+                });
+            },
+            onSuccess: resp => {
+                if (resp.success && resp.secret) {
+                    const sec = toSecret(resp.secret);
+                    if (sec) {
+                        queryClient.setQueryData(queryKeys.secrets.detail(sec.id), sec);
+                    }
+                }
+                queryClient.invalidateQueries({ queryKey: queryKeys.secrets.all() });
+            },
+        });
+    };
+    /**
+     * Delete secret
+     */
+    const useDeleteSecret = () => {
+        return useMutation({
+            mutationFn: async (secretId) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/secrets/${secretId}`,
+                    method: 'DELETE',
+                });
+            },
+            onSuccess: (_, secretId) => {
+                queryClient.removeQueries({
+                    queryKey: queryKeys.secrets.detail(secretId),
+                });
+                queryClient.invalidateQueries({ queryKey: queryKeys.secrets.all() });
+            },
+        });
+    };
+    /**
+     * Get all tokens
+     */
+    const useTokens = () => {
+        return useQuery({
+            queryKey: queryKeys.tokens.all(),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/tokens`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.tokens) {
+                    const tokens = resp.tokens
+                        .map((t) => {
+                        const token = toToken(t);
+                        if (token) {
+                            queryClient.setQueryData(queryKeys.tokens.detail(token.id), token);
+                        }
+                        return token;
+                    })
+                        .filter(Boolean);
+                    return tokens;
+                }
+                return [];
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+        });
+    };
+    /**
+     * Create token
+     */
+    const useCreateToken = () => {
+        return useMutation({
+            mutationFn: async (token) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/tokens`,
+                    method: 'POST',
+                    body: {
+                        ...token,
+                        expirationDate: token.expirationDate.getTime(),
+                    },
+                });
+            },
+            onSuccess: resp => {
+                if (resp.success && resp.token) {
+                    const tok = toToken(resp.token);
+                    if (tok) {
+                        queryClient.setQueryData(queryKeys.tokens.detail(tok.id), tok);
+                    }
+                }
+                queryClient.invalidateQueries({ queryKey: queryKeys.tokens.all() });
+            },
+        });
+    };
+    // ============================================================================
+    // Contact Hooks
+    // ============================================================================
+    /**
+     * Get contact by ID
+     */
+    const useContact = (contactId) => {
+        return useQuery({
+            queryKey: queryKeys.contacts.detail(contactId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.contact) {
+                    const contact = toContact(resp.contact);
+                    if (contact) {
+                        queryClient.setQueryData(queryKeys.contacts.byHandle(contact.handle), contact);
+                    }
+                    return contact;
+                }
+                throw new Error(resp.message || 'Failed to fetch contact');
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!contactId,
+        });
+    };
+    /**
+     * Search contacts
+     */
+    const useSearchContacts = (query) => {
+        return useQuery({
+            queryKey: queryKeys.contacts.search(query),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/contacts/search`,
+                    method: 'POST',
+                    body: { query },
+                });
+                if (resp.success && resp.contacts) {
+                    const contacts = resp.contacts
+                        .map((c) => {
+                        const contact = toContact(c);
+                        if (contact) {
+                            queryClient.setQueryData(queryKeys.contacts.detail(contact.id), contact);
+                            queryClient.setQueryData(queryKeys.contacts.byHandle(contact.handle), contact);
+                        }
+                        return contact;
+                    })
+                        .filter(Boolean);
+                    return contacts;
+                }
+                return [];
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!query && query.length > 0,
+        });
+    };
+    /**
+     * Create contact
+     */
+    const useCreateContact = () => {
+        return useMutation({
+            mutationFn: async (contact) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/contacts`,
+                    method: 'POST',
+                    body: { contact },
+                });
+            },
+            onSuccess: resp => {
+                if (resp.success && resp.contact) {
+                    const contact = toContact(resp.contact);
+                    if (contact) {
+                        // Set detail cache
+                        queryClient.setQueryData(queryKeys.contacts.detail(contact.id), contact);
+                        // Invalidate all contact queries
+                        queryClient.invalidateQueries({
+                            queryKey: queryKeys.contacts.all(),
+                        });
+                    }
+                }
+            },
+        });
+    };
+    /**
+     * Update contact
+     */
+    const useUpdateContact = () => {
+        return useMutation({
+            mutationFn: async ({ contactId, contact, }) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}`,
+                    method: 'PUT',
+                    body: { contact },
+                });
+            },
+            onSuccess: (_, variables) => {
+                // Invalidate detail cache
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.contacts.detail(variables.contactId),
+                });
+                // Invalidate all contact queries
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.contacts.all(),
+                });
+            },
+        });
+    };
+    /**
+     * Delete contact
+     */
+    const useDeleteContact = () => {
+        return useMutation({
+            mutationFn: async (contactId) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}`,
+                    method: 'DELETE',
+                });
+            },
+            onSuccess: (_, contactId) => {
+                // Remove detail cache
+                queryClient.removeQueries({
+                    queryKey: queryKeys.contacts.detail(contactId),
+                });
+                // Invalidate all contact queries
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.contacts.all(),
+                });
+            },
+        });
+    };
+    // ============================================================================
+    // Delete Item Hook (generic)
+    // ============================================================================
+    /**
+     * Delete any item (notebook, document, cell, etc.)
+     */
+    const useDeleteItem = () => {
+        return useMutation({
+            mutationFn: async (itemId) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${itemId}`,
+                    method: 'DELETE',
+                });
+            },
+            onSuccess: (_, itemId) => {
+                // Remove from all possible item caches
+                queryClient.removeQueries({
+                    queryKey: queryKeys.notebooks.detail(itemId),
+                });
+                queryClient.removeQueries({
+                    queryKey: queryKeys.documents.detail(itemId),
+                });
+                queryClient.removeQueries({ queryKey: queryKeys.cells.detail(itemId) });
+                queryClient.removeQueries({
+                    queryKey: queryKeys.datasets.detail(itemId),
+                });
+                queryClient.removeQueries({
+                    queryKey: queryKeys.lessons.detail(itemId),
+                });
+                queryClient.removeQueries({
+                    queryKey: queryKeys.exercises.detail(itemId),
+                });
+                queryClient.removeQueries({
+                    queryKey: queryKeys.assignments.detail(itemId),
+                });
+                // Invalidate all artifact type queries
+                queryClient.invalidateQueries({ queryKey: queryKeys.notebooks.all() });
+                queryClient.invalidateQueries({ queryKey: queryKeys.documents.all() });
+                queryClient.invalidateQueries({ queryKey: queryKeys.cells.all() });
+                queryClient.invalidateQueries({ queryKey: queryKeys.datasets.all() });
+                queryClient.invalidateQueries({ queryKey: queryKeys.lessons.all() });
+                queryClient.invalidateQueries({ queryKey: queryKeys.exercises.all() });
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.assignments.all(),
+                });
+                // Invalidate space items lists
+                queryClient.invalidateQueries({ queryKey: queryKeys.items.all() });
+            },
+        });
+    };
+    // ============================================================================
+    // BATCH 1: Core CRUD Operations - Refresh & Get Methods
+    // ============================================================================
+    /**
+     * Get single datasource by ID
+     */
+    const useDatasource = (datasourceId) => {
+        return useQuery({
+            queryKey: queryKeys.datasources.detail(datasourceId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/datasources/${datasourceId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.datasource) {
+                    return toDatasource(resp.datasource);
+                }
+                return null;
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!datasourceId,
+        });
+    };
+    /**
+     * Update datasource
+     */
+    const useUpdateDatasource = () => {
+        return useMutation({
+            mutationFn: async (datasource) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/datasources/${datasource.id}`,
+                    method: 'PUT',
+                    body: { ...datasource },
+                });
+            },
+            onSuccess: resp => {
+                if (resp.success && resp.datasource) {
+                    const ds = toDatasource(resp.datasource);
+                    if (ds) {
+                        queryClient.setQueryData(queryKeys.datasources.detail(ds.id), ds);
+                    }
+                }
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.datasources.all(),
+                });
+            },
+        });
+    };
+    /**
+     * Get single secret by ID
+     */
+    const useSecret = (secretId) => {
+        return useQuery({
+            queryKey: queryKeys.secrets.detail(secretId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/secrets/${secretId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.secret) {
+                    return toSecret(resp.secret);
+                }
+                return null;
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!secretId,
+        });
+    };
+    /**
+     * Update secret
+     */
+    const useUpdateSecret = () => {
+        return useMutation({
+            mutationFn: async (secret) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/secrets/${secret.id}`,
+                    method: 'PUT',
+                    body: { ...secret },
+                });
+            },
+            onSuccess: resp => {
+                if (resp.success && resp.secret) {
+                    const sec = toSecret(resp.secret);
+                    if (sec) {
+                        queryClient.setQueryData(queryKeys.secrets.detail(sec.id), sec);
+                    }
+                }
+                queryClient.invalidateQueries({ queryKey: queryKeys.secrets.all() });
+            },
+        });
+    };
+    /**
+     * Get single token by ID
+     */
+    const useToken = (tokenId) => {
+        return useQuery({
+            queryKey: queryKeys.tokens.detail(tokenId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/tokens/${tokenId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.token) {
+                    return toToken(resp.token);
+                }
+                return null;
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!tokenId,
+        });
+    };
+    /**
+     * Update token
+     */
+    const useUpdateToken = () => {
+        return useMutation({
+            mutationFn: async (token) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/tokens/${token.id}`,
+                    method: 'PUT',
+                    body: { ...token },
+                });
+            },
+            onSuccess: resp => {
+                if (resp.success && resp.token) {
+                    const tok = toToken(resp.token);
+                    if (tok) {
+                        queryClient.setQueryData(queryKeys.tokens.detail(tok.id), tok);
+                    }
+                }
+                queryClient.invalidateQueries({ queryKey: queryKeys.tokens.all() });
+            },
+        });
+    };
+    /**
+     * Get contact by handle
+     */
+    const useContactByHandle = (handle) => {
+        return useQuery({
+            queryKey: queryKeys.contacts.byHandle(handle),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/contacts/handle/${handle}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.contact) {
+                    const contact = toContact(resp.contact);
+                    if (contact) {
+                        queryClient.setQueryData(queryKeys.contacts.detail(contact.id), contact);
+                    }
+                    return contact;
+                }
+                return null;
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!handle,
+        });
+    };
+    /**
+     * Get team by handle
+     */
+    const useTeamByHandle = (handle) => {
+        return useQuery({
+            queryKey: queryKeys.teams.byHandle(handle),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/teams/handle/${handle}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.team) {
+                    const team = toTeam(resp.team, resp.team.organization?.id || '');
+                    if (team) {
+                        queryClient.setQueryData(queryKeys.teams.detail(team.id), team);
+                    }
+                    return team;
+                }
+                return null;
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!handle,
+        });
+    };
+    /**
+     * Get organization space by handle
+     */
+    const useOrganizationSpaceByHandle = (organizationId, handle) => {
+        return useQuery({
+            queryKey: queryKeys.spaces.orgSpaceByHandle(organizationId, handle),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/organizations/${organizationId}/spaces/handle/${handle}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.space) {
+                    const space = toSpace(resp.space);
+                    if (space) {
+                        queryClient.setQueryData(queryKeys.spaces.detail(space.id), space);
+                    }
+                    return space;
+                }
+                return null;
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!organizationId && !!handle,
+        });
+    };
+    /**
+     * Get user space (personal space)
+     */
+    const useUserSpace = (spaceId) => {
+        return useQuery({
+            queryKey: queryKeys.spaces.detail(spaceId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.space) {
+                    return toSpace(resp.space);
+                }
+                return null;
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!spaceId,
+        });
+    };
+    /**
+     * Get user space by handle (personal space)
+     * This reads from the cache populated by useUserSpaces()
+     */
+    const useUserSpaceByHandle = (handle) => {
+        return useQuery({
+            queryKey: queryKeys.spaces.byHandle(handle),
+            queryFn: async () => {
+                // First check if we have it in the cache from useUserSpaces()
+                const cached = queryClient.getQueryData(queryKeys.spaces.byHandle(handle));
+                if (cached) {
+                    return cached;
+                }
+                // If not in cache, fetch all user spaces which will populate it
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/users/me`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.spaces) {
+                    let targetSpace = null;
+                    resp.spaces.forEach((spc) => {
+                        const space = toSpace(spc);
+                        if (space) {
+                            queryClient.setQueryData(queryKeys.spaces.detail(space.id), space);
+                            queryClient.setQueryData(queryKeys.spaces.byHandle(space.handle), space);
+                            if (space.handle === handle) {
+                                targetSpace = space;
+                            }
+                        }
+                    });
+                    return targetSpace;
+                }
+                return null;
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!handle && !!user,
+        });
+    };
+    /**
+     * Update organization space
+     */
+    const useUpdateOrganizationSpace = () => {
+        return useMutation({
+            mutationFn: async ({ organizationId, spaceId, updates, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/organizations/${organizationId}/spaces/${spaceId}`,
+                    method: 'PUT',
+                    body: updates,
+                });
+            },
+            onSuccess: (_, { spaceId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.spaces.detail(spaceId),
+                });
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.spaces.all(),
+                });
+            },
+        });
+    };
+    // ============================================================================
+    // BATCH 2: Member Management & User Extensions
+    // ============================================================================
+    /**
+     * Refresh user data by ID (re-fetch from API)
+     */
+    const useRefreshUser = () => {
+        return useMutation({
+            mutationFn: async (userId) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/users/${userId}`,
+                    method: 'GET',
+                });
+            },
+            onSuccess: (resp, userId) => {
+                if (resp.success && resp.user) {
+                    const user = toUser(resp.user);
+                    if (user) {
+                        queryClient.setQueryData(queryKeys.users.detail(userId), user);
+                        if (user.handle) {
+                            queryClient.setQueryData(queryKeys.users.byHandle(user.handle), user);
+                        }
+                    }
+                }
+                queryClient.invalidateQueries({ queryKey: queryKeys.users.all() });
+            },
+        });
+    };
+    /**
+     * Get user credits
+     */
+    const useUserCredits = (userId) => {
+        return useQuery({
+            queryKey: [...queryKeys.users.detail(userId), 'credits'],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/usage/credits/users/${userId}`,
+                    method: 'GET',
+                });
+                if (resp.success) {
+                    return resp.credits || 0;
+                }
+                return 0;
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+            enabled: !!userId,
+        });
+    };
+    /**
+     * Update user credits
+     */
+    const useUpdateUserCredits = () => {
+        return useMutation({
+            mutationFn: async ({ userId, credits, brand, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/usage/credits/users/${userId}`,
+                    method: 'PUT',
+                    body: { credits, brand },
+                });
+            },
+            onSuccess: (_, { userId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: [...queryKeys.users.detail(userId), 'credits'],
+                });
+            },
+        });
+    };
+    /**
+     * Add member to organization
+     */
+    const useAddMemberToOrganization = () => {
+        return useMutation({
+            mutationFn: async ({ organizationId, userId, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}/members/${userId}`,
+                    method: 'POST',
+                });
+            },
+            onSuccess: (_, { organizationId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.organizations.members(organizationId),
+                });
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.organizations.detail(organizationId),
+                });
+            },
+        });
+    };
+    /**
+     * Remove member from organization
+     */
+    const useRemoveMemberFromOrganization = () => {
+        return useMutation({
+            mutationFn: async ({ organizationId, userId, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}/members/${userId}`,
+                    method: 'DELETE',
+                });
+            },
+            onSuccess: (_, { organizationId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.organizations.members(organizationId),
+                });
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.organizations.detail(organizationId),
+                });
+            },
+        });
+    };
+    /**
+     * Add role to organization member
+     */
+    const useAddRoleToOrganizationMember = () => {
+        return useMutation({
+            mutationFn: async ({ organizationId, userId, roleName, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}/members/${userId}/roles/${roleName}`,
+                    method: 'POST',
+                });
+            },
+            onSuccess: (_, { organizationId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.organizations.members(organizationId),
+                });
+            },
+        });
+    };
+    /**
+     * Remove role from organization member
+     */
+    const useRemoveRoleFromOrganizationMember = () => {
+        return useMutation({
+            mutationFn: async ({ organizationId, userId, roleName, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}/members/${userId}/roles/${roleName}`,
+                    method: 'DELETE',
+                });
+            },
+            onSuccess: (_, { organizationId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.organizations.members(organizationId),
+                });
+            },
+        });
+    };
+    /**
+     * Add member to team
+     */
+    const useAddMemberToTeam = () => {
+        return useMutation({
+            mutationFn: async ({ teamId, userId, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}/members/${userId}`,
+                    method: 'POST',
+                });
+            },
+            onSuccess: (_, { teamId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.teams.members(teamId),
+                });
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.teams.detail(teamId),
+                });
+            },
+        });
+    };
+    /**
+     * Remove member from team
+     */
+    const useRemoveMemberFromTeam = () => {
+        return useMutation({
+            mutationFn: async ({ teamId, userId, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}/members/${userId}`,
+                    method: 'DELETE',
+                });
+            },
+            onSuccess: (_, { teamId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.teams.members(teamId),
+                });
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.teams.detail(teamId),
+                });
+            },
+        });
+    };
+    /**
+     * Add role to team member
+     */
+    const useAddRoleToTeamMember = () => {
+        return useMutation({
+            mutationFn: async ({ teamId, userId, roleName, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}/members/${userId}/roles/${roleName}`,
+                    method: 'POST',
+                });
+            },
+            onSuccess: (_, { teamId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.teams.members(teamId),
+                });
+            },
+        });
+    };
+    /**
+     * Remove role from team member
+     */
+    const useRemoveRoleFromTeamMember = () => {
+        return useMutation({
+            mutationFn: async ({ teamId, userId, roleName, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}/members/${userId}/roles/${roleName}`,
+                    method: 'DELETE',
+                });
+            },
+            onSuccess: (_, { teamId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.teams.members(teamId),
+                });
+            },
+        });
+    };
+    /**
+     * Add member to organization space
+     */
+    const useAddMemberToOrganizationSpace = () => {
+        return useMutation({
+            mutationFn: async ({ organizationId, spaceId, accountId, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/organizations/${organizationId}/members/${accountId}`,
+                    method: 'POST',
+                });
+            },
+            onSuccess: (_, { spaceId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.spaces.members(spaceId),
+                });
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.spaces.detail(spaceId),
+                });
+            },
+        });
+    };
+    /**
+     * Remove member from organization space
+     */
+    const useRemoveMemberFromOrganizationSpace = () => {
+        return useMutation({
+            mutationFn: async ({ organizationId, spaceId, accountId, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/organizations/${organizationId}/members/${accountId}`,
+                    method: 'DELETE',
+                });
+            },
+            onSuccess: (_, { spaceId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.spaces.members(spaceId),
+                });
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.spaces.detail(spaceId),
+                });
+            },
+        });
+    };
+    /**
+     * Make space public
+     */
+    const useMakeSpacePublic = () => {
+        return useMutation({
+            mutationFn: async (spaceId) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/public`,
+                    method: 'PUT',
+                });
+            },
+            onSuccess: (_, spaceId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.spaces.detail(spaceId),
+                });
+            },
+        });
+    };
+    /**
+     * Make space private
+     */
+    const useMakeSpacePrivate = () => {
+        return useMutation({
+            mutationFn: async (spaceId) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/private`,
+                    method: 'PUT',
+                });
+            },
+            onSuccess: (_, spaceId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.spaces.detail(spaceId),
+                });
+            },
+        });
+    };
+    // ============================================================================
+    // BATCH 3: Authentication, Roles, Schools, and Refresh Methods
+    // ============================================================================
+    /**
+     * Change user password
+     */
+    const useChangePassword = () => {
+        return useMutation({
+            mutationFn: async ({ handle, password, passwordConfirm, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/password`,
+                    method: 'PUT',
+                    body: { handle, password, passwordConfirm },
+                });
+            },
+        });
+    };
+    /**
+     * Request email update
+     */
+    const useRequestEmailUpdate = () => {
+        return useMutation({
+            mutationFn: async (email) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/me/email`,
+                    method: 'PUT',
+                    body: { email },
+                });
+            },
+        });
+    };
+    /**
+     * Confirm email update with token
+     */
+    const useConfirmEmailUpdate = () => {
+        return useMutation({
+            mutationFn: async (token) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/me/email`,
+                    method: 'POST',
+                    body: { token },
+                });
+            },
+            onSuccess: () => {
+                // Invalidate current user cache
+                queryClient.invalidateQueries({ queryKey: queryKeys.auth.me() });
+            },
         });
     };
-    const getOAuth2AuthorizationLinkURL = async (queryArgs) => {
-        return requestDatalayer({
-            url: URLExt.join(configuration.iamRunUrl, 'api/iam/v1/oauth2/authz/url/link') + URLExt.objectToQueryString(queryArgs),
+    /**
+     * Assign role to user
+     */
+    const useAssignRoleToUser = () => {
+        return useMutation({
+            mutationFn: async ({ userId, roleName, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/users/${userId}/roles/${roleName}`,
+                    method: 'POST',
+                });
+            },
+            onSuccess: (_, { userId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.users.detail(userId),
+                });
+            },
         });
     };
-    // IAM Providers ------------------------------------------------------------
-    const getGitHubProfile = async (accessToken) => {
-        return fetch(IAMProvidersSpecs.GitHub.userInfoURL, {
-            method: 'GET',
-            headers: {
-                Accept: 'application/vnd.github+json',
-                Authorization: `Bearer ${accessToken}`,
-                'X-GitHub-Api-Version': '2022-11-28',
+    /**
+     * Unassign role from user
+     */
+    const useUnassignRoleFromUser = () => {
+        return useMutation({
+            mutationFn: async ({ userId, roleName, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/users/${userId}/roles/${roleName}`,
+                    method: 'DELETE',
+                });
+            },
+            onSuccess: (_, { userId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.users.detail(userId),
+                });
             },
-        }).then(resp => resp.json());
+        });
     };
-    /*
-     * CORS is not supported @see https://github.com/linkedin-developers/linkedin-api-js-client
+    /**
+     * Get all schools
      */
-    const getLinkedinProfile = async (accessToken) => {
-        return proxyGET(IAMProvidersSpecs.LinkedIn.userInfoURL, accessToken).then(resp => {
-            return new LinkedInUser(resp.response);
+    const useSchools = () => {
+        return useQuery({
+            queryKey: ['schools'],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/organizations/schools`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.orgs) {
+                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+                    const schools = resp.orgs.map((s) => ({
+                        id: s.uid,
+                        type: 'school',
+                        handle: s.handle_s,
+                        name: s.name_t,
+                        description: s.description_t,
+                        dean: undefined,
+                        members: [],
+                        students: [],
+                        courses: [],
+                        public: s.public_b,
+                        creationDate: new Date(s.creation_ts_dt),
+                        setMembers(members) {
+                            this.members = members;
+                        },
+                    }));
+                    return schools;
+                }
+                return [];
+            },
+            ...DEFAULT_QUERY_OPTIONS,
         });
     };
-    const postLinkedinShare = async (linkedinUser, postText, accessToken) => {
-        const POST_SHARE_REQUEST = {
-            author: linkedinUser.getUrn(),
-            lifecycleState: 'PUBLISHED',
-            specificContent: {
-                'com.linkedin.ugc.ShareContent': {
-                    shareCommentary: {
-                        text: postText,
-                    },
-                    shareMediaCategory: 'NONE',
-                },
+    /**
+     * Refresh organization data
+     */
+    const useRefreshOrganization = () => {
+        return useMutation({
+            mutationFn: async (organizationId) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}`,
+                    method: 'GET',
+                });
             },
-            visibility: {
-                'com.linkedin.ugc.MemberNetworkVisibility': 'PUBLIC',
+            onSuccess: (resp, organizationId) => {
+                if (resp.success && resp.organization) {
+                    const org = toOrganization(resp.organization);
+                    if (org) {
+                        queryClient.setQueryData(queryKeys.organizations.detail(organizationId), org);
+                        if (org.handle) {
+                            queryClient.setQueryData(queryKeys.organizations.byHandle(org.handle), org);
+                        }
+                    }
+                }
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.organizations.all(),
+                });
             },
-        };
-        return proxyPOST(IAMProvidersSpecs.LinkedIn.postShareURL, POST_SHARE_REQUEST, accessToken);
-    };
-    const postLinkedinShareWithUpload = async (linkedinUser, postText, uploadObject, accessToken) => {
-        const REGISTER_UPLOAD_REQUEST = {
-            registerUploadRequest: {
-                recipes: ['urn:li:digitalmediaRecipe:feedshare-image'],
-                owner: linkedinUser.getUrn(),
-                serviceRelationships: [
-                    {
-                        relationshipType: 'OWNER',
-                        identifier: 'urn:li:userGeneratedContent',
-                    },
-                ],
+        });
+    };
+    /**
+     * Refresh user organizations
+     */
+    const useRefreshUserOrganizations = () => {
+        return useMutation({
+            mutationFn: async () => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/organizations`,
+                    method: 'GET',
+                });
             },
-        };
-        return proxyPOST(IAMProvidersSpecs.LinkedIn.registerUploadURL, REGISTER_UPLOAD_REQUEST, accessToken).then(registerUploadReponse => {
-            /*
-              {
-                "value": {
-                    "uploadMechanism": {
-                        "com.linkedin.digitalmedia.uploading.MediaUploadHttpRequest": {
-                            "headers": {},
-                            "uploadUrl": "https://api.linkedin.com/mediaUpload/C5522AQGTYER3k3ByHQ/feedshare-uploadedImage/0?ca=vector_feedshare&cn=uploads&m=AQJbrN86Zm265gAAAWemyz2pxPSgONtBiZdchrgG872QltnfYjnMdb2j3A&app=1953784&sync=0&v=beta&ut=2H-IhpbfXrRow1"
+            onSuccess: resp => {
+                if (resp.success && resp.organizations) {
+                    resp.organizations.forEach((org) => {
+                        const organization = toOrganization(org);
+                        if (organization) {
+                            queryClient.setQueryData(queryKeys.organizations.detail(organization.id), organization);
+                            if (organization.handle) {
+                                queryClient.setQueryData(queryKeys.organizations.byHandle(organization.handle), organization);
+                            }
                         }
-                    },
-                    "mediaArtifact": "urn:li:digitalmediaMediaArtifact:(urn:li:digitalmediaAsset:C5522AQGTYER3k3ByHQ,urn:li:digitalmediaMediaArtifactClass:feedshare-uploadedImage)",
-                    "asset": "urn:li:digitalmediaAsset:C5522AQGTYER3k3ByHQ"
-                }
-              }
-              */
-            const asset = registerUploadReponse.response.value.asset;
-            const uploadURL = registerUploadReponse.response.value.uploadMechanism['com.linkedin.digitalmedia.uploading.MediaUploadHttpRequest'].uploadUrl;
-            const UPLOAD_OBJECT_REQUEST = {
-                uploadURL: uploadURL,
-                content: uploadObject,
-                userURN: linkedinUser.getUrn(),
-            };
-            return proxyPUT(uploadURL, UPLOAD_OBJECT_REQUEST, accessToken).then(resp => {
-                const share = {
-                    author: linkedinUser.getUrn(),
-                    lifecycleState: 'PUBLISHED',
-                    specificContent: {
-                        'com.linkedin.ugc.ShareContent': {
-                            shareCommentary: {
-                                text: postText,
-                            },
-                            shareMediaCategory: 'IMAGE',
-                            media: [
-                                {
-                                    status: 'READY',
-                                    description: {
-                                        text: 'Datalayer Notebook',
-                                    },
-                                    media: asset,
-                                    title: {
-                                        text: 'Datalayer Notebook',
-                                    },
-                                },
-                            ],
-                        },
-                    },
-                    visibility: {
-                        'com.linkedin.ugc.MemberNetworkVisibility': 'PUBLIC',
-                    },
-                };
-                return proxyPOST(IAMProvidersSpecs.LinkedIn.postShareURL, share, accessToken);
-            });
+                    });
+                }
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.organizations.userOrgs(),
+                });
+            },
         });
     };
-    // Proxy -------------------------------------------------------------------
-    const proxyGET = async (url, token) => {
-        return requestDatalayer({
-            url: URLExt.join(configuration.iamRunUrl, 'api/iam/v1/proxy/request'),
-            method: 'POST',
-            body: {
-                request_method: 'GET',
-                request_url: url,
-                request_token: token,
-            },
-        });
-    };
-    const proxyPOST = async (url, body, token) => {
-        return requestDatalayer({
-            url: URLExt.join(configuration.iamRunUrl, 'api/iam/v1/proxy/request'),
-            method: 'POST',
-            body: {
-                request_method: 'POST',
-                request_url: url,
-                request_token: token,
-                request_body: body,
-            },
-        });
-    };
-    const proxyPUT = async (url, body, token) => {
-        return requestDatalayer({
-            url: URLExt.join(configuration.iamRunUrl, 'api/iam/v1/proxy/request'),
-            method: 'POST',
-            body: {
-                request_method: 'PUT',
-                request_url: url,
-                request_token: token,
-                request_body: body,
-            },
-        });
-    };
-    // Waiting List -------------------------------------------------------------
-    const registerToWaitingList = (formData) => {
-        requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/waitinglist/register`,
-            method: 'POST',
-            body: {
-                firstName: formData.firstName,
-                lastName: formData.lastName,
-                email: formData.email,
-                affiliation: formData.affiliation || '',
-            },
-        })
-            .then(resp => {
-            // Special case, make the error very explicit to the user...
-            if (!resp.success) {
-                alert('Sorry, something has gone wrong... Please send an email to eric@datalayer.io to register to the waiting list.');
-            }
-        })
-            .catch(err => {
-            // Special case, make the error very explicit to the user...
-            console.error(err);
-            alert('Sorry, something has gone wrong... Please send an email to eric@datalayer.io to register to the waiting list.');
-        });
-    };
-    // Profile ------------------------------------------------------------------
-    const getMe = async (token) => {
-        const resp = await requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/me`,
-            method: 'GET',
-            token,
-        });
-        const me = resp.me;
-        if (me) {
-            const user = asUser(me);
-            return user;
-        }
-        return null;
+    /**
+     * Refresh team data
+     */
+    const useRefreshTeam = () => {
+        return useMutation({
+            mutationFn: async ({ teamId, organizationId: _organizationId, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}`,
+                    method: 'GET',
+                });
+            },
+            onSuccess: (resp, { teamId, organizationId }) => {
+                if (resp.success && resp.team) {
+                    const team = toTeam(resp.team, organizationId);
+                    if (team) {
+                        queryClient.setQueryData(queryKeys.teams.detail(teamId), team);
+                        if (team.handle) {
+                            queryClient.setQueryData(queryKeys.teams.byHandle(team.handle), team);
+                        }
+                    }
+                }
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.teams.byOrganization(organizationId),
+                });
+            },
+        });
     };
-    const updateMe = (email, firstName, lastName) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/me`,
-            method: 'PUT',
-            body: {
-                email,
-                firstName,
-                lastName,
+    /**
+     * Refresh teams for organization
+     */
+    const useRefreshTeams = () => {
+        return useMutation({
+            mutationFn: async (organizationId) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/teams`,
+                    method: 'GET',
+                    body: { organizationId },
+                });
+            },
+            onSuccess: (resp, organizationId) => {
+                if (resp.success && resp.teams) {
+                    resp.teams.forEach((t) => {
+                        const team = toTeam(t, organizationId);
+                        if (team) {
+                            queryClient.setQueryData(queryKeys.teams.detail(team.id), team);
+                            if (team.handle) {
+                                queryClient.setQueryData(queryKeys.teams.byHandle(team.handle), team);
+                            }
+                        }
+                    });
+                }
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.teams.byOrganization(organizationId),
+                });
             },
         });
     };
-    const whoami = () => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/whoami`,
-            method: 'GET',
+    /**
+     * Refresh organization space
+     */
+    const useRefreshOrganizationSpace = () => {
+        return useMutation({
+            mutationFn: async ({ organizationId, spaceId, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/organizations/${organizationId}/spaces/${spaceId}`,
+                    method: 'GET',
+                });
+            },
+            onSuccess: (resp, { organizationId, spaceId }) => {
+                if (resp.success && resp.space) {
+                    const space = toSpace(resp.space);
+                    if (space) {
+                        queryClient.setQueryData(queryKeys.spaces.detail(spaceId), space);
+                    }
+                }
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.spaces.byOrganization(organizationId),
+                });
+            },
         });
     };
-    const requestEmailUpdate = email => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/me/email`,
-            method: 'PUT',
-            body: {
-                email,
+    /**
+     * Refresh organization spaces
+     */
+    const useRefreshOrganizationSpaces = () => {
+        return useMutation({
+            mutationFn: async (organizationId) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/organizations/${organizationId}/spaces`,
+                    method: 'GET',
+                });
+            },
+            onSuccess: (resp, organizationId) => {
+                if (resp.success && resp.spaces) {
+                    resp.spaces.forEach((s) => {
+                        const space = toSpace(s);
+                        if (space) {
+                            queryClient.setQueryData(queryKeys.spaces.detail(space.id), space);
+                        }
+                    });
+                }
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.spaces.byOrganization(organizationId),
+                });
             },
         });
     };
-    const confirmEmailUpdate = token => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/me/email`,
-            method: 'POST',
-            body: {
-                token,
+    /**
+     * Refresh user spaces
+     */
+    const useRefreshUserSpaces = () => {
+        return useMutation({
+            mutationFn: async () => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/users/me`,
+                    method: 'GET',
+                });
+            },
+            onSuccess: resp => {
+                if (resp.success && resp.spaces) {
+                    resp.spaces.forEach((s) => {
+                        const space = toSpace(s);
+                        if (space) {
+                            queryClient.setQueryData(queryKeys.spaces.detail(space.id), space);
+                        }
+                    });
+                }
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.spaces.userSpaces(),
+                });
             },
         });
     };
-    // Onboarding ---------------------------------------------------------------
-    const updateUserOnboarding = (onboarding) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/onboardings`,
-            method: 'PUT',
-            body: {
-                onboarding,
+    // ============================================================================
+    // BATCH 4: Courses, Space Items, and Advanced Features
+    // ============================================================================
+    /**
+     * Get course by ID
+     */
+    const useCourse = (courseId) => {
+        return useQuery({
+            queryKey: ['courses', 'detail', courseId],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.course) {
+                    return toCourse(resp.course);
+                }
+                return undefined;
             },
+            enabled: !!courseId,
+            ...DEFAULT_QUERY_OPTIONS,
         });
     };
-    // Settings -----------------------------------------------------------------
-    const updateUserSettings = (userId, settings) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/users/${userId}/settings`,
-            method: 'PUT',
-            body: {
-                aiagents_url_s: settings.aiAgentsUrl,
-                can_invite_b: settings.canInvite || false,
+    /**
+     * Update course
+     */
+    const useUpdateCourse = () => {
+        return useMutation({
+            mutationFn: async ({ courseId, name, description, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}`,
+                    method: 'PUT',
+                    body: { name, description },
+                });
+            },
+            onSuccess: (_, { courseId }) => {
+                // Invalidate detail cache
+                queryClient.invalidateQueries({
+                    queryKey: ['courses', 'detail', courseId],
+                });
+                // Invalidate all course queries
+                queryClient.invalidateQueries({
+                    queryKey: ['courses'],
+                });
             },
         });
     };
-    // Pages ------------------------------------------------------------------
-    const toPage = (s) => {
-        if (s) {
-            const page = asPage(s);
-            PAGES_BY_ID.set(s.uid, page);
-            return page;
-        }
+    /**
+     * Get public courses
+     */
+    const usePublicCourses = () => {
+        return useQuery({
+            queryKey: ['courses', 'public'],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.libraryRunUrl}/api/library/v1/courses/public`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.courses) {
+                    return resp.courses.map((course) => toCourse(course));
+                }
+                return [];
+            },
+            ...DEFAULT_QUERY_OPTIONS,
+        });
     };
-    const createPage = (page) => {
-        return requestDatalayer({
-            url: `${configuration.libraryRunUrl}/api/library/v1/pages`,
-            method: 'POST',
-            body: { ...page },
-        }).then(resp => {
-            if (resp.success) {
-                if (resp.page) {
-                    const pageId = resp.page.uid;
-                    PAGES_BY_ID.set(pageId, {
-                        ...page,
-                        id: pageId,
-                    });
+    /**
+     * Get instructor courses
+     */
+    const useInstructorCourses = (userId) => {
+        return useQuery({
+            queryKey: ['courses', 'instructor', userId],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/instructors/${userId}/courses`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.courses) {
+                    return resp.courses.map((course) => toCourse(course));
                 }
-            }
-            return resp;
+                return [];
+            },
+            enabled: !!userId,
+            ...DEFAULT_QUERY_OPTIONS,
+        });
+    };
+    /**
+     * Get course enrollments for current user
+     */
+    const useCourseEnrollments = () => {
+        return useQuery({
+            queryKey: ['courses', 'enrollments', 'me'],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/enrollments/me`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.enrollments) {
+                    return resp.enrollments.map((enrollment) => toCourse(enrollment));
+                }
+                return [];
+            },
+            ...DEFAULT_QUERY_OPTIONS,
         });
     };
-    const updatePage = (page) => {
-        return requestDatalayer({
-            url: `${configuration.libraryRunUrl}/api/library/v1/pages/${page.id}`,
-            method: 'PUT',
-            body: {
-                name: page.name,
-                description: page.description,
-                tags: page.tags,
+    /**
+     * Enroll student to course
+     */
+    const useEnrollStudentToCourse = () => {
+        return useMutation({
+            mutationFn: async ({ courseId, studentId, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}/enrollments/students/${studentId}`,
+                    method: 'POST',
+                });
+            },
+            onSuccess: (_, { courseId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['courses', 'detail', courseId],
+                });
+                queryClient.invalidateQueries({
+                    queryKey: ['courses', 'enrollments'],
+                });
+            },
+        });
+    };
+    /**
+     * Remove student from course
+     */
+    const useRemoveStudentFromCourse = () => {
+        return useMutation({
+            mutationFn: async ({ courseId, studentId, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}/enrollments/students/${studentId}`,
+                    method: 'DELETE',
+                });
             },
-        }).then(resp => {
-            if (resp.success) {
-                if (resp.page) {
-                    toPage(resp.page);
+            onSuccess: (_, { courseId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['courses', 'detail', courseId],
+                });
+                queryClient.invalidateQueries({
+                    queryKey: ['courses', 'enrollments'],
+                });
+            },
+        });
+    };
+    /**
+     * Get space items
+     */
+    const useSpaceItems = (spaceId) => {
+        return useQuery({
+            queryKey: ['spaces', spaceId, 'items'],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.items) {
+                    // eslint-disable-next-line @typescript-eslint/no-explicit-any
+                    return asArray(resp.items).map((itm) => toItem(itm));
                 }
-            }
-            return resp;
+                return [];
+            },
+            enabled: !!spaceId,
+            ...DEFAULT_QUERY_OPTIONS,
+        });
+    };
+    /**
+     * Make item public
+     */
+    const useMakeItemPublic = () => {
+        return useMutation({
+            mutationFn: async (itemId) => {
+                return requestDatalayer({
+                    url: `${configuration.libraryRunUrl}/api/library/v1/items/${itemId}/public`,
+                    method: 'PUT',
+                });
+            },
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: ['spaces'] });
+            },
         });
     };
-    const deletePage = (page) => {
-        return requestDatalayer({
-            url: `${configuration.libraryRunUrl}/api/library/v1/pages/${page.id}`,
-            method: 'DELETE',
+    /**
+     * Make item private
+     */
+    const useMakeItemPrivate = () => {
+        return useMutation({
+            mutationFn: async (itemId) => {
+                return requestDatalayer({
+                    url: `${configuration.libraryRunUrl}/api/library/v1/items/${itemId}/private`,
+                    method: 'PUT',
+                });
+            },
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: ['spaces'] });
+            },
         });
     };
-    const getPage = (pageId) => PAGES_BY_ID.get(pageId);
-    const clearCachedPages = () => PAGES_BY_ID.clear();
-    const refreshPage = (pageId) => {
-        return requestDatalayer({
-            url: `${configuration.libraryRunUrl}/api/library/v1/pages/${pageId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                if (resp.page) {
-                    toPage(resp.page);
+    /**
+     * Get user organization by ID (helper method)
+     */
+    const useUserOrganizationById = (organizationId) => {
+        const { data: userOrganizations } = useUserOrganizations();
+        return userOrganizations?.find(org => org.id === organizationId);
+    };
+    /**
+     * Refresh layout (loads user, organization, and space data)
+     */
+    const useRefreshLayout = () => {
+        return useMutation({
+            mutationFn: async ({ accountHandle, spaceHandle, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/layouts/accounts/${accountHandle}${spaceHandle !== undefined ? '/spaces/' + spaceHandle : ''}`,
+                    method: 'GET',
+                });
+            },
+            onSuccess: (resp, variables) => {
+                if (resp.success) {
+                    // Set data directly into cache instead of just invalidating
+                    if (resp.user) {
+                        queryClient.setQueryData(queryKeys.users.byHandle(variables.accountHandle), resp.user);
+                        queryClient.invalidateQueries({ queryKey: queryKeys.users.all() });
+                    }
+                    if (resp.organization) {
+                        queryClient.setQueryData(queryKeys.organizations.byHandle(variables.accountHandle), resp.organization);
+                        queryClient.invalidateQueries({
+                            queryKey: queryKeys.organizations.all(),
+                        });
+                    }
+                    if (resp.space) {
+                        // Set both user and org space queries based on which type it is
+                        if (resp.user && variables.spaceHandle) {
+                            queryClient.setQueryData(queryKeys.spaces.byHandle(variables.spaceHandle), resp.space);
+                        }
+                        if (resp.organization && variables.spaceHandle) {
+                            queryClient.setQueryData(queryKeys.spaces.orgSpaceByHandle(resp.organization.id, variables.spaceHandle), resp.space);
+                        }
+                        queryClient.invalidateQueries({ queryKey: queryKeys.spaces.all() });
+                    }
                 }
-            }
-            return resp;
-        });
-    };
-    const getPages = () => {
-        return Array.from(PAGES_BY_ID.values());
-    };
-    const refreshPages = () => {
-        return requestDatalayer({
-            url: `${configuration.libraryRunUrl}/api/library/v1/pages`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const pages = resp.pages;
-                if (pages) {
-                    PAGES_BY_ID.clear();
-                    pages.forEach(page => {
-                        toPage(page);
-                    });
+            },
+        });
+    };
+    /**
+     * Export space
+     */
+    const useExportSpace = () => {
+        return useMutation({
+            mutationFn: async (spaceId) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/export`,
+                    method: 'GET',
+                });
+            },
+        });
+    };
+    // ============================================================================
+    // BATCH 5: Cells, Datasets, Environments, and Lessons
+    // ============================================================================
+    /**
+     * Get cell by ID
+     */
+    const useCell = (cellId) => {
+        return useQuery({
+            queryKey: queryKeys.cells.detail(cellId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${cellId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.item) {
+                    return toCell(resp.item);
                 }
-            }
-            return resp;
+                return undefined;
+            },
+            enabled: !!cellId,
+            ...DEFAULT_QUERY_OPTIONS,
         });
     };
-    // Datasources ------------------------------------------------------------------
-    const toDatasource = (s) => {
-        if (s) {
-            const datasource = asDatasource(s);
-            DATASOURCES_BY_ID.set(s.uid, datasource);
-            return datasource;
-        }
+    /**
+     * Get cells by space
+     */
+    const useCellsBySpace = (spaceId) => {
+        return useQuery({
+            queryKey: queryKeys.cells.bySpace(spaceId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/cell`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.items) {
+                    return resp.items.map((item) => toCell(item));
+                }
+                return [];
+            },
+            enabled: !!spaceId,
+            ...DEFAULT_QUERY_OPTIONS,
+        });
     };
-    const createDatasource = (datasource) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/datasources`,
-            method: 'POST',
-            body: { ...datasource },
-        }).then(resp => {
-            if (resp.success) {
-                if (resp.datasource) {
-                    toDatasource(resp.datasource);
+    /**
+     * Update cell
+     */
+    const useUpdateCell = () => {
+        return useMutation({
+            mutationFn: async (cell) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/cells/${cell.id}`,
+                    method: 'PUT',
+                    body: cell,
+                });
+            },
+            onSuccess: (resp, cell) => {
+                if (resp.success) {
+                    // Invalidate detail and list queries
+                    queryClient.invalidateQueries({
+                        queryKey: queryKeys.cells.detail(cell.id),
+                    });
+                    queryClient.invalidateQueries({
+                        queryKey: queryKeys.cells.bySpace(cell.spaceId),
+                    });
                 }
-            }
-            return resp;
+            },
+        });
+    };
+    /**
+     * Clone cell
+     */
+    const useCloneCell = () => {
+        return useMutation({
+            mutationFn: async (cellId) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/cells/${cellId}/clone`,
+                    method: 'POST',
+                });
+            },
+            onSuccess: (resp, _cellId) => {
+                if (resp.success && resp.cell) {
+                    const cell = toCell(resp.cell);
+                    // Set detail cache
+                    queryClient.setQueryData(queryKeys.cells.detail(cell.id), cell);
+                    // Invalidate list to refetch
+                    if (cell?.space) {
+                        const spaceIdStr = typeof cell.space === 'string'
+                            ? cell.space
+                            : (cell.space.id ?? '');
+                        if (spaceIdStr) {
+                            queryClient.invalidateQueries({
+                                queryKey: queryKeys.cells.bySpace(spaceIdStr),
+                            });
+                        }
+                    }
+                }
+            },
         });
     };
-    const updateDatasource = (datasource) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/datasources/${datasource.id}`,
-            method: 'PUT',
-            body: { ...datasource },
-        }).then(resp => {
-            if (resp.success) {
-                if (resp.datasource) {
-                    toDatasource(resp.datasource);
+    /**
+     * Get dataset by ID
+     */
+    const useDataset = (datasetId) => {
+        return useQuery({
+            queryKey: queryKeys.datasets.detail(datasetId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${datasetId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.item) {
+                    return toDataset(resp.item);
                 }
-            }
-            return resp;
+                return undefined;
+            },
+            enabled: !!datasetId,
+            ...DEFAULT_QUERY_OPTIONS,
         });
     };
-    const getDatasource = (datasourceId) => DATASOURCES_BY_ID.get(datasourceId);
-    const clearCachedDatasources = () => DATASOURCES_BY_ID.clear();
-    const refreshDatasource = (datasourceId) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/datasources/${datasourceId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                if (resp.datasource) {
-                    toDatasource(resp.datasource);
+    /**
+     * Get datasets by space
+     */
+    const useDatasetsBySpace = (spaceId) => {
+        return useQuery({
+            queryKey: queryKeys.datasets.bySpace(spaceId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/dataset`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.items) {
+                    return resp.items.map((item) => toDataset(item));
                 }
-            }
-            return resp;
-        });
-    };
-    const getDatasources = () => {
-        return Array.from(DATASOURCES_BY_ID.values());
-    };
-    const refreshDatasources = () => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/datasources`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const datasources = resp.datasources;
-                if (datasources) {
-                    SECRETS_BY_ID.clear();
-                    datasources.forEach(datasource => {
-                        toDatasource(datasource);
+                return [];
+            },
+            enabled: !!spaceId,
+            ...DEFAULT_QUERY_OPTIONS,
+        });
+    };
+    /**
+     * Update dataset
+     */
+    const useUpdateDataset = () => {
+        return useMutation({
+            mutationFn: async ({ id, name, description, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/datasets/${id}`,
+                    method: 'PUT',
+                    body: { name, description },
+                });
+            },
+            onSuccess: (resp, { id, spaceId }) => {
+                if (resp.success) {
+                    // Invalidate detail and list queries
+                    queryClient.invalidateQueries({
+                        queryKey: queryKeys.datasets.detail(id),
                     });
+                    if (spaceId) {
+                        queryClient.invalidateQueries({
+                            queryKey: queryKeys.datasets.bySpace(spaceId),
+                        });
+                    }
                 }
-            }
-            return resp;
+            },
         });
     };
-    // Secrets ------------------------------------------------------------------
-    const toSecret = (s) => {
-        if (s) {
-            const secret = asSecret(s);
-            SECRETS_BY_ID.set(s.uid, secret);
-            return secret;
-        }
-    };
-    const createSecret = (secret) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/secrets`,
-            method: 'POST',
-            body: { ...secret },
-        }).then(resp => {
-            if (resp.success) {
-                if (resp.secret) {
-                    toSecret(resp.secret);
+    /**
+     * Get environment by ID
+     */
+    const useEnvironment = (environmentId) => {
+        return useQuery({
+            queryKey: queryKeys.environments.detail(environmentId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${environmentId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.item) {
+                    return toEnvironment(resp.item);
                 }
-            }
-            return resp;
+                return undefined;
+            },
+            enabled: !!environmentId,
+            ...DEFAULT_QUERY_OPTIONS,
         });
     };
-    const updateSecret = (secret) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/secrets/${secret.id}`,
-            method: 'PUT',
-            body: { ...secret },
-        }).then(resp => {
-            if (resp.success) {
-                if (resp.secret) {
-                    toSecret(resp.secret);
+    /**
+     * Get environments by space
+     */
+    const useEnvironmentsBySpace = (spaceId) => {
+        return useQuery({
+            queryKey: queryKeys.environments.bySpace(spaceId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/environment`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.items) {
+                    return resp.items.map((item) => toEnvironment(item));
                 }
-            }
-            return resp;
+                return [];
+            },
+            enabled: !!spaceId,
+            ...DEFAULT_QUERY_OPTIONS,
         });
     };
-    const deleteSecret = (secret) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/secrets/${secret.id}`,
-            method: 'DELETE',
+    /**
+     * Get lesson by ID
+     */
+    const useLesson = (lessonId) => {
+        return useQuery({
+            queryKey: queryKeys.lessons.detail(lessonId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/lessons/${lessonId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.lesson) {
+                    return toLesson(resp.lesson);
+                }
+                return undefined;
+            },
+            enabled: !!lessonId,
+            ...DEFAULT_QUERY_OPTIONS,
         });
     };
-    const getSecret = (secretId) => SECRETS_BY_ID.get(secretId);
-    const clearCachedSecrets = () => SECRETS_BY_ID.clear();
-    const refreshSecret = (secretId) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/secrets/${secretId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                if (resp.secret) {
-                    toSecret(resp.secret);
-                }
-            }
-            return resp;
-        });
-    };
-    const getSecrets = () => {
-        return Array.from(SECRETS_BY_ID.values());
-    };
-    const refreshSecrets = () => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/secrets`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const secrets = resp.secrets;
-                if (secrets) {
-                    SECRETS_BY_ID.clear();
-                    secrets.forEach(secret => {
-                        toSecret(secret);
-                    });
+    /**
+     * Get lessons by space
+     */
+    const useLessonsBySpace = (spaceId) => {
+        return useQuery({
+            queryKey: queryKeys.lessons.bySpace(spaceId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/lesson`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.items) {
+                    return resp.items.map((item) => toLesson(item));
                 }
-            }
-            return resp;
+                return [];
+            },
+            enabled: !!spaceId,
+            ...DEFAULT_QUERY_OPTIONS,
         });
     };
-    // Tokens ------------------------------------------------------------------
-    const toToken = (s) => {
-        if (s) {
-            const token = asToken(s);
-            TOKENS_BY_ID.set(s.uid, token);
-            return token;
-        }
-    };
-    const createToken = (token) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/tokens`,
-            method: 'POST',
-            body: {
-                ...token,
-                expirationDate: token.expirationDate.getTime(),
+    /**
+     * Clone lesson
+     */
+    const useCloneLesson = () => {
+        return useMutation({
+            mutationFn: async (lessonId) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${lessonId}/clone`,
+                    method: 'POST',
+                });
             },
-        }).then(resp => {
-            if (resp.success) {
-                if (resp.token) {
-                    toToken(resp.token);
+            onSuccess: (resp, _lessonId) => {
+                if (resp.success && resp.notebook) {
+                    const lesson = toLesson(resp.notebook);
+                    // Set detail cache
+                    queryClient.setQueryData(queryKeys.lessons.detail(lesson.id), lesson);
+                    // Invalidate list to refetch
+                    if (lesson?.space) {
+                        const spaceIdStr = typeof lesson.space === 'string'
+                            ? lesson.space
+                            : (lesson.space.id ?? '');
+                        if (spaceIdStr) {
+                            queryClient.invalidateQueries({
+                                queryKey: queryKeys.lessons.bySpace(spaceIdStr),
+                            });
+                        }
+                    }
                 }
-            }
-            return resp;
+            },
         });
     };
-    const updateToken = (token) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/tokens/${token.id}`,
-            method: 'PUT',
-            body: { ...token },
-        }).then(resp => {
-            if (resp.success) {
-                if (resp.token) {
-                    toToken(resp.token);
+    // ============================================================================
+    // BATCH 6: Exercises, Assignments, Invites, and Contacts
+    // ============================================================================
+    /**
+     * Get exercise by ID
+     */
+    const useExercise = (exerciseId) => {
+        return useQuery({
+            queryKey: queryKeys.exercises.detail(exerciseId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${exerciseId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.item) {
+                    return toExercise(resp.item);
                 }
-            }
-            return resp;
+                return undefined;
+            },
+            enabled: !!exerciseId,
+            ...DEFAULT_QUERY_OPTIONS,
         });
     };
-    const getToken = (tokenId) => TOKENS_BY_ID.get(tokenId);
-    const clearCachedTokens = () => TOKENS_BY_ID.clear();
-    const refreshToken = (tokenId) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/tokens/${tokenId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                if (resp.token) {
-                    toToken(resp.token);
-                }
-            }
-            return resp;
-        });
-    };
-    const getTokens = () => {
-        return Array.from(TOKENS_BY_ID.values());
-    };
-    const refreshTokens = () => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/tokens`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const tokens = resp.tokens;
-                if (tokens) {
-                    TOKENS_BY_ID.clear();
-                    tokens.forEach(token => {
-                        toToken(token);
-                    });
+    /**
+     * Get exercises by space
+     */
+    const useExercisesBySpace = (spaceId) => {
+        return useQuery({
+            queryKey: queryKeys.exercises.bySpace(spaceId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/exercise`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.items) {
+                    return resp.items.map((item) => toExercise(item));
                 }
-            }
-            return resp;
+                return [];
+            },
+            enabled: !!spaceId,
+            ...DEFAULT_QUERY_OPTIONS,
         });
     };
-    // Layout -------------------------------------------------------------------
-    const refreshLayout = (accountHandle, spaceHandle, user) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/layouts/accounts/${accountHandle}${spaceHandle !== undefined ? '/spaces/' + spaceHandle : ''}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                if (resp.user) {
-                    toUser(resp.user);
-                }
-                let organization = undefined;
-                if (resp.organization) {
-                    organization = toOrganization(resp.organization);
-                    if (user && checkIsOrganizationMember(user, organization)) {
-                        ORGANISATIONS_FOR_USER_BY_ID.set(organization.id, organization);
-                    }
-                }
-                if (resp.space) {
-                    const space = toSpace(resp.space);
-                    if (organization) {
-                        let osById = SPACES_BY_ID_BY_ORGANISATION_ID.get(organization.id);
-                        if (!osById) {
-                            osById = new Map();
-                            SPACES_BY_ID_BY_ORGANISATION_ID.set(organization.id, osById);
-                        }
-                        osById.set(space.id, space);
-                        let osByHandle = SPACES_BY_HANDLE_BY_ORGANISATION_HANDLE.get(organization.handle);
-                        if (!osByHandle) {
-                            osByHandle = new Map();
-                            SPACES_BY_HANDLE_BY_ORGANISATION_HANDLE.set(organization.handle, osByHandle);
+    /**
+     * Update exercise
+     */
+    const useUpdateExercise = () => {
+        return useMutation({
+            mutationFn: async ({ id, name, description, help, codePre, codeSolution, codeQuestion, codeTest, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/exercises/${id}`,
+                    method: 'PUT',
+                    body: {
+                        name,
+                        description,
+                        help,
+                        codePre,
+                        codeSolution,
+                        codeQuestion,
+                        codeTest,
+                    },
+                });
+            },
+            onSuccess: (_, { id }) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.exercises.detail(id),
+                });
+                queryClient.invalidateQueries({ queryKey: queryKeys.exercises.all() });
+            },
+        });
+    };
+    /**
+     * Clone exercise
+     */
+    const useCloneExercise = () => {
+        return useMutation({
+            mutationFn: async (exerciseId) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/exercises/${exerciseId}/clone`,
+                    method: 'POST',
+                });
+            },
+            onSuccess: resp => {
+                if (resp.success && resp.exercise) {
+                    const exercise = toExercise(resp.exercise);
+                    // Set detail cache
+                    queryClient.setQueryData(queryKeys.exercises.detail(exercise.id), exercise);
+                    // Invalidate list to refetch
+                    if (exercise?.space) {
+                        const spaceIdStr = typeof exercise.space === 'string'
+                            ? exercise.space
+                            : (exercise.space.id ?? '');
+                        if (spaceIdStr) {
+                            queryClient.invalidateQueries({
+                                queryKey: queryKeys.exercises.bySpace(spaceIdStr),
+                            });
                         }
-                        osByHandle.set(space.handle, space);
-                    }
-                    else {
-                        SPACES_FOR_USER_BY_HANDLE.set(space.handle, space);
-                        SPACES_FOR_USER_BY_ID.set(space.id, space);
-                    }
-                }
-            }
-            return resp;
-        });
-    };
-    // Invites -------------------------------------------------------------------
-    const requestInvite = (firstName, lastName, email, socialUrl) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/invites/request`,
-            method: 'POST',
-            body: {
-                first_name: firstName,
-                last_name: lastName,
-                email: email,
-                social_url: socialUrl,
-            },
-        });
-    };
-    const sendInvite = (invite) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/invites`,
-            method: 'POST',
-            body: {
-                email: invite.to.email,
-                firstName: invite.to.firstName,
-                lastName: invite.to.lastName,
-                message: invite.message,
-                brand: invite.brand,
-            },
-        });
-    };
-    const getInvite = (token) => INVITES_BY_TOKEN.get(token);
-    const clearCachedInvites = () => INVITES_BY_TOKEN.clear();
-    const refreshInvite = (token) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/invites/tokens/${token}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const i = resp.invite;
-                if (i) {
-                    const invite = asInvite(i);
-                    if (invite.token) {
-                        INVITES_BY_TOKEN.set(invite.token, invite);
                     }
                 }
-            }
-            return resp;
-        });
-    };
-    const getInvites = () => {
-        return Array.from(INVITES_BY_TOKEN.values());
-    };
-    const refreshInvites = (accountId) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/invites/users/${accountId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.invites.forEach(i => {
-                    const invite = asInvite(i);
-                    if (invite.token) {
-                        INVITES_BY_TOKEN.set(invite.token, invite);
-                    }
-                });
-            }
-            return resp;
+            },
         });
     };
-    const putInvite = (token) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/invites/tokens/${token}`,
-            method: 'PUT',
+    /**
+     * Get assignment by ID
+     */
+    const useAssignment = (assignmentId) => {
+        return useQuery({
+            queryKey: queryKeys.assignments.detail(assignmentId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.assignment) {
+                    return toAssignment(resp.assignment);
+                }
+                return undefined;
+            },
+            enabled: !!assignmentId,
+            ...DEFAULT_QUERY_OPTIONS,
         });
     };
-    // Accounts -------------------------------------------------------------------
-    const refreshAccount = (accountHandle) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/accounts/${accountHandle}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                if (resp.user) {
-                    toUser(resp.user);
-                }
-                if (resp.organization) {
-                    toOrganization(resp.organization);
+    /**
+     * Get assignments by space
+     */
+    const useAssignmentsBySpace = (spaceId) => {
+        return useQuery({
+            queryKey: queryKeys.assignments.bySpace(spaceId),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/assignment`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.items) {
+                    return resp.items.map((item) => toAssignment(item));
                 }
-            }
-            return resp;
+                return [];
+            },
+            enabled: !!spaceId,
+            ...DEFAULT_QUERY_OPTIONS,
         });
     };
-    // Contacts ---------------------------------------------------------------------
-    const toContact = (c) => {
-        if (c) {
-            const contact = asContact(c);
-            CONTACTS_BY_ID.set(contact.id, contact);
-            CONTACTS_BY_HANDLE.set(contact.handle, contact);
-            return contact;
-        }
-    };
-    const getContactById = (contactId) => CONTACTS_BY_ID.get(contactId);
-    const getContactByHandle = (contactHandle) => CONTACTS_BY_HANDLE.get(contactHandle);
-    const createContact = (contact) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/contacts`,
-            method: 'POST',
-            body: {
-                contact,
-            },
-        }).then(resp => {
-            if (resp.success) {
-                toContact(resp.contact);
-            }
-            return resp;
+    /**
+     * Clone assignment
+     */
+    const useCloneAssignment = () => {
+        return useMutation({
+            mutationFn: async (assignmentId) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${assignmentId}/clone`,
+                    method: 'POST',
+                });
+            },
+            onSuccess: resp => {
+                if (resp.success && resp.notebook) {
+                    const assignment = toAssignment(resp.notebook);
+                    // Set detail cache
+                    queryClient.setQueryData(queryKeys.assignments.detail(assignment.id), assignment);
+                    // Invalidate list to refetch
+                    if (assignment?.space) {
+                        const spaceIdStr = typeof assignment.space === 'string'
+                            ? assignment.space
+                            : (assignment.space.id ?? '');
+                        if (spaceIdStr) {
+                            queryClient.invalidateQueries({
+                                queryKey: queryKeys.assignments.bySpace(spaceIdStr),
+                            });
+                        }
+                    }
+                }
+            },
         });
     };
-    const updateContact = (contactId, contact) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}`,
-            method: 'PUT',
-            body: {
-                contact,
+    /**
+     * Get invite by token
+     */
+    const useInvite = (token) => {
+        return useQuery({
+            queryKey: ['invites', 'token', token],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/invites/tokens/${token}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.invite) {
+                    return asInvite(resp.invite);
+                }
+                return undefined;
             },
-        }).then(resp => {
-            if (resp.success) {
-                toContact(resp.contact);
-            }
-            return resp;
+            enabled: !!token,
+            ...DEFAULT_QUERY_OPTIONS,
         });
     };
-    const refreshContact = (contactId) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                toContact(resp.contact);
-            }
-            return resp;
+    /**
+     * Get invites for user
+     */
+    const useInvitesByUser = (accountId) => {
+        return useQuery({
+            queryKey: ['invites', 'user', accountId],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/invites/users/${accountId}`,
+                    method: 'GET',
+                });
+                if (resp.success && resp.invites) {
+                    return resp.invites.map((i) => asInvite(i));
+                }
+                return [];
+            },
+            enabled: !!accountId,
+            ...DEFAULT_QUERY_OPTIONS,
         });
     };
-    const searchContacts = (query) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/search`,
-            method: 'POST',
-            body: {
-                query,
+    /**
+     * Accept/put invite
+     */
+    const usePutInvite = () => {
+        return useMutation({
+            mutationFn: async (token) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/invites/tokens/${token}`,
+                    method: 'PUT',
+                });
+            },
+            onSuccess: (_, token) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['invites', 'token', token],
+                });
+                queryClient.invalidateQueries({ queryKey: ['invites', 'user'] });
             },
-        }).then(resp => {
-            if (resp.success) {
-                const contacts = resp.contacts.map(contact => toContact(contact));
-                resp.contacts = contacts;
-            }
-            return resp;
         });
     };
-    const assignTagToContact = (contactId, tagName) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}/tags/${tagName}`,
-            method: 'POST',
+    // ============================================================================
+    // [BATCH 7] Assignment Student Operations
+    // ============================================================================
+    /**
+     * Fetch assignment from student perspective with enrollment data
+     */
+    const useAssignmentForStudent = (assignmentId, courseId, userId, options) => {
+        return useQuery({
+            queryKey: ['assignments', 'student', assignmentId, courseId, userId],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}/courses/${courseId}/students/${userId}`,
+                    method: 'GET',
+                });
+                if (!resp.success) {
+                    throw new Error(resp.message || 'Failed to fetch assignment for student');
+                }
+                return resp.assignment;
+            },
+            ...options,
         });
     };
-    const unassignTagFromContact = (contactId, tagName) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}/tags/${tagName}`,
-            method: 'DELETE',
+    /**
+     * Reset assignment for a student (clear their progress)
+     */
+    const useResetAssignmentForStudent = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ assignmentId, courseId: _courseId, userId: _userId, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}/reset`,
+                    method: 'POST',
+                });
+            },
+            onSuccess: (_, { assignmentId, courseId, userId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['assignments', 'student', assignmentId, courseId, userId],
+                });
+                queryClient.invalidateQueries({
+                    queryKey: ['assignments', assignmentId],
+                });
+            },
         });
     };
-    const deleteContact = (contactId) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}`,
-            method: 'DELETE',
+    /**
+     * Grade an assignment for a student
+     */
+    const useGradeAssignmentForStudent = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ assignmentId, courseId: _courseId, userId, model, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}/students/${userId}/grade`,
+                    method: 'PUT',
+                    body: { model },
+                });
+            },
+            onSuccess: (_, { assignmentId, courseId, userId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['assignments', 'student', assignmentId, courseId, userId],
+                });
+                queryClient.invalidateQueries({
+                    queryKey: ['assignments', assignmentId],
+                });
+            },
         });
     };
-    const sendInviteToContact = (contact, message) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/invites`,
-            method: 'POST',
-            body: {
-                contactId: contact.id,
-                message,
+    /**
+     * Get student version of assignment (submission view)
+     */
+    const useAssignmentStudentVersion = (assignmentId, options) => {
+        return useQuery({
+            queryKey: ['assignments', 'studentVersion', assignmentId],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}/student_version`,
+                    method: 'GET',
+                });
+                return resp;
             },
+            ...options,
         });
     };
-    // Contacts Enrich ----------------------------------------------------------
-    const enrichContactEmail = (contactId, useDomain) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}/enrich/email?useDomain=${useDomain}`,
-            method: 'GET',
+    // ============================================================================
+    // [BATCH 7] Exercise Grading
+    // ============================================================================
+    /**
+     * Grade an exercise by assigning points to student code
+     */
+    const useUpdateExercisePoints = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ exerciseId, codeStudent, points, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/exercises/${exerciseId}/points`,
+                    method: 'PUT',
+                    body: { codeStudent, points },
+                });
+            },
+            onSuccess: (_, { exerciseId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['exercises', exerciseId],
+                });
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.exercises.all(),
+                });
+            },
         });
     };
-    const enrichContactLinkedin = contactId => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}/enrich/linkedin`,
-            method: 'GET',
+    // ============================================================================
+    // [BATCH 7] Course Student & Course Items
+    // ============================================================================
+    /**
+     * Get a student in a course
+     */
+    const useStudent = (courseId, studentId, options) => {
+        return useQuery({
+            queryKey: ['courses', courseId, 'students', studentId],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}/enrollments/students/${studentId}`,
+                    method: 'GET',
+                });
+                if (!resp.success) {
+                    throw new Error(resp.message || 'Failed to fetch student');
+                }
+                return resp.student;
+            },
+            enabled: !!courseId && !!studentId,
+            ...options,
         });
     };
-    const sendLinkedinConnectionRequest = (contact, message) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contact.id}/connect/linkedin`,
-            method: 'POST',
-            body: {
-                message,
+    /**
+     * Mark a course item as completed
+     */
+    const useConfirmCourseItemCompletion = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ courseId, itemType, itemId, completed, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${courseId}/types/${itemType}/items/${itemId}/complete`,
+                    method: 'PUT',
+                    body: { completed },
+                });
+            },
+            onSuccess: (_, { courseId, itemId: _itemId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['courses', courseId],
+                });
+                queryClient.invalidateQueries({
+                    queryKey: ['courses', courseId, 'items'],
+                });
             },
-        }).then(resp => {
-            if (resp.success) {
-                toContact(resp.contact);
-            }
-            return resp;
         });
     };
-    // Contacts Links -----------------------------------------------------------
-    const linkUserWithContact = (userId, contactId) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/users/${userId}/contacts/${contactId}/link`,
-            method: 'POST',
+    /**
+     * Set the curriculum items for a course
+     */
+    const useSetCourseItems = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ courseId, itemIds, }) => {
+                return requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}/items`,
+                    method: 'PUT',
+                    body: { itemIds },
+                });
+            },
+            onSuccess: (_, { courseId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['courses', courseId],
+                });
+                queryClient.invalidateQueries({
+                    queryKey: ['courses', courseId, 'items'],
+                });
+            },
         });
     };
-    const unlinkUserFromContact = (userId, contactId) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/users/${userId}/contacts/${contactId}/link`,
-            method: 'DELETE',
+    // ============================================================================
+    // [BATCH 7] Inbounds & Outbounds
+    // ============================================================================
+    /**
+     * Get all inbound leads
+     */
+    const useInbounds = (options) => {
+        return useQuery({
+            queryKey: ['inbounds'],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.inboundsRunUrl}/api/inbounds/v1/inbounds`,
+                    method: 'GET',
+                });
+                if (!resp.success) {
+                    throw new Error(resp.message || 'Failed to fetch inbounds');
+                }
+                return resp.inbounds;
+            },
+            ...options,
         });
     };
-    // Users --------------------------------------------------------------------
-    const toUser = (u) => {
-        if (u) {
-            const user = asUser(u);
-            USERS_BY_ID.set(user.id, user);
-            USERS_BY_HANDLE.set(user.handle, user);
-            return user;
-        }
+    /**
+     * Get a specific outbound by ID
+     */
+    const useOutbound = (outboundId, options) => {
+        return useQuery({
+            queryKey: ['outbounds', outboundId],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/${outboundId}`,
+                    method: 'GET',
+                });
+                if (!resp.success) {
+                    throw new Error(resp.message || 'Failed to fetch outbound');
+                }
+                return resp.outbound;
+            },
+            enabled: !!outboundId,
+            ...options,
+        });
     };
-    const getUser = (id) => USERS_BY_ID.get(id);
-    const getUserByHandle = (handle) => USERS_BY_HANDLE.get(handle);
-    const refreshUser = (userId) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/users/${userId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                toUser(resp.user);
-            }
-            return resp;
+    /**
+     * Get all outbound campaigns
+     */
+    const useOutbounds = (options) => {
+        return useQuery({
+            queryKey: ['outbounds'],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/outbounds`,
+                    method: 'GET',
+                });
+                if (!resp.success) {
+                    throw new Error(resp.message || 'Failed to fetch outbounds');
+                }
+                return resp.outbounds;
+            },
+            ...options,
         });
     };
-    const searchUsers = (namingPattern) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/users/search`,
-            method: 'POST',
-            body: {
-                namingPattern,
+    /**
+     * Draft bulk emails for outbound campaign
+     */
+    const useDraftBulkEmailsOutbounds = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (params) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/emails/bulk/draft`,
+                    method: 'POST',
+                    body: params,
+                });
+            },
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: ['outbounds'] });
             },
-        }).then(resp => {
-            if (resp.success) {
-                const users = resp.users.map(user => toUser(user));
-                resp.users = users;
-            }
-            return resp;
         });
     };
-    // User Roles ---------------------------------------------------------------
-    const assignRoleToUser = (userId, roleName) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/users/${userId}/roles/${roleName}`,
-            method: 'POST',
+    // ============================================================================
+    // [BATCH 8] Advanced Outbound Operations
+    // ============================================================================
+    /**
+     * Try bulk emails (test mode) for outbound campaign
+     */
+    const useTryBulkEmailsOutbounds = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (outboundId) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/${outboundId}/try`,
+                    method: 'POST',
+                    body: {},
+                });
+            },
+            onSuccess: (_, outboundId) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['outbounds', outboundId],
+                });
+            },
         });
     };
-    const unassignRoleFromUser = (userId, roleName) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/users/${userId}/roles/${roleName}`,
-            method: 'DELETE',
+    /**
+     * Launch bulk emails for outbound campaign (production mode)
+     */
+    const useLaunchBulkEmailsOutbounds = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (outboundId) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/${outboundId}/launch`,
+                    method: 'POST',
+                    body: {},
+                });
+            },
+            onSuccess: (_, outboundId) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['outbounds', outboundId],
+                });
+                queryClient.invalidateQueries({ queryKey: ['outbounds'] });
+            },
         });
     };
-    // Organizations -------------------------------------------------------------------
-    const toOrganization = (org) => {
-        const organization = asOrganization(org);
-        ORGANISATIONS_BY_ID.set(organization.id, organization);
-        ORGANISATIONS_BY_HANDLE.set(organization.handle, organization);
-        return organization;
-    };
-    const createOrganization = (organization) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/organizations`,
-            method: 'POST',
-            body: {
-                handle: organization.handle,
-                name: organization.name,
-                description: organization.description,
-            },
-        }).then(resp => {
-            const organization = toOrganization(resp.organization);
-            ORGANISATIONS_FOR_USER_BY_ID.set(organization.id, organization);
-            return resp;
-        });
-    };
-    const getOrganizationById = (organizationId) => ORGANISATIONS_BY_ID.get(organizationId);
-    const getOrganizationByHandle = (organizationHandle) => ORGANISATIONS_BY_HANDLE.get(organizationHandle);
-    const clearCachedOrganizations = () => {
-        ORGANISATIONS_BY_HANDLE.clear();
-        ORGANISATIONS_BY_ID.clear();
-        ORGANISATIONS_FOR_USER_BY_ID.clear();
-    };
-    const refreshOrganization = (user, organizationId) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const org = resp.organization;
-                if (org) {
-                    const organization = toOrganization(org);
-                    if (checkIsOrganizationMember(user, organization)) {
-                        ORGANISATIONS_FOR_USER_BY_ID.set(organizationId, organization);
-                    }
-                }
-            }
-            return resp;
+    /**
+     * Send individual outbound email to a user
+     */
+    const useSendOutboundEmailToUser = () => {
+        return useMutation({
+            mutationFn: async ({ userId, recipient, subject, content, }) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/email`,
+                    method: 'POST',
+                    body: { userId, recipient, subject, content },
+                });
+            },
         });
     };
-    const updateOrganization = (organization) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organization.id}`,
-            method: 'PUT',
-            body: {
-                name: organization.name,
-                description: organization.description,
+    /**
+     * Delete an outbound campaign
+     */
+    const useDeleteOutbound = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (outboundId) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/${outboundId}`,
+                    method: 'DELETE',
+                });
             },
-        }).then(resp => {
-            if (resp.success) {
-                const org = getOrganizationById(organization.id);
-                if (org) {
-                    org.name = organization.name;
-                    org.description = organization.description;
-                }
-            }
-            return resp;
-        });
-    };
-    const getUserOrganizations = () => Array.from(ORGANISATIONS_FOR_USER_BY_ID.values());
-    const getUserOrganizationById = (organizationId) => ORGANISATIONS_FOR_USER_BY_ID.get(organizationId);
-    const refreshUserOrganizations = (user) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/organizations`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.organizations.forEach(org => {
-                    const organization = toOrganization(org);
-                    if (checkIsOrganizationMember(user, organization)) {
-                        ORGANISATIONS_FOR_USER_BY_ID.set(organization.id, organization);
-                    }
+            onSuccess: (_, outboundId) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['outbounds', outboundId],
                 });
-            }
-            return resp;
+                queryClient.invalidateQueries({ queryKey: ['outbounds'] });
+            },
         });
     };
-    const addMemberToOrganization = (organizationId, userId) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}/members/${userId}`,
-            method: 'POST',
+    // ============================================================================
+    // [BATCH 8] Outbound Subscriptions
+    // ============================================================================
+    /**
+     * Subscribe a user to outbound communications
+     */
+    const useSubscribeUserToOutbounds = () => {
+        return useMutation({
+            mutationFn: async (userId) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/outbounds/users/${userId}`,
+                    method: 'PUT',
+                });
+            },
         });
     };
-    const removeMemberFromOrganization = (organizationId, userId) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}/members/${userId}`,
-            method: 'DELETE',
+    /**
+     * Unsubscribe a user from outbound communications
+     */
+    const useUnsubscribeUserFromOutbounds = () => {
+        return useMutation({
+            mutationFn: async (userId) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/outbounds/users/${userId}`,
+                    method: 'DELETE',
+                });
+            },
         });
     };
-    const addRoleToOrganizationMember = (organizationId, userId, roleName) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}/members/${userId}/roles/${roleName}`,
-            method: 'POST',
+    /**
+     * Unsubscribe a contact from outbound communications
+     */
+    const useUnsubscribeContactFromOutbounds = () => {
+        return useMutation({
+            mutationFn: async (contactId) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/contacts/unsubscribe/${contactId}`,
+                    method: 'GET',
+                });
+            },
         });
     };
-    const removeRoleFromOrganizationMember = (organizationId, userId, roleName) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}/members/${userId}/roles/${roleName}`,
-            method: 'DELETE',
+    /**
+     * Unsubscribe an invitee from outbound communications
+     */
+    const useUnsubscribeInviteeFromOutbounds = () => {
+        return useMutation({
+            mutationFn: async (token) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/unsubscribe/${token}`,
+                    method: 'GET',
+                });
+            },
         });
     };
-    // Teams -------------------------------------------------------------------
-    const toTeam = (org, organizationId) => {
-        const team = asTeam(org, organizationId);
-        TEAMS_BY_ID.set(team.id, team);
-        TEAMS_BY_HANDLE.set(team.handle, team);
-        return team;
-    };
-    const createTeam = (team, organization) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/teams`,
-            method: 'POST',
-            body: {
-                handle: team.handle,
-                name: team.name,
-                description: team.description,
-                organizationId: organization.id,
-            },
-        }).then(resp => {
-            const team = toTeam(resp.team, organization.id);
-            TEAMS_BY_HANDLE.set(team.handle, team);
-            TEAMS_BY_ID.set(team.id, team);
-            return resp;
-        });
-    };
-    const getTeamById = (teamId) => TEAMS_BY_ID.get(teamId);
-    const getTeamByHandle = (teamHandle) => TEAMS_BY_HANDLE.get(teamHandle);
-    const clearCachedTeams = () => {
-        TEAMS_BY_HANDLE.clear();
-        TEAMS_BY_ID.clear();
-    };
-    const refreshTeam = (teamId, organizationId) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const t = resp.team;
-                if (t) {
-                    const team = toTeam(t, organizationId);
-                    TEAMS_BY_HANDLE.set(team.handle, team);
-                    TEAMS_BY_ID.set(team.id, team);
-                }
-            }
-            return resp;
+    // ============================================================================
+    // [BATCH 8] MFA (Multi-Factor Authentication)
+    // ============================================================================
+    /**
+     * Enable MFA for current user
+     */
+    const useEnableUserMFA = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async () => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/mfa`,
+                    method: 'PUT',
+                });
+            },
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: ['me'] });
+            },
         });
     };
-    const updateTeam = (team) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/teams/${team.id}`,
-            method: 'PUT',
-            body: {
-                name: team.name,
-                description: team.description,
+    /**
+     * Disable MFA for current user
+     */
+    const useDisableUserMFA = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async () => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/mfa`,
+                    method: 'DELETE',
+                });
             },
-        }).then(resp => {
-            if (resp.success) {
-                const t = resp.team;
-                if (t) {
-                    const tt = toTeam(t, team.organization.id);
-                    TEAMS_BY_HANDLE.set(team.handle, tt);
-                    TEAMS_BY_ID.set(team.id, tt);
-                }
-            }
-            return resp;
-        });
-    };
-    const getTeamsByOrganizationId = (organizationId) => TEAMS_BY_ORGANIZATION_BY_ID.get(organizationId);
-    const refreshTeams = (organizationId) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}/teams`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const teams = resp.teams.map(t => {
-                    const team = toTeam(t, organizationId);
-                    TEAMS_BY_HANDLE.set(team.handle, team);
-                    TEAMS_BY_ID.set(team.id, team);
-                    return team;
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: ['me'] });
+            },
+        });
+    };
+    /**
+     * Validate MFA code for a user
+     */
+    const useValidateUserMFACode = () => {
+        return useMutation({
+            mutationFn: async ({ userUid, code, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/mfa`,
+                    method: 'POST',
+                    body: { userUid, code },
                 });
-                TEAMS_BY_ORGANIZATION_BY_ID.set(organizationId, teams);
-            }
-            return resp;
+            },
         });
     };
-    const addMemberToTeam = (teamId, userId) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}/members/${userId}`,
-            method: 'POST',
+    // ============================================================================
+    // [BATCH 8] Checkout & Credits
+    // ============================================================================
+    /**
+     * Get Stripe pricing information
+     */
+    const useStripePrices = (options) => {
+        return useQuery({
+            queryKey: ['stripe', 'prices'],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/stripe/v1/prices`,
+                    method: 'GET',
+                });
+                return resp.prices || [];
+            },
+            ...options,
         });
     };
-    const removeMemberFromTeam = (teamId, userId) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}/members/${userId}`,
-            method: 'DELETE',
+    /**
+     * Create Stripe checkout session
+     */
+    const useCreateCheckoutSession = () => {
+        return useMutation({
+            mutationFn: async ({ product, location, }) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/stripe/v1/checkout/session`,
+                    method: 'POST',
+                    body: {
+                        price_id: product?.id,
+                        return_url: `${location.protocol}//${location.host}${location.pathname.split('/').slice(0, -1).join('/')}`,
+                    },
+                });
+                return resp.client_secret;
+            },
         });
     };
-    const addRoleToTeamMember = (teamId, userId, roleName) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}/members/${userId}/roles/${roleName}`,
-            method: 'POST',
+    /**
+     * Burn user credits (deduct from balance)
+     */
+    const useBurnCredit = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (credits) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/usage/credits`,
+                    method: 'DELETE',
+                    body: { credits },
+                });
+            },
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: ['users', 'credits'] });
+            },
         });
     };
-    const removeRoleFromTeamMember = (teamId, userId, roleName) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}/members/${userId}/roles/${roleName}`,
-            method: 'DELETE',
+    // ============================================================================
+    // [BATCH 8] Support & Surveys
+    // ============================================================================
+    /**
+     * Request platform support (first form)
+     */
+    const useRequestPlatformSupport = () => {
+        return useMutation({
+            mutationFn: async ({ subject, message, email, brand, }) => {
+                return requestDatalayer({
+                    url: `${configuration.supportRunUrl}/api/support/v1/support/request`,
+                    method: 'POST',
+                    body: { subject, message, email, brand },
+                });
+            },
         });
     };
-    // Schools -------------------------------------------------------------------
-    const getSchools = () => {
-        return Array.from(SCHOOLS_BY_ID.values());
-    };
-    const refreshSchools = () => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/schools`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.orgs.forEach(s => {
-                    const dean = undefined;
-                    const students = new Array();
-                    const members = new Array();
-                    const courses = new Array();
-                    const school = {
-                        id: s.uid,
-                        type: 'school',
-                        handle: s.handle_s,
-                        name: s.name_t,
-                        description: s.description_t,
-                        dean,
-                        members,
-                        students,
-                        courses,
-                        public: s.public_b,
-                        creationDate: new Date(s.creation_ts_dt),
-                        setMembers(members) {
-                            this.members = members;
-                        },
-                    };
-                    SCHOOLS_BY_ID.set(school.id, school);
+    /**
+     * Request platform support (second form with more details)
+     */
+    const useRequestPlatformSupport2 = () => {
+        return useMutation({
+            mutationFn: async ({ accountHandle, firstName, lastName, email, message, }) => {
+                return requestDatalayer({
+                    url: `${configuration.supportRunUrl}/api/support/v1/support/request2`,
+                    method: 'POST',
+                    body: { accountHandle, firstName, lastName, email, message },
                 });
-            }
-            return resp;
+            },
         });
     };
-    // Spaces -------------------------------------------------------------------
-    const toSpace = (spc) => {
-        const space = asSpace(spc);
-        return space;
-    };
-    const createSpace = (space, organization) => {
-        const seedSpaceId = space.variant === 'course' ? space.seedSpace?.id : undefined;
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces`,
-            method: 'POST',
-            body: {
-                name: space.name,
-                description: space.description,
-                variant: space.variant,
-                public: space.public,
-                spaceHandle: space.handle,
-                organizationId: organization?.id,
-                seedSpaceId,
-            },
-        }).then(resp => {
-            const spc = resp.space;
-            if (spc) {
-                const space = toSpace(spc);
-                if (organization) {
-                    let os = SPACES_BY_ID_BY_ORGANISATION_ID.get(organization.id);
-                    if (!os) {
-                        os = new Map();
-                        SPACES_BY_ID_BY_ORGANISATION_ID.set(organization.id, os);
-                    }
-                    os.set(space.id, space);
-                }
-                else {
-                    SPACES_FOR_USER_BY_HANDLE.set(space.handle, space);
-                    SPACES_FOR_USER_BY_ID.set(space.id, space);
-                }
-            }
-            return resp;
-        });
-    };
-    const getOrganizationSpace = (organizationId, spaceId) => {
-        const organizationSpaces = SPACES_BY_ID_BY_ORGANISATION_ID.get(organizationId);
-        return organizationSpaces ? organizationSpaces.get(spaceId) : undefined;
-    };
-    const getOrganizationSpaceByHandle = (organizationHandle, spaceHandle) => {
-        const organizationSpaces = SPACES_BY_HANDLE_BY_ORGANISATION_HANDLE.get(organizationHandle);
-        return organizationSpaces ? organizationSpaces.get(spaceHandle) : undefined;
-    };
-    const refreshOrganizationSpace = (organizationId, spaceId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/organizations/${organizationId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const spc = resp.space;
-                if (spc) {
-                    const space = toSpace(spc);
-                    let os = SPACES_BY_ID_BY_ORGANISATION_ID.get(organizationId);
-                    if (!os) {
-                        os = new Map();
-                        SPACES_BY_ID_BY_ORGANISATION_ID.set(organizationId, os);
-                    }
-                    os.set(space.id, space);
+    /**
+     * Get user surveys
+     */
+    const useUserSurveys = (userId, options) => {
+        return useQuery({
+            queryKey: ['users', userId, 'surveys'],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/surveys/users/${userId}`,
+                    method: 'GET',
+                });
+                if (!resp.success) {
+                    throw new Error(resp.message || 'Failed to fetch surveys');
                 }
-            }
-            return resp;
+                return {
+                    surveys: resp.surveys || [],
+                    surveysMap: resp.surveysMap,
+                };
+            },
+            enabled: !!userId,
+            ...options,
         });
     };
-    const exportSpace = (spaceId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/export`,
-            method: 'GET',
+    // ============================================================================
+    // [BATCH 9] Join & Registration
+    // ============================================================================
+    /**
+     * Request to join platform (standard registration)
+     */
+    const useRequestJoin = () => {
+        return useMutation({
+            mutationFn: async ({ handle, email, firstName, lastName, password, passwordConfirm, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/join/request`,
+                    method: 'POST',
+                    body: {
+                        handle,
+                        email,
+                        firstName,
+                        lastName,
+                        password,
+                        passwordConfirm,
+                    },
+                });
+            },
         });
     };
-    const updateOrganizationSpace = (organization, space) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/organizations/${organization.id}`,
-            method: 'PUT',
-            body: {
-                name: space.name,
-                description: space.description,
+    /**
+     * Request to join with token (token-based registration)
+     */
+    const useRequestJoinToken = () => {
+        return useMutation({
+            mutationFn: async ({ handle, email, firstName, lastName, password, passwordConfirm, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/join/request/token`,
+                    method: 'POST',
+                    body: {
+                        handle,
+                        email,
+                        firstName,
+                        lastName,
+                        password,
+                        passwordConfirm,
+                    },
+                });
             },
-        }).then(resp => {
-            if (resp.success) {
-                const spc = getOrganizationSpace(organization.id, space.id);
-                if (spc) {
-                    spc.name = space.name;
-                    spc.description = space.description;
-                }
-            }
-            return resp;
         });
     };
-    const getOrganizationSpaces = (organizationId) => {
-        const spaces = SPACES_BY_ID_BY_ORGANISATION_ID.get(organizationId);
-        if (spaces) {
-            return Array.from(spaces.values());
-        }
-        return [];
-    };
-    const refreshOrganizationSpaces = (organizationId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/organizations/${organizationId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.spaces.forEach(org => {
-                    const space = toSpace(org);
-                    let organizationSpaces = SPACES_BY_ID_BY_ORGANISATION_ID.get(organizationId);
-                    if (!organizationSpaces) {
-                        organizationSpaces = new Map();
-                        SPACES_BY_ID_BY_ORGANISATION_ID.set(organizationId, organizationSpaces);
-                    }
-                    organizationSpaces.set(space.id, space);
+    /**
+     * Join platform with invite token
+     */
+    const useJoinWithInvite = () => {
+        return useMutation({
+            mutationFn: async ({ formValues, token, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/join/invites/token`,
+                    method: 'POST',
+                    body: { ...formValues, token },
                 });
-            }
-            return resp;
+            },
         });
     };
-    const getUserSpaces = () => Array.from(SPACES_FOR_USER_BY_ID.values());
-    const refreshUserSpaces = () => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/users/me`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.spaces.forEach(spc => {
-                    const space = toSpace(spc);
-                    SPACES_FOR_USER_BY_HANDLE.set(space.handle, space);
-                    SPACES_FOR_USER_BY_ID.set(space.id, space);
+    /**
+     * Confirm join with token
+     */
+    const useConfirmJoinWithToken = () => {
+        return useMutation({
+            mutationFn: async ({ userHandle, token, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/join/users/${userHandle}/tokens/${token}`,
+                    method: 'GET',
                 });
-            }
-            return resp;
-        });
-    };
-    const getUserSpace = (userId) => SPACES_FOR_USER_BY_ID.get(userId);
-    const getUserSpaceByHandle = (userHandle) => SPACES_FOR_USER_BY_HANDLE.get(userHandle);
-    const refreshUserSpace = (userId, spaceId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/users/${userId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const spc = resp.space;
-                if (spc) {
-                    const space = toSpace(spc);
-                    SPACES_FOR_USER_BY_HANDLE.set(space.handle, space);
-                    SPACES_FOR_USER_BY_ID.set(spaceId, space);
-                }
-            }
-            return resp;
+            },
         });
     };
-    const updateSpace = (space) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/users/${user?.id}`,
-            method: 'PUT',
-            body: {
-                name: space.name,
-                description: space.description,
+    // ============================================================================
+    // [BATCH 9] Password Recovery
+    // ============================================================================
+    /**
+     * Create token for password change
+     */
+    const useCreateTokenForPasswordChange = () => {
+        return useMutation({
+            mutationFn: async ({ handle, password, passwordConfirm, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/password/token`,
+                    method: 'POST',
+                    body: { handle, password, passwordConfirm },
+                });
             },
-        }).then(resp => {
-            if (resp.success) {
-                const spc = getUserSpace(space.id);
-                if (spc) {
-                    spc.name = space.name;
-                    spc.description = space.description;
-                }
-            }
-            return resp;
-        });
-    };
-    const addMemberToOrganizationSpace = (organizationId, spaceId, accountId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/organizations/${organizationId}/members/${accountId}`,
-            method: 'POST',
-        });
-    };
-    const removeMemberFromOrganizationSpace = (organizationId, spaceId, accountId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/organizations/${organizationId}/members/${accountId}`,
-            method: 'DELETE',
-        }).then(resp => {
-            //      if (resp.success) {
-            //        OR.delete(accountHandle);
-            //      }
-            return resp;
-        });
-    };
-    const makeSpacePublic = (spaceId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/public`,
-            method: 'PUT',
-        });
-    };
-    const makeSpacePrivate = (spaceId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/private`,
-            method: 'PUT',
-        });
-    };
-    // Courses -------------------------------------------------------------------
-    const toStudentItem = (raw_student_item, itemId) => {
-        const studentItem = {
-            id: raw_student_item.uid,
-            type: 'student_item',
-            student: user,
-            points: raw_student_item.points_i ?? 0,
-            completed: raw_student_item.completed_b,
-            itemId,
-            itemType: raw_student_item.item_type_s,
-            pass: raw_student_item.pass_b,
-            codeStudent: raw_student_item.code_student_t,
-            invalid: raw_student_item.invalid_b,
-            invalidReason: raw_student_item.invalid_reason_t,
-            nbgrades: raw_student_item.nbgrades,
-            nbgradesTotalPoints: raw_student_item.nbgrades_total_points_f,
-            nbgradesTotalScore: raw_student_item.nbgrades_total_score_f,
-        };
-        return studentItem;
-    };
-    const toStudent = (raw_student, courseId) => {
-        let student = undefined;
-        if (raw_student) {
-            const user = toUser(raw_student);
-            if (user) {
-                let studentItems;
-                if (raw_student.student_items) {
-                    studentItems = new Map();
-                    raw_student.student_items.forEach(raw_student_item => {
-                        const itemId = raw_student_item.item_uid;
-                        const studentItem = toStudentItem(raw_student_item, itemId);
-                        studentItems?.set(itemId, studentItem);
-                    });
-                }
-                student = {
-                    ...user,
-                    studentItems,
-                };
-                STUDENTS_BY_ID.set(courseId + '-' + student.id, student);
-            }
-        }
-        return student;
-    };
-    const toCourse = (raw_course, cache) => {
-        const owner = newUserMock();
-        USERS_BY_ID.set(owner.id, owner);
-        let instructor = undefined;
-        if (raw_course.members) {
-            let raw_instructor = raw_course.members;
-            if (Array.isArray(raw_instructor)) {
-                raw_instructor = raw_instructor[0];
-            }
-            instructor = {
-                id: raw_instructor.uid,
-                handle: raw_instructor.handle_s,
-                email: raw_instructor.email_s,
-                firstName: raw_instructor.first_name_t,
-                lastName: raw_instructor.last_name_t,
-                initials: namesAsInitials(raw_instructor.to_first_name_t, raw_instructor.to_last_name_t),
-                displayName: asDisplayName(raw_instructor.first_name_t, raw_instructor.last_name_t),
-                roles: [],
-                iamProviders: [],
-                setRoles: (roles) => { },
-                unsubscribedFromOutbounds: false,
-                onboarding: BOOTSTRAP_USER_ONBOARDING,
-                linkedContactId: undefined,
-                events: [],
-                settings: {},
-            };
-            USERS_BY_ID.set(instructor.id, instructor);
-        }
-        let students = undefined;
-        if (raw_course.students) {
-            students = new Map();
-            raw_course.students.forEach(raw_stud => {
-                const student = toStudent(raw_stud, raw_course.uid);
-                if (student) {
-                    students.set(student.id, student);
-                }
-            });
-        }
-        let itemIds = new Array();
-        let raw_item_uids = raw_course.item_uids_s;
-        if (raw_item_uids && raw_item_uids !== '()') {
-            raw_item_uids = raw_item_uids.replace('(', '').replace(')', '');
-            itemIds = raw_item_uids.split(' ');
-        }
-        const items = new Array();
-        if (raw_course.items) {
-            raw_course.items.forEach(item => {
-                const i = toItem(item);
-                items.push(i);
-            });
-        }
-        const course = {
-            id: raw_course.uid,
-            handle: raw_course.handle_s,
-            type: 'space',
-            variant: 'course',
-            name: raw_course.name_t,
-            description: raw_course.description_t,
-            creationDate: new Date(raw_course.creation_ts_dt),
-            public: raw_course.public_b ?? false,
-            items,
-            itemIds,
-            instructor,
-            students,
-            owner,
-        };
-        cache.set(course.id, course);
-        return course;
-    };
-    const getCourse = (courseId) => COURSES_BY_ID.get(courseId);
-    const updateCourse = (courseId, name, description) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}`,
-            method: 'PUT',
-            body: {
-                name,
-                description,
-            },
-        });
-    };
-    const refreshCourse = (courseId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const raw_course = resp.course;
-                if (raw_course) {
-                    toCourse(raw_course, COURSES_BY_ID);
-                }
-            }
-            return resp;
         });
     };
-    const enrollStudentToCourse = (courseId, studentId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}/enrollments/students/${studentId}`,
-            method: 'POST',
+    /**
+     * Confirm password change with token
+     */
+    const useConfirmPasswordWithToken = () => {
+        return useMutation({
+            mutationFn: async ({ userHandle, token, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/password/confirm/users/${userHandle}/tokens/${token}`,
+                    method: 'PUT',
+                });
+            },
         });
     };
-    const removeStudentFromCourse = (courseId, studentId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}/enrollments/students/${studentId}`,
-            method: 'DELETE',
-        }).then(resp => {
-            if (resp.success) {
-                STUDENTS_BY_ID.delete(courseId);
-            }
-            return resp;
+    // ============================================================================
+    // [BATCH 9] OAuth2 Authentication
+    // ============================================================================
+    /**
+     * Get OAuth2 authorization URL
+     */
+    const useOAuth2AuthorizationURL = () => {
+        return useMutation({
+            mutationFn: async (queryArgs) => {
+                const queryString = Object.entries(queryArgs)
+                    .map(([key, value]) => `${key}=${encodeURIComponent(value)}`)
+                    .join('&');
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/oauth2/authz/url?${queryString}`,
+                    notifyOnError: false,
+                });
+                return resp.autorization_url;
+            },
         });
     };
-    const getStudent = (courseId, studentId) => STUDENTS_BY_ID.get(courseId + '-' + studentId);
-    const refreshStudent = (courseId, studentHandle) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}/enrollments/students/${studentHandle}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                toStudent(resp.student, courseId);
-            }
-            return resp;
+    /**
+     * Get OAuth2 authorization link URL
+     */
+    const useOAuth2AuthorizationLinkURL = () => {
+        return useMutation({
+            mutationFn: async (queryArgs) => {
+                const queryString = Object.entries(queryArgs)
+                    .map(([key, value]) => `${key}=${encodeURIComponent(value)}`)
+                    .join('&');
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/oauth2/authz/url/link?${queryString}`,
+                });
+                return resp.autorization_url;
+            },
         });
     };
-    const getPublicCourses = () => Array.from(PUBLIC_COURSES_BY_ID.values());
-    const refreshPublicCourses = () => {
-        return requestDatalayer({
-            url: `${configuration.libraryRunUrl}/api/library/v1/courses/public`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.courses.forEach(course => {
-                    toCourse(course, PUBLIC_COURSES_BY_ID);
+    // ============================================================================
+    // [BATCH 9] Contact Enrichment & Tagging
+    // ============================================================================
+    /**
+     * Assign tag to contact
+     */
+    const useAssignTagToContact = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ contactId, tagName, }) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}/tags/${tagName}`,
+                    method: 'POST',
                 });
-            }
-            return resp;
+            },
+            onSuccess: (_, { contactId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['contacts', contactId],
+                });
+                queryClient.invalidateQueries({ queryKey: ['contacts'] });
+            },
         });
     };
-    const getInstructorCourses = () => Array.from(COURSES_INSTRUCTORS_BY_ID.values());
-    const refreshInstructorCourses = () => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/instructors/${user?.id}/courses`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.courses.forEach(course => {
-                    toCourse(course, COURSES_INSTRUCTORS_BY_ID);
+    /**
+     * Remove tag from contact
+     */
+    const useUnassignTagFromContact = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ contactId, tagName, }) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}/tags/${tagName}`,
+                    method: 'DELETE',
                 });
-            }
-            return resp;
+            },
+            onSuccess: (_, { contactId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['contacts', contactId],
+                });
+                queryClient.invalidateQueries({ queryKey: ['contacts'] });
+            },
         });
     };
-    const getCoursesEnrollments = () => Array.from(COURSES_ENROLLMENTS_BY_ID.values());
-    const refreshCoursesEnrollments = () => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/enrollments/me`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.enrollments.forEach(enrollment => {
-                    toCourse(enrollment, COURSES_ENROLLMENTS_BY_ID);
+    /**
+     * Send invite to contact
+     */
+    const useSendInviteToContact = () => {
+        return useMutation({
+            mutationFn: async ({ contactId, message, }) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/contacts/invites`,
+                    method: 'POST',
+                    body: { contactId, message },
                 });
-            }
-            return resp;
+            },
         });
     };
-    const confirmCourseItemCompletion = (courseId, itemType, itemId, completed) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${courseId}/types/${itemType}/items/${itemId}/complete`,
-            method: 'PUT',
-            body: {
-                completed,
+    /**
+     * Enrich contact with email data
+     */
+    const useEnrichContactEmail = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ contactId, useDomain, }) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}/enrich/email?useDomain=${useDomain}`,
+                    method: 'GET',
+                });
+            },
+            onSuccess: (_, { contactId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['contacts', contactId],
+                });
             },
         });
     };
-    const setCourseItems = (courseId, itemIds) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}/items`,
-            method: 'PUT',
-            body: {
-                itemIds,
+    /**
+     * Enrich contact with LinkedIn data
+     */
+    const useEnrichContactLinkedin = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (contactId) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}/enrich/linkedin`,
+                    method: 'GET',
+                });
+            },
+            onSuccess: (_, contactId) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['contacts', contactId],
+                });
             },
         });
     };
-    // Surveys ---------------------------------------------------------------------
-    const getUserSurveys = (userId) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/surveys/users/${userId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success && resp.surveys) {
-                const surveyArray = resp.surveys.map(survey => asSurvey(survey));
-                const surveysMap = new Map();
-                surveyArray.forEach(survey => surveysMap.set(survey.name, survey));
-                resp.surveys = surveyArray;
-                resp.surveysMap = surveysMap;
-            }
-            return resp;
+    /**
+     * Send LinkedIn connection request to contact
+     */
+    const useSendLinkedinConnectionRequest = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ contactId, message, }) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}/connect/linkedin`,
+                    method: 'POST',
+                    body: { message },
+                });
+            },
+            onSuccess: (_, { contactId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['contacts', contactId],
+                });
+            },
         });
     };
-    // Inbounds ---------------------------------------------------------------------
-    const toInbound = (u) => {
-        if (u) {
-            const inbound = asInbound(u);
-            INBOUNDS_BY_ID.set(inbound.id, inbound);
-            INBOUNDS_BY_HANDLE.set(inbound.handle, inbound);
-            return inbound;
-        }
+    // ============================================================================
+    // [BATCH 9] Contact-User Linking
+    // ============================================================================
+    /**
+     * Link user with contact
+     */
+    const useLinkUserWithContact = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ userId, contactId, }) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/users/${userId}/contacts/${contactId}/link`,
+                    method: 'POST',
+                });
+            },
+            onSuccess: (_, { userId, contactId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['users', userId],
+                });
+                queryClient.invalidateQueries({
+                    queryKey: ['contacts', contactId],
+                });
+            },
+        });
     };
-    const getInbound = (id) => INBOUNDS_BY_ID.get(id);
-    const getInboundByHandle = (handle) => INBOUNDS_BY_HANDLE.get(handle);
-    const refreshInbound = (userId) => {
-        return requestDatalayer({
-            url: `${configuration.inboundsRunUrl}/api/inbounds/v1/inbounds/${userId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                toInbound(resp.user);
-            }
-            return resp;
+    /**
+     * Unlink user from contact
+     */
+    const useUnlinkUserFromContact = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ userId, contactId, }) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/users/${userId}/contacts/${contactId}/link`,
+                    method: 'DELETE',
+                });
+            },
+            onSuccess: (_, { userId, contactId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['users', userId],
+                });
+                queryClient.invalidateQueries({
+                    queryKey: ['contacts', contactId],
+                });
+            },
         });
     };
-    const getInbounds = () => {
-        return requestDatalayer({
-            url: `${configuration.inboundsRunUrl}/api/inbounds/v1/inbounds`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const inbounds = resp.inbounds.map(user => toInbound(user));
-                resp.inbounds = inbounds;
-            }
-            return resp;
+    // ============================================================================
+    // [BATCH 9] Credits Quota & Usage
+    // ============================================================================
+    /**
+     * Update user credits quota
+     */
+    const useUpdateUserCreditsQuota = () => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ userId, quota, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/usage/quota`,
+                    method: 'PUT',
+                    body: {
+                        user_uid: userId,
+                        quota,
+                        reset: '0',
+                    },
+                });
+            },
+            onSuccess: (_, { userId }) => {
+                queryClient.invalidateQueries({
+                    queryKey: ['users', userId, 'credits'],
+                });
+            },
         });
     };
-    // Outbounds ---------------------------------------------------------------------
-    const toOutbound = (u) => {
-        if (u) {
-            const user = asOutbound(u);
-            OUTBOUNDS_BY_ID.set(user.id, user);
-            return user;
-        }
+    /**
+     * Get current user's usage data
+     */
+    const useUsages = (options) => {
+        return useQuery({
+            queryKey: ['usage', 'me'],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/usage/user`,
+                    method: 'GET',
+                });
+                return resp.usages || [];
+            },
+            ...options,
+        });
     };
-    const getOutbound = (id) => OUTBOUNDS_BY_ID.get(id);
-    const refreshOutbound = (outboundId) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/${outboundId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const outbound = toOutbound(resp.outbound);
-                resp.outbound = outbound;
-            }
-            return resp;
+    /**
+     * Get usage data for specific user
+     */
+    const useUsagesForUser = (userId, options) => {
+        return useQuery({
+            queryKey: ['usage', 'user', userId],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/usage/users/${userId}`,
+                    method: 'GET',
+                });
+                return resp.usages || [];
+            },
+            enabled: !!userId,
+            ...options,
         });
     };
-    const getOutbounds = () => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const outbounds = resp.outbounds.map(outbound => toOutbound(outbound));
-                resp.outbounds = outbounds;
-            }
-            return resp;
+    /**
+     * Get platform-wide usage statistics
+     */
+    const usePlatformUsages = (options) => {
+        return useQuery({
+            queryKey: ['usage', 'platform'],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/usage/platform`,
+                    method: 'GET',
+                });
+                return resp.usages || [];
+            },
+            ...options,
         });
     };
-    const draftBulkEmailsOutbounds = (params) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/emails/bulk/draft`,
-            method: 'POST',
-            body: params,
+    // ============================================================================
+    // [BATCH 10] Search Operations
+    // ============================================================================
+    /**
+     * Search public items (notebooks, documents, etc.)
+     */
+    const useSearchPublicItems = () => {
+        return useMutation({
+            mutationFn: async ({ q, types = ['notebook', 'document', 'lesson'], max = 100, }) => {
+                const queryString = Object.entries({
+                    q: q || '*',
+                    types: types.join(' '),
+                    max: max.toString(),
+                    public: 'true',
+                })
+                    .map(([key, value]) => `${key}=${encodeURIComponent(value)}`)
+                    .join('&');
+                const resp = await requestDatalayer({
+                    url: `${configuration.libraryRunUrl}/api/library/v1/search?${queryString}`,
+                    method: 'GET',
+                });
+                if (!resp.success) {
+                    throw new Error(resp.message || 'Failed to search public items');
+                }
+                return resp.items || [];
+            },
         });
     };
-    const tryBulkEmailsOutbounds = (outboundId) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/${outboundId}/try`,
-            method: 'POST',
-            body: {},
+    // ============================================================================
+    // [BATCH 10] Social Media Integrations
+    // ============================================================================
+    /**
+     * Get GitHub profile from access token
+     */
+    const useGetGitHubProfile = () => {
+        return useMutation({
+            mutationFn: async (accessToken) => {
+                const response = await fetch('https://api.github.com/user', {
+                    method: 'GET',
+                    headers: {
+                        Accept: 'application/vnd.github+json',
+                        Authorization: `Bearer ${accessToken}`,
+                        'X-GitHub-Api-Version': '2022-11-28',
+                    },
+                });
+                return response.json();
+            },
         });
     };
-    const launchBulkEmailsOutbounds = (outboundId) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/${outboundId}/launch`,
-            method: 'POST',
-            body: {},
+    /**
+     * Get LinkedIn profile via proxy
+     */
+    const useGetLinkedinProfile = () => {
+        return useMutation({
+            mutationFn: async (accessToken) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/proxy/request`,
+                    method: 'POST',
+                    body: {
+                        request_method: 'GET',
+                        request_url: 'https://api.linkedin.com/v2/me',
+                        request_token: accessToken,
+                    },
+                });
+            },
         });
     };
-    const sendOutboundEmailToUser = (userId, recipient, subject, content) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/email`,
-            method: 'POST',
-            body: {
-                userId,
-                recipient,
-                subject,
-                content,
+    /**
+     * Post LinkedIn share
+     */
+    const usePostLinkedinShare = () => {
+        return useMutation({
+            mutationFn: async ({ linkedinUserUrn, postText, accessToken, }) => {
+                const postShareRequest = {
+                    author: linkedinUserUrn,
+                    lifecycleState: 'PUBLISHED',
+                    specificContent: {
+                        'com.linkedin.ugc.ShareContent': {
+                            shareCommentary: { text: postText },
+                            shareMediaCategory: 'NONE',
+                        },
+                    },
+                    visibility: {
+                        'com.linkedin.ugc.MemberNetworkVisibility': 'PUBLIC',
+                    },
+                };
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/proxy/request`,
+                    method: 'POST',
+                    body: {
+                        request_method: 'POST',
+                        request_url: 'https://api.linkedin.com/v2/ugcPosts',
+                        request_token: accessToken,
+                        request_body: postShareRequest,
+                    },
+                });
             },
         });
     };
-    const enableUserMFA = () => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/mfa`,
-            method: 'PUT',
-        });
-    };
-    const disableUserMFA = () => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/mfa`,
-            method: 'DELETE',
-        });
-    };
-    const validateUserMFACode = (userUid, code) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/mfa`,
-            method: 'POST',
-            body: {
-                userUid,
-                code,
+    /**
+     * Post LinkedIn share with image upload
+     */
+    const usePostLinkedinShareWithUpload = () => {
+        return useMutation({
+            mutationFn: async ({ linkedinUserUrn, postText, uploadObject, accessToken, }) => {
+                // Step 1: Register upload
+                const registerUploadRequest = {
+                    registerUploadRequest: {
+                        recipes: ['urn:li:digitalmediaRecipe:feedshare-image'],
+                        owner: linkedinUserUrn,
+                        serviceRelationships: [
+                            {
+                                relationshipType: 'OWNER',
+                                identifier: 'urn:li:userGeneratedContent',
+                            },
+                        ],
+                    },
+                };
+                const registerResp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/proxy/request`,
+                    method: 'POST',
+                    body: {
+                        request_method: 'POST',
+                        request_url: 'https://api.linkedin.com/v2/assets?action=registerUpload',
+                        request_token: accessToken,
+                        request_body: registerUploadRequest,
+                    },
+                });
+                const asset = registerResp.response.value.asset;
+                const uploadUrl = registerResp.response.value.uploadMechanism['com.linkedin.digitalmedia.uploading.MediaUploadHttpRequest'].uploadUrl;
+                // Step 2: Upload image
+                await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/proxy/request`,
+                    method: 'POST',
+                    body: {
+                        request_method: 'PUT',
+                        request_url: uploadUrl,
+                        request_token: accessToken,
+                        request_body: {
+                            uploadURL: uploadUrl,
+                            content: uploadObject,
+                            userURN: linkedinUserUrn,
+                        },
+                    },
+                });
+                // Step 3: Create share with media
+                const shareRequest = {
+                    author: linkedinUserUrn,
+                    lifecycleState: 'PUBLISHED',
+                    specificContent: {
+                        'com.linkedin.ugc.ShareContent': {
+                            shareCommentary: { text: postText },
+                            shareMediaCategory: 'IMAGE',
+                            media: [
+                                {
+                                    status: 'READY',
+                                    description: { text: 'Datalayer Notebook' },
+                                    media: asset,
+                                    title: { text: 'Datalayer Notebook' },
+                                },
+                            ],
+                        },
+                    },
+                    visibility: {
+                        'com.linkedin.ugc.MemberNetworkVisibility': 'PUBLIC',
+                    },
+                };
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/proxy/request`,
+                    method: 'POST',
+                    body: {
+                        request_method: 'POST',
+                        request_url: 'https://api.linkedin.com/v2/ugcPosts',
+                        request_token: accessToken,
+                        request_body: shareRequest,
+                    },
+                });
             },
         });
     };
-    const subscribeUserToOutbounds = (userId) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/outbounds/users/${userId}`,
-            method: 'PUT',
-        });
-    };
-    const unsubscribeUserFromOutbounds = (userId) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/outbounds/users/${userId}`,
-            method: 'DELETE',
-        });
-    };
-    const unsubscribeContactFromOutbounds = (contactId) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/unsubscribe/${contactId}`,
-            method: 'GET',
+    // ============================================================================
+    // [BATCH 10] Proxy Operations
+    // ============================================================================
+    /**
+     * Proxy GET request
+     */
+    const useProxyGET = () => {
+        return useMutation({
+            mutationFn: async ({ url, token }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/proxy/request`,
+                    method: 'POST',
+                    body: {
+                        request_method: 'GET',
+                        request_url: url,
+                        request_token: token,
+                    },
+                });
+            },
         });
     };
-    const unsubscribeInviteeFromOutbounds = (token) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/unsubscribe/${token}`,
-            method: 'GET',
+    /**
+     * Proxy POST request
+     */
+    const useProxyPOST = () => {
+        return useMutation({
+            mutationFn: async ({ url, body, token, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/proxy/request`,
+                    method: 'POST',
+                    body: {
+                        request_method: 'POST',
+                        request_url: url,
+                        request_token: token,
+                        request_body: body,
+                    },
+                });
+            },
         });
     };
-    const deleteOutbound = (outboundId) => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/${outboundId}`,
-            method: 'DELETE',
+    /**
+     * Proxy PUT request
+     */
+    const useProxyPUT = () => {
+        return useMutation({
+            mutationFn: async ({ url, body, token, }) => {
+                return requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/proxy/request`,
+                    method: 'POST',
+                    body: {
+                        request_method: 'PUT',
+                        request_url: url,
+                        request_token: token,
+                        request_body: body,
+                    },
+                });
+            },
         });
     };
-    // Items --------------------------------------------------------------
-    const toItem = (item) => {
-        if (!item.type_s) {
-            console.error('No type_s found on item', item);
-            return {};
-        }
-        switch (item.type_s) {
-            case 'assignment':
-                return toAssignment(item);
-            case 'cell':
-                return toCell(item);
-            case 'dataset':
-                return toDataset(item);
-            case 'document':
-                return toDocument(item);
-            case 'exercise':
-                return toExercise(item);
-            case 'lesson':
-                return toLesson(item);
-            case 'notebook':
-                return toNotebook(item);
-            case 'page':
-                return toPage(item);
-            default:
-                return {};
-        }
-    };
-    const clearCachedPublicItems = () => PUBLIC_ITEMS_BY_ID.clear();
-    const getPublicItems = () => Array.from(PUBLIC_ITEMS_BY_ID.values());
-    const refreshPublicItems = () => {
-        return requestDatalayer({
-            url: `${configuration.libraryRunUrl}/api/library/v1/items/public`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.items.forEach(i => {
-                    const item = toItem(i);
-                    PUBLIC_ITEMS_BY_ID.set(item.id, item);
+    // ============================================================================
+    // [BATCH 10] Waiting List & Growth
+    // ============================================================================
+    /**
+     * Register to waiting list
+     */
+    const useRegisterToWaitingList = () => {
+        return useMutation({
+            mutationFn: async ({ firstName, lastName, email, affiliation, }) => {
+                return requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/waitinglist/register`,
+                    method: 'POST',
+                    body: {
+                        firstName,
+                        lastName,
+                        email,
+                        affiliation: affiliation || '',
+                    },
                 });
-            }
-            return resp;
-        });
-    };
-    const getSpaceItems = () => Array.from(SPACE_ITEMS_CACHE.values());
-    const refreshSpaceItems = (spaceId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                if (resp.items) {
-                    asArray(resp.items).forEach(itm => {
-                        const item = toItem(itm);
-                        SPACE_ITEMS_CACHE.set(item.id, item);
-                    });
-                }
-            }
-            return resp;
-        });
-    };
-    const makeItemPublic = (id) => {
-        return requestDatalayer({
-            url: `${configuration.libraryRunUrl}/api/library/v1/items/${id}/public`,
-            method: 'PUT',
-        });
-    };
-    const makeItemPrivate = (id) => {
-        return requestDatalayer({
-            url: `${configuration.libraryRunUrl}/api/library/v1/items/${id}/private`,
-            method: 'PUT',
-        });
-    };
-    const deleteItem = (itemId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${itemId}`,
-            method: 'DELETE',
-        }).then(resp => {
-            if (resp.success) {
-                SPACE_ASSIGNMENTS_BY_ID.delete(itemId);
-                SPACE_CELLS_BY_ID.delete(itemId);
-                SPACE_DATASETS_BY_ID.delete(itemId);
-                SPACE_DOCUMENTS_BY_ID.delete(itemId);
-                SPACE_ENVIRONMENTS_BY_ID.delete(itemId);
-                SPACE_EXERCISES_BY_ID.delete(itemId);
-                SPACE_ITEMS_CACHE.delete(itemId);
-                SPACE_LESSONS_BY_ID.delete(itemId);
-                SPACE_NOTEBOOKS_BY_ID.delete(itemId);
-            }
-            return resp;
+            },
         });
     };
-    // Search ------------------------------------------------------------------
-    const searchPublicItems = (opts = DEFAULT_SEARCH_OPTS) => {
-        const { q, types, max } = opts;
-        const queryArgs = {
-            q,
-            types: `${types.join(' ')}`,
-            max: max.toFixed(0).toString(),
-            public: 'true',
-        };
-        return requestDatalayer({
-            url: `${configuration.libraryRunUrl}/api/library/v1/search${URLExt.objectToQueryString(queryArgs)}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const items = new Array();
-                resp.items.forEach(i => {
-                    const item = toItem(i);
-                    items.push(item);
-                });
-                resp.items = items;
-            }
-            return resp;
+    /**
+     * Get growth KPIs
+     */
+    const useGrowthKPI = (options) => {
+        return useQuery({
+            queryKey: ['growth', 'kpi'],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/kpis`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            ...options,
         });
     };
-    // Datasets ------------------------------------------------------------------
-    const toDataset = raw_dataset => {
-        const owner = newUserMock();
-        USERS_BY_ID.set(owner.id, owner);
-        const dataset = {
-            id: raw_dataset.uid,
-            type: 'dataset',
-            name: raw_dataset.name_t,
-            description: raw_dataset.description_t,
-            fileName: raw_dataset.file_name_s,
-            datasetExtension: raw_dataset.dataset_extension_s,
-            contentLength: raw_dataset.content_length_i,
-            contentType: raw_dataset.content_type_s,
-            mimeType: raw_dataset.mimetype_s,
-            path: raw_dataset.s3_path_s,
-            cdnUrl: raw_dataset.cdn_url_s,
-            creationDate: new Date(raw_dataset.creation_ts_dt),
-            public: raw_dataset.public_b ?? false,
-            lastPublicationDate: raw_dataset.creation_ts_dt
-                ? new Date(raw_dataset.creation_ts_dt)
-                : undefined,
-            owner,
-            space: {
-                handle: raw_dataset.handle_s,
+    // ============================================================================
+    // BATCH 11: Refresh Operations & Additional Methods
+    // ============================================================================
+    /**
+     * Refresh a specific user space
+     * @param userId - User ID
+     * @param spaceId - Space ID
+     * @param options - Mutation options
+     */
+    const useRefreshUserSpace = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ userId, spaceId, }) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/users/${userId}`,
+                    method: 'GET',
+                });
+                return resp;
             },
-            organization: {
-                handle: raw_dataset.handle_s,
+            onSuccess: (data, variables) => {
+                // Invalidate user spaces queries
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.spaces.userSpaces(),
+                });
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.spaces.detail(variables.spaceId),
+                });
             },
-        };
-        SPACE_DATASETS_BY_ID.set(dataset.id, dataset);
-        return dataset;
-    };
-    const getDataset = id => SPACE_DATASETS_BY_ID.get(id);
-    const refreshDataset = (id) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${id}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const d = resp.item;
-                if (d) {
-                    toDataset(d);
-                }
-            }
-            return resp;
+            ...options,
         });
     };
-    const getSpaceDatasets = () => Array.from(SPACE_DATASETS_BY_ID.values());
-    const refreshSpaceDatasets = (space, organization) => {
-        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/dataset`;
-        return requestDatalayer({
-            url,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.items.forEach(d => {
-                    toDataset(d);
+    /**
+     * Refresh a specific course
+     * @param options - Mutation options
+     */
+    const useRefreshCourse = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (courseId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: (data, courseId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.courses.detail(courseId),
                 });
-            }
-            return resp;
-        });
-    };
-    const updateDataset = (id, name, description) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/datasets/${id}`,
-            method: 'PUT',
-            body: {
-                name,
-                description,
             },
+            ...options,
         });
     };
-    // Cells ------------------------------------------------------------------
-    const toCell = cl => {
-        const owner = newUserMock();
-        USERS_BY_ID.set(owner.id, owner);
-        const cell = {
-            id: cl.uid,
-            type: 'cell',
-            name: cl.name_t,
-            description: cl.description_t,
-            source: cl.source_t,
-            creationDate: new Date(cl.creation_ts_dt),
-            public: cl.public_b ?? false,
-            lastPublicationDate: cl.last_publication_ts_dt
-                ? new Date(cl.last_publication_ts_dt)
-                : undefined,
-            outputshotUrl: cl.outputshot_url_s || '',
-            outputshotData: OUTPUTSHOT_PLACEHOLDER_DEFAULT_SVG,
-            owner,
-            space: {
-                handle: cl.handle_s,
+    /**
+     * Refresh public courses list
+     * @param options - Mutation options
+     */
+    const useRefreshPublicCourses = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.libraryRunUrl}/api/library/v1/courses/public`,
+                    method: 'GET',
+                });
+                return resp;
             },
-            organization: {
-                handle: cl.handle_s,
+            onSuccess: () => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.courses.public(),
+                });
             },
-        };
-        SPACE_CELLS_BY_ID.set(cell.id, cell);
-        return cell;
-    };
-    const getCell = (id) => SPACE_CELLS_BY_ID.get(id);
-    const refreshCell = (id) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${id}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const cell = resp.item;
-                if (cell) {
-                    toCell(cell);
-                }
-            }
-            return resp;
+            ...options,
         });
     };
-    const getSpaceCells = () => Array.from(SPACE_CELLS_BY_ID.values());
-    const refreshSpaceCells = (space, organization) => {
-        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/cell`;
-        return requestDatalayer({
-            url,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.items.forEach(cell => {
-                    toCell(cell);
+    /**
+     * Refresh instructor courses list
+     * @param options - Mutation options
+     */
+    const useRefreshInstructorCourses = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/instructors/${user?.id}/courses`,
+                    method: 'GET',
                 });
-            }
-            return resp;
-        });
-    };
-    const updateCell = (cell) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/cells/${cell.id}`,
-            method: 'PUT',
-            body: cell,
+                return resp;
+            },
+            onSuccess: () => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.courses.instructor(user?.id ?? ''),
+                });
+            },
+            ...options,
         });
     };
-    const cloneCell = (cellId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/cells/${cellId}/clone`,
-            method: 'POST',
-        }).then(resp => {
-            if (resp.success) {
-                toCell(resp.cell);
-            }
-            return resp;
+    /**
+     * Refresh course enrollments
+     * @param options - Mutation options
+     */
+    const useRefreshCoursesEnrollments = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/enrollments/me`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: () => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.courses.enrollments(),
+                });
+            },
+            ...options,
         });
     };
-    // Notebooks ------------------------------------------------------------------
-    const toNotebook = raw_notebook => {
-        const owner = newUserMock();
-        USERS_BY_ID.set(owner.id, owner);
-        const notebook = {
-            id: raw_notebook.uid,
-            type: 'notebook',
-            name: raw_notebook.name_t,
-            description: raw_notebook.description_t,
-            nbformat: raw_notebook.model_s
-                ? JSON.parse(raw_notebook.model_s)
-                : undefined,
-            public: raw_notebook.public_b ?? false,
-            creationDate: new Date(raw_notebook.creation_ts_dt),
-            lastUpdateDate: raw_notebook.last_update_ts_dt
-                ? new Date(raw_notebook.last_update_ts_dt)
-                : undefined,
-            lastPublicationDate: raw_notebook.creation_ts_dt
-                ? new Date(raw_notebook.creation_ts_dt)
-                : undefined,
-            datasets: [],
-            owner,
-            space: {
-                handle: raw_notebook.handle_s,
+    /**
+     * Refresh student data
+     * @param options - Mutation options
+     */
+    const useRefreshStudent = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ courseId, studentHandle, }) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}/enrollments/students/${studentHandle}`,
+                    method: 'GET',
+                });
+                return resp;
             },
-            organization: {
-                handle: raw_notebook.handle_s,
+            onSuccess: (data, variables) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.courses.student(variables.courseId, variables.studentHandle),
+                });
             },
-        };
-        SPACE_NOTEBOOKS_BY_ID.set(notebook.id, notebook);
-        return notebook;
-    };
-    const getNotebook = notebookId => SPACE_NOTEBOOKS_BY_ID.get(notebookId);
-    const refreshNotebook = (notebookId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${notebookId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const notebook = resp.notebook;
-                if (notebook) {
-                    toNotebook(notebook);
-                }
-            }
-            return resp;
+            ...options,
         });
     };
-    const getSpaceNotebooks = () => Array.from(SPACE_NOTEBOOKS_BY_ID.values());
-    const getSpaceNotebook = id => SPACE_NOTEBOOKS_BY_ID.get(id);
-    const refreshSpaceNotebooks = (space, organization) => {
-        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/notebook`;
-        return requestDatalayer({
-            url,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.items.forEach(n => {
-                    toNotebook(n);
+    /**
+     * Refresh a specific notebook
+     * @param options - Mutation options
+     */
+    const useRefreshNotebook = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (notebookId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${notebookId}`,
+                    method: 'GET',
                 });
-            }
-            return resp;
+                return resp;
+            },
+            onSuccess: (data, notebookId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.notebooks.detail(notebookId),
+                });
+            },
+            ...options,
         });
     };
-    const cloneNotebook = (notebookId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${notebookId}/clone`,
-            method: 'POST',
-        }).then(resp => {
-            if (resp.success) {
-                toNotebook(resp.notebook);
-            }
-            return resp;
-        });
-    };
-    const createNotebook = async (spaceId, name, description, notebookType = 'notebook') => {
-        // Create FormData for the upload
-        const formData = new FormData();
-        formData.append('spaceId', spaceId);
-        formData.append('notebookType', notebookType);
-        formData.append('name', name);
-        formData.append('description', description || '');
-        try {
-            const resp = await uploadNotebook(formData);
-            if (resp.success) {
-                if (resp.notebook) {
-                    toNotebook(resp.notebook);
+    /**
+     * Refresh space notebooks
+     * @param options - Mutation options
+     */
+    const useRefreshSpaceNotebooks = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (spaceId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/notebook`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            // eslint-disable-next-line @typescript-eslint/no-explicit-any
+            onSuccess: (data, spaceId) => {
+                // Set the notebooks data directly into cache
+                if (data.success && data.items) {
+                    const notebooks = data.items.map((n) => {
+                        const notebook = toNotebook(n);
+                        queryClient.setQueryData(queryKeys.notebooks.detail(notebook.id), notebook);
+                        return notebook;
+                    });
+                    queryClient.setQueryData(queryKeys.notebooks.bySpace(spaceId), notebooks);
                 }
-            }
-            return resp;
-        }
-        catch (error) {
-            console.error('Failed to create notebook:', error);
-            return { success: false, error };
-        }
-    };
-    const updateNotebook = (id, name, description) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${id}`,
-            method: 'PUT',
-            body: {
-                name,
-                description,
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.notebooks.bySpace(spaceId),
+                });
             },
+            ...options,
         });
     };
-    const updateNotebookModel = (notebookId, nbformat) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${notebookId}/model`,
-            method: 'PUT',
-            body: {
-                nbformat,
+    /**
+     * Refresh a specific document
+     * @param options - Mutation options
+     */
+    const useRefreshDocument = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (documentId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/lexicals/${documentId}`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: (data, documentId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.documents.detail(documentId),
+                });
             },
+            ...options,
         });
     };
-    // Documents ------------------------------------------------------------------
-    const toDocument = doc => {
-        const owner = newUserMock();
-        USERS_BY_ID.set(owner.id, owner);
-        const document = {
-            id: doc.uid,
-            type: 'document',
-            name: doc.name_t,
-            description: doc.description_t,
-            model: doc.model_s ? JSON.parse(doc.model_s) : undefined,
-            public: doc.public_b ?? false,
-            creationDate: new Date(doc.creation_ts_dt),
-            lastUpdateDate: doc.last_update_ts_dt
-                ? new Date(doc.last_update_ts_dt)
-                : undefined,
-            lastPublicationDate: doc.creation_ts_dt
-                ? new Date(doc.creation_ts_dt)
-                : undefined,
-            owner,
-            space: {
-                handle: doc.handle_s,
+    /**
+     * Refresh space documents
+     * @param options - Mutation options
+     */
+    const useRefreshSpaceDocuments = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (spaceId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/document`,
+                    method: 'GET',
+                });
+                return resp;
             },
-            organization: {
-                handle: doc.handle_s,
+            onSuccess: (data, spaceId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.documents.bySpace(spaceId),
+                });
             },
-        };
-        SPACE_DOCUMENTS_BY_ID.set(document.id, document);
-        return document;
-    };
-    const getDocument = id => SPACE_DOCUMENTS_BY_ID.get(id);
-    const refreshDocument = (id) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/lexicals/${id}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const document = resp.document;
-                if (document) {
-                    toDocument(document);
-                }
-            }
-            return resp;
+            ...options,
         });
     };
-    const getSpaceDocuments = () => Array.from(SPACE_DOCUMENTS_BY_ID.values());
-    const getSpaceDocument = id => SPACE_DOCUMENTS_BY_ID.get(id);
-    const refreshSpaceDocuments = (space, organization) => {
-        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/document`;
-        return requestDatalayer({
-            url,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.items.forEach(n => {
-                    toDocument(n);
+    /**
+     * Refresh a specific cell
+     * @param options - Mutation options
+     */
+    const useRefreshCell = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (cellId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${cellId}`,
+                    method: 'GET',
                 });
-            }
-            return resp;
+                return resp;
+            },
+            onSuccess: (data, cellId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.cells.detail(cellId),
+                });
+            },
+            ...options,
         });
     };
-    const cloneDocument = (documentId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/lexicals/${documentId}/clone`,
-            method: 'POST',
-        }).then(resp => {
-            if (resp.success) {
-                toDocument(resp.document);
-            }
-            return resp;
+    /**
+     * Refresh space cells
+     * @param options - Mutation options
+     */
+    const useRefreshSpaceCells = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (spaceId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/cell`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: (data, spaceId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.cells.bySpace(spaceId),
+                });
+            },
+            ...options,
         });
     };
-    const updateDocument = (id, name, description) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/lexicals/${id}`,
-            method: 'PUT',
-            body: {
-                name,
-                description,
+    /**
+     * Refresh a specific dataset
+     * @param options - Mutation options
+     */
+    const useRefreshDataset = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (datasetId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${datasetId}`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: (data, datasetId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.datasets.detail(datasetId),
+                });
             },
+            ...options,
         });
     };
-    const updateDocumentModel = (id, model) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/lexicals/${id}/model`,
-            method: 'PUT',
-            body: {
-                model,
+    /**
+     * Refresh space datasets
+     * @param options - Mutation options
+     */
+    const useRefreshSpaceDatasets = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (spaceId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/dataset`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: (data, spaceId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.datasets.bySpace(spaceId),
+                });
             },
+            ...options,
         });
     };
-    // Environments ------------------------------------------------------------------
-    const toEnvironment = (env, cache) => {
-        const owner = newUserMock();
-        USERS_BY_ID.set(owner.id, owner);
-        const environment = {
-            id: env.uid,
-            type: 'environment',
-            name: env.name_t,
-            description: env.description_t,
-            creationDate: new Date(env.creation_ts_dt),
-            public: env.public_b ?? false,
-            lastPublicationDate: env.creation_ts_dt
-                ? new Date(env.creation_ts_dt)
-                : undefined,
-            owner,
-            space: {
-                handle: env.handle_s,
+    /**
+     * Refresh schools list
+     * @param options - Mutation options
+     */
+    const useRefreshSchools = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.iamRunUrl}/api/iam/v1/organizations/schools`,
+                    method: 'GET',
+                });
+                return resp;
             },
-            organization: {
-                handle: env.handle_s,
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: queryKeys.schools.all() });
             },
-        };
-        cache.set(environment.id, environment);
-        return environment;
-    };
-    const getEnvironment = (id) => SPACE_ENVIRONMENTS_BY_ID.get(id);
-    const refreshEnvironment = (id) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${id}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const env = resp.item;
-                if (env) {
-                    toEnvironment(env, SPACE_ENVIRONMENTS_BY_ID);
-                }
-            }
-            return resp;
+            ...options,
         });
     };
-    const getSpaceEnvironments = () => Array.from(SPACE_ENVIRONMENTS_BY_ID.values());
-    const refreshSpaceEnvironments = (space, organization) => {
-        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/environment`;
-        return requestDatalayer({
-            url,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.items.forEach(d => {
-                    toEnvironment(d, SPACE_ENVIRONMENTS_BY_ID);
+    /**
+     * Get public items (query hook)
+     * @param options - Query options
+     */
+    const usePublicItems = (options) => {
+        return useQuery({
+            queryKey: queryKeys.items.public(),
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.libraryRunUrl}/api/library/v1/items/public`,
+                    method: 'GET',
                 });
-            }
-            return resp;
+                return resp;
+            },
+            ...options,
         });
     };
-    // Lessons ------------------------------------------------------------------
-    const toLesson = raw_lesson => {
-        const owner = newUserMock();
-        USERS_BY_ID.set(owner.id, owner);
-        const lesson = {
-            id: raw_lesson.uid,
-            type: 'lesson',
-            name: raw_lesson.name_t,
-            description: raw_lesson.description_t,
-            nbformat: raw_lesson.model_s ? JSON.parse(raw_lesson.model_s) : undefined,
-            public: raw_lesson.public_b ?? false,
-            creationDate: new Date(raw_lesson.creation_ts_dt),
-            lastUpdateDate: raw_lesson.last_update_ts_dt
-                ? new Date(raw_lesson.last_update_ts_dt)
-                : undefined,
-            lastPublicationDate: raw_lesson.creation_ts_dt
-                ? new Date(raw_lesson.creation_ts_dt)
-                : undefined,
-            owner,
-            space: {
-                handle: raw_lesson.handle_s,
+    /**
+     * Refresh public items
+     * @param options - Mutation options
+     */
+    const useRefreshPublicItems = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.libraryRunUrl}/api/library/v1/items/public`,
+                    method: 'GET',
+                });
+                return resp;
             },
-            organization: {
-                handle: raw_lesson.handle_s,
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: queryKeys.items.public() });
             },
-            datasets: [],
-        };
-        SPACE_LESSONS_BY_ID.set(lesson.id, lesson);
-        return lesson;
-    };
-    const getLesson = id => SPACE_LESSONS_BY_ID.get(id);
-    const refreshLesson = (id) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/lessons/${id}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const lesson = resp.lesson;
-                if (lesson) {
-                    toLesson(lesson);
-                }
-            }
-            return resp;
+            ...options,
         });
     };
-    const getSpaceLessons = () => Array.from(SPACE_LESSONS_BY_ID.values());
-    const getSpaceLesson = id => SPACE_LESSONS_BY_ID.get(id);
-    const refreshSpaceLessons = (space, organization) => {
-        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/lesson`;
-        return requestDatalayer({
-            url,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.items.forEach(n => {
-                    toLesson(n);
+    /**
+     * Refresh space items
+     * @param options - Mutation options
+     */
+    const useRefreshSpaceItems = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (spaceId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items`,
+                    method: 'GET',
                 });
-            }
-            return resp;
+                return resp;
+            },
+            onSuccess: (data, spaceId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.items.bySpace(spaceId),
+                });
+            },
+            ...options,
         });
     };
-    const cloneLesson = (lessonId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${lessonId}/clone`,
-            method: 'POST',
-        }).then(resp => {
-            if (resp.success) {
-                toLesson(resp.notebook);
-            }
-            return resp;
+    /**
+     * Clear cached organizations (mutation)
+     * @param options - Mutation options
+     */
+    const useClearCachedOrganizations = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async () => {
+                // No API call, just clear cache
+                return;
+            },
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: ['organizations'] });
+            },
+            ...options,
         });
     };
-    // Exercises ------------------------------------------------------------------
-    const toExercise = (ex) => {
-        const owner = newUserMock();
-        USERS_BY_ID.set(owner.id, owner);
-        const exercise = {
-            id: ex.uid,
-            type: 'exercise',
-            name: ex.name_t,
-            description: ex.description_t,
-            help: ex.help_t,
-            codePre: ex.code_pre_t,
-            codeQuestion: ex.code_question_t,
-            codeSolution: ex.code_solution_t,
-            codeTest: ex.code_test_t,
-            public: ex.public_b ?? false,
-            creationDate: new Date(ex.creation_ts_dt),
-            lastUpdateDate: ex.last_update_ts_dt
-                ? new Date(ex.last_update_ts_dt)
-                : undefined,
-            lastPublicationDate: ex.creation_ts_dt
-                ? new Date(ex.creation_ts_dt)
-                : undefined,
-            owner,
-            space: {
-                handle: ex.handle_s,
+    /**
+     * Clear cached teams (mutation)
+     * @param options - Mutation options
+     */
+    const useClearCachedTeams = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async () => {
+                // No API call, just clear cache
+                return;
             },
-            organization: {
-                handle: ex.handle_s,
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: ['teams'] });
             },
-            datasets: [],
-        };
-        SPACE_EXERCISES_BY_ID.set(exercise.id, exercise);
-        return exercise;
-    };
-    const getExercise = (id) => SPACE_EXERCISES_BY_ID.get(id);
-    const refreshExercise = (id) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${id}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const exercise = resp.item;
-                if (exercise) {
-                    toExercise(exercise);
-                }
-            }
-            return resp;
+            ...options,
         });
     };
-    const getSpaceExercises = () => {
-        return Array.from(SPACE_EXERCISES_BY_ID.values());
-    };
-    const refreshSpaceExercises = (space, organization) => {
-        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/exercise`;
-        return requestDatalayer({
-            url,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.items.forEach(d => {
-                    toExercise(d);
+    // ============================================================================
+    // BATCH 12: Additional Refresh Operations
+    // ============================================================================
+    /**
+     * Refresh a specific environment
+     * @param options - Mutation options
+     */
+    const useRefreshEnvironment = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (environmentId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${environmentId}`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: (data, environmentId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.environments.detail(environmentId),
                 });
-            }
-            return resp;
-        });
-    };
-    const cloneExercise = (exerciseId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/exercises/${exerciseId}/clone`,
-            method: 'POST',
-        }).then(resp => {
-            if (resp.success) {
-                toExercise(resp.exercise);
-            }
-            return resp;
-        });
-    };
-    const updateExercise = ({ id, name, description, help, codePre, codeSolution, codeQuestion, codeTest, }) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/exercises/${id}`,
-            method: 'PUT',
-            body: {
-                name,
-                description,
-                help,
-                codePre,
-                codeSolution,
-                codeQuestion,
-                codeTest,
             },
+            ...options,
         });
     };
-    const updateExercisePoints = (id, codeStudent, points) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/exercises/${id}/points`,
-            method: 'PUT',
-            body: {
-                codeStudent,
-                points,
+    /**
+     * Refresh space environments
+     * @param options - Mutation options
+     */
+    const useRefreshSpaceEnvironments = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (spaceId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/environment`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: (data, spaceId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.environments.bySpace(spaceId),
+                });
             },
+            ...options,
         });
     };
-    // Assignments ------------------------------------------------------------------
-    const toAssignment = (raw_assignment) => {
-        const owner = newUserMock();
-        USERS_BY_ID.set(owner.id, owner);
-        let studentItem = undefined;
-        if (raw_assignment.student_items) {
-            raw_assignment.student_items.forEach(student_item => {
-                studentItem = {
-                    id: student_item.uid,
-                    type: 'student_item',
-                    itemId: student_item.item_uid,
-                    itemType: student_item.item_type_s,
-                    nbgrades: student_item.nbgrades,
-                    nbgradesTotalPoints: student_item.nbgrades_total_points_f,
-                    nbgradesTotalScore: student_item.nbgrades_total_score_f,
-                };
-            });
-        }
-        USERS_BY_ID.set(owner.id, owner);
-        const assignment = {
-            id: raw_assignment.uid,
-            type: 'assignment',
-            name: raw_assignment.name_t,
-            description: raw_assignment.description_t,
-            nbformat: raw_assignment.model_s
-                ? JSON.parse(raw_assignment.model_s)
-                : undefined,
-            public: raw_assignment.public_b ?? false,
-            creationDate: new Date(raw_assignment.creation_ts_dt),
-            lastUpdateDate: raw_assignment.last_update_ts_dt
-                ? new Date(raw_assignment.last_update_ts_dt)
-                : undefined,
-            lastPublicationDate: raw_assignment.creation_ts_dt
-                ? new Date(raw_assignment.creation_ts_dt)
-                : undefined,
-            studentItem,
-            datasets: [],
-            owner,
-            space: {
-                handle: raw_assignment.handle_s,
+    /**
+     * Refresh a specific lesson
+     * @param options - Mutation options
+     */
+    const useRefreshLesson = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (lessonId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/lessons/${lessonId}`,
+                    method: 'GET',
+                });
+                return resp;
             },
-            organization: {
-                handle: raw_assignment.handle_s,
+            onSuccess: (data, lessonId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.lessons.detail(lessonId),
+                });
             },
-        };
-        SPACE_ASSIGNMENTS_BY_ID.set(assignment.id, assignment);
-        STUDENT_ASSIGNMENTS_BY_ID.set(assignment.id, assignment);
-        return assignment;
-    };
-    const getAssignment = assignmentId => SPACE_ASSIGNMENTS_BY_ID.get(assignmentId);
-    const refreshAssignment = (assignmentId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const assignment = resp.assignment;
-                if (assignment) {
-                    toAssignment(assignment);
-                }
-            }
-            return resp;
+            ...options,
         });
     };
-    const getAssignmentForStudent = (assignmentId) => STUDENT_ASSIGNMENTS_BY_ID.get(assignmentId);
-    const refreshAssignmentForStudent = (courseId, user, assignmentId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}/courses/${courseId}/students/${user.id}`,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                const assignment = resp.assignment;
-                if (assignment) {
-                    toAssignment(assignment);
-                }
-            }
-            return resp;
+    /**
+     * Refresh space lessons
+     * @param options - Mutation options
+     */
+    const useRefreshSpaceLessons = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (spaceId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/lesson`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: (data, spaceId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.lessons.bySpace(spaceId),
+                });
+            },
+            ...options,
         });
     };
-    const resetAssignmentForStudent = (courseId, user, assignmentId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}/reset`,
-            method: 'POST',
-        }).then(resp => {
-            if (resp.success) {
-                const assignment = resp.assignment;
-                if (assignment) {
-                    toAssignment(assignment);
-                }
-            }
-            return resp;
+    /**
+     * Refresh a specific exercise
+     * @param options - Mutation options
+     */
+    const useRefreshExercise = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (exerciseId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${exerciseId}`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: (data, exerciseId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.exercises.detail(exerciseId),
+                });
+            },
+            ...options,
         });
     };
-    const gradeAssignmentForStudent = (courseId, user, assignmentId, model) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}/students/${user.id}/grade`,
-            method: 'PUT',
-            body: {
-                model,
+    /**
+     * Refresh space exercises
+     * @param options - Mutation options
+     */
+    const useRefreshSpaceExercises = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (spaceId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/exercise`,
+                    method: 'GET',
+                });
+                return resp;
             },
-        }).then(resp => {
-            if (resp.success) {
-                const assignment = resp.assignment;
-                if (assignment) {
-                    toAssignment(assignment);
-                }
-            }
-            return resp;
+            onSuccess: (data, spaceId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.exercises.bySpace(spaceId),
+                });
+            },
+            ...options,
         });
     };
-    const getSpaceAssignments = () => Array.from(SPACE_ASSIGNMENTS_BY_ID.values());
-    const getSpaceAssignment = id => SPACE_ASSIGNMENTS_BY_ID.get(id);
-    const refreshSpaceAssignments = (space, organization) => {
-        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/assignment`;
-        return requestDatalayer({
-            url,
-            method: 'GET',
-        }).then(resp => {
-            if (resp.success) {
-                resp.items.forEach(n => {
-                    toAssignment(n);
+    /**
+     * Refresh a specific assignment
+     * @param options - Mutation options
+     */
+    const useRefreshAssignment = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (assignmentId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}`,
+                    method: 'GET',
                 });
-            }
-            return resp;
+                return resp;
+            },
+            onSuccess: (data, assignmentId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.assignments.detail(assignmentId),
+                });
+            },
+            ...options,
         });
     };
-    const cloneAssignment = (assignmentId) => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${assignmentId}/clone`,
-            method: 'POST',
-        }).then(resp => {
-            if (resp.success) {
-                toAssignment(resp.notebook);
-            }
-            return resp;
+    /**
+     * Refresh assignment for a specific student
+     * @param options - Mutation options
+     */
+    const useRefreshAssignmentForStudent = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ courseId, userId, assignmentId, }) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}/courses/${courseId}/students/${userId}`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: (data, variables) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.assignments.forStudent(variables.assignmentId, variables.courseId, variables.userId),
+                });
+            },
+            ...options,
         });
     };
-    const getAssignmentStudentVersion = assignmentId => {
-        return requestDatalayer({
-            url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}/student_version`,
-            method: 'GET',
+    /**
+     * Refresh space assignments
+     * @param options - Mutation options
+     */
+    const useRefreshSpaceAssignments = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (spaceId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items/types/assignment`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: (data, spaceId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.assignments.bySpace(spaceId),
+                });
+            },
+            ...options,
         });
     };
-    // Prices -------------------------------------------------------------------
-    const refreshStripePrices = () => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/stripe/v1/prices`,
-            method: 'GET',
+    /**
+     * Clear cached items (mutation)
+     * @param options - Mutation options
+     */
+    const useClearCachedItems = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async () => {
+                // No API call, just clear cache
+                return;
+            },
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: ['items'] });
+            },
+            ...options,
         });
     };
-    // Checkout -------------------------------------------------------------------
-    const createCheckoutSession = (product, location) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/stripe/v1/checkout/session`,
-            method: 'POST',
-            body: {
-                price_id: product?.id,
-                return_url: `${location.protocol}//${location.host}${location.pathname.split('/').slice(0, -1).join('/')}`,
+    /**
+     * Clear cached public items (mutation)
+     * @param options - Mutation options
+     */
+    const useClearCachedPublicItems = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async () => {
+                // No API call, just clear cache
+                return;
+            },
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: queryKeys.items.public() });
             },
-        })
-            .then(data => data.client_secret)
-            .catch(error => {
-            console.error('Failed to create Stripe checkout session.', error);
+            ...options,
         });
     };
-    // Credits -------------------------------------------------------------------
-    const burnCredit = credits => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/usage/credits`,
-            method: 'DELETE',
-            body: {
-                credits,
+    // ============================================================================
+    // BATCH 13: Final Methods - Invites, Contacts, Inbounds, Outbounds
+    // ============================================================================
+    /**
+     * Request an invite (mutation)
+     * @param options - Mutation options
+     */
+    const useRequestInvite = (options) => {
+        return useMutation({
+            mutationFn: async ({ firstName, lastName, email, socialUrl, }) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/invites/request`,
+                    method: 'POST',
+                    body: {
+                        first_name: firstName,
+                        last_name: lastName,
+                        email: email,
+                        social_url: socialUrl,
+                    },
+                });
+                return resp;
             },
+            ...options,
         });
     };
-    const getUserCredits = userId => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/usage/credits/users/${userId}`,
-            method: 'GET',
+    /**
+     * Send an invite (mutation)
+     * @param options - Mutation options
+     */
+    const useSendInvite = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async ({ email, firstName, lastName, message, brand, }) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/invites`,
+                    method: 'POST',
+                    body: {
+                        email,
+                        firstName,
+                        lastName,
+                        message,
+                        brand,
+                    },
+                });
+                return resp;
+            },
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: ['invites'] });
+            },
+            ...options,
         });
     };
-    const updateUserCredits = (userId, credits, brand) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/usage/credits/users/${userId}`,
-            method: 'PUT',
-            body: {
-                credits,
-                brand,
+    /**
+     * Refresh a specific invite by token
+     * @param options - Mutation options
+     */
+    const useRefreshInvite = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (token) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/invites/tokens/${token}`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: (data, token) => {
+                queryClient.invalidateQueries({ queryKey: ['invites', token] });
             },
+            ...options,
         });
     };
-    const updateUserCreditsQuota = (userId, quota) => {
-        return requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/usage/quota`,
-            method: 'PUT',
-            body: {
-                user_uid: userId,
-                quota,
-                reset: '0',
+    /**
+     * Refresh invites for a user
+     * @param options - Mutation options
+     */
+    const useRefreshInvites = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (accountId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/invites/users/${accountId}`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: ['invites'] });
             },
+            ...options,
         });
     };
-    // Usages -------------------------------------------------------------------
     /**
-     * Get user usages
+     * Clear cached invites (mutation)
+     * @param options - Mutation options
      */
-    const getUsages = async () => {
-        const data = await requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/usage/user`,
-            method: 'GET',
+    const useClearCachedInvites = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async () => {
+                // No API call, just clear cache
+                return;
+            },
+            onSuccess: () => {
+                queryClient.invalidateQueries({ queryKey: ['invites'] });
+            },
+            ...options,
         });
-        data.usages = (data.usages ?? []).map(u => asUsage(u));
-        return data;
     };
     /**
-     * Get user usages
+     * Refresh a specific contact
+     * @param options - Mutation options
      */
-    const getUsagesForUser = async (userId) => {
-        const data = await requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/usage/users/${userId}`,
-            method: 'GET',
+    const useRefreshContact = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (contactId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: (data, contactId) => {
+                queryClient.invalidateQueries({
+                    queryKey: queryKeys.contacts.detail(contactId),
+                });
+            },
+            ...options,
         });
-        data.usages = (data.usages ?? []).map(u => asUsage(u));
-        return data;
     };
     /**
-     * Get platform usages
+     * Get inbound by ID (query hook)
+     * @param id - Inbound ID
+     * @param options - Query options
      */
-    const getPlatformUsages = async () => {
-        const data = await requestDatalayer({
-            url: `${configuration.iamRunUrl}/api/iam/v1/usage/platform`,
-            method: 'GET',
+    const useInbound = (id, options) => {
+        return useQuery({
+            queryKey: ['inbounds', id],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.inboundsRunUrl}/api/inbounds/v1/inbounds/${id}`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            ...options,
         });
-        data.usages = (data.usages ?? []).map(u => asUsage(u));
-        return data;
     };
-    // Support ------------------------------------------------------------------
-    const requestPlatformSupport = (subject, message, email, brand) => {
-        return requestDatalayer({
-            url: `${configuration.supportRunUrl}/api/support/v1/support/request`,
-            method: 'POST',
-            body: {
-                subject,
-                message,
-                email,
-                brand,
+    /**
+     * Get inbound by handle (query hook)
+     * @param handle - Inbound handle
+     * @param options - Query options
+     */
+    const useInboundByHandle = (handle, options) => {
+        return useQuery({
+            queryKey: ['inbounds', 'handle', handle],
+            queryFn: async () => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.inboundsRunUrl}/api/inbounds/v1/inbounds/handles/${handle}`,
+                    method: 'GET',
+                });
+                return resp;
             },
+            ...options,
         });
     };
-    const requestPlatformSupport2 = (accountHandle, firstName, lastName, email, message) => {
-        return requestDatalayer({
-            url: `${configuration.supportRunUrl}/api/support/v1/support/request2`,
-            method: 'POST',
-            body: {
-                accountHandle,
-                firstName,
-                lastName,
-                email,
-                message,
+    /**
+     * Refresh inbound data
+     * @param options - Mutation options
+     */
+    const useRefreshInbound = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (userId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.inboundsRunUrl}/api/inbounds/v1/inbounds/${userId}`,
+                    method: 'GET',
+                });
+                return resp;
             },
+            onSuccess: (data, userId) => {
+                queryClient.invalidateQueries({ queryKey: ['inbounds', userId] });
+                queryClient.invalidateQueries({ queryKey: ['inbounds', 'list'] });
+            },
+            ...options,
         });
     };
-    // Growth ------------------------------------------------------------------
-    const getGrowthKPI = () => {
-        return requestDatalayer({
-            url: `${configuration.growthRunUrl}/api/growth/v1/kpis`,
-            method: 'GET',
+    /**
+     * Refresh outbound data
+     * @param options - Mutation options
+     */
+    const useRefreshOutbound = (options) => {
+        const queryClient = useQueryClient();
+        return useMutation({
+            mutationFn: async (outboundId) => {
+                const resp = await requestDatalayer({
+                    url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/${outboundId}`,
+                    method: 'GET',
+                });
+                return resp;
+            },
+            onSuccess: (data, outboundId) => {
+                queryClient.invalidateQueries({ queryKey: ['outbounds', outboundId] });
+                queryClient.invalidateQueries({ queryKey: ['outbounds', 'list'] });
+            },
+            ...options,
         });
     };
-    // --------------------------------------------------------------------------
+    // ============================================================================
+    // Return all methods grouped by category
+    // ============================================================================
     return {
-        addMemberToOrganization,
-        addMemberToOrganizationSpace,
-        addMemberToTeam,
-        addRoleToOrganizationMember,
-        addRoleToTeamMember,
-        assignRoleToUser,
-        assignTagToContact,
-        burnCredit,
-        changePassword,
-        clearAllCaches,
-        clearCachedDatasources,
-        clearCachedInvites,
-        clearCachedItems,
-        clearCachedOrganizations,
-        clearCachedPages,
-        clearCachedPublicItems,
-        clearCachedSecrets,
-        clearCachedTeams,
-        clearCachedTokens,
-        cloneAssignment,
-        cloneCell,
-        cloneDocument,
-        cloneExercise,
-        cloneLesson,
-        cloneNotebook,
-        createNotebook,
-        confirmCourseItemCompletion,
-        confirmEmailUpdate,
-        confirmJoinWithToken,
-        confirmPassworkWithToken,
-        createCheckoutSession,
-        createContact,
-        createDatasource,
-        createOrganization,
-        createPage,
-        createSecret,
-        createSpace,
-        createTeam,
-        createToken,
-        createTokenForPasswordChange,
-        deleteContact,
-        deleteItem,
-        deleteOutbound,
-        deletePage,
-        deleteSecret,
-        disableUserMFA,
-        draftBulkEmailsOutbounds,
-        enableUserMFA,
-        enrichContactEmail,
-        enrichContactLinkedin,
-        enrollStudentToCourse,
-        exportSpace,
-        getAssignment,
-        getAssignmentForStudent,
-        getAssignmentStudentVersion,
-        getCell,
-        getContactByHandle,
-        getContactById,
-        getCourse,
-        getCoursesEnrollments,
-        getDataset,
-        getDatasource,
-        getDatasources,
-        getDocument,
-        getEnvironment,
-        getExercise,
-        getGitHubProfile,
-        getGrowthKPI,
-        getInbound,
-        getInboundByHandle,
-        getInbounds,
-        getInstructorCourses,
-        getInvite,
-        getInvites,
-        getLesson,
-        getLinkedinProfile,
-        getMe,
-        getNotebook,
-        getOAuth2AuthorizationLinkURL,
-        getOAuth2AuthorizationURL,
-        getOrganizationByHandle,
-        getOrganizationById,
-        getOrganizationSpace,
-        getOrganizationSpaceByHandle,
-        getOrganizationSpaces,
-        getOutbound,
-        getOutbounds,
-        getPage,
-        getPages,
-        getPlatformUsages,
-        getPublicCourses,
-        getPublicItems,
-        getSchools,
-        getSecret,
-        getSecrets,
-        getSpaceAssignment,
-        getSpaceAssignments,
-        getSpaceCells,
-        getSpaceDatasets,
-        getSpaceDocument,
-        getSpaceDocuments,
-        getSpaceEnvironments,
-        getSpaceExercises,
-        getSpaceItems,
-        getSpaceLesson,
-        getSpaceLessons,
-        getSpaceNotebook,
-        getSpaceNotebooks,
-        getStudent,
-        getTeamByHandle,
-        getTeamById,
-        getTeamsByOrganizationId,
-        getToken,
-        getTokens,
-        getUsages,
-        getUsagesForUser,
-        getUser,
-        getUserByHandle,
-        getUserCredits,
-        getUserOrganizationById,
-        getUserOrganizations,
-        getUserSpace,
-        getUserSpaceByHandle,
-        getUserSpaces,
-        getUserSurveys,
-        gradeAssignmentForStudent,
-        joinWithInvite,
-        launchBulkEmailsOutbounds,
-        linkUserWithContact,
-        login,
-        logout,
-        makeItemPrivate,
-        makeItemPublic,
-        makeSpacePrivate,
-        makeSpacePublic,
-        postLinkedinShare,
-        postLinkedinShareWithUpload,
-        proxyGET,
-        proxyPOST,
-        proxyPUT,
-        putInvite,
-        refreshAccount,
-        refreshAssignment,
-        refreshAssignmentForStudent,
-        refreshCell,
-        refreshContact,
-        refreshCourse,
-        refreshCoursesEnrollments,
-        refreshDataset,
-        refreshDatasource,
-        refreshDatasources,
-        refreshDocument,
-        refreshEnvironment,
-        refreshExercise,
-        refreshInbound,
-        refreshInstructorCourses,
-        refreshInvite,
-        refreshInvites,
-        refreshLayout,
-        refreshLesson,
-        refreshNotebook,
-        refreshOrganization,
-        refreshOrganizationSpace,
-        refreshOrganizationSpaces,
-        refreshOutbound,
-        refreshPage,
-        refreshPages,
-        refreshPublicCourses,
-        refreshPublicItems,
-        refreshSchools,
-        refreshSecret,
-        refreshSecrets,
-        refreshSpaceAssignments,
-        refreshSpaceCells,
-        refreshSpaceDatasets,
-        refreshSpaceDocuments,
-        refreshSpaceEnvironments,
-        refreshSpaceExercises,
-        refreshSpaceItems,
-        refreshSpaceLessons,
-        refreshSpaceNotebooks,
-        refreshStripePrices,
-        refreshStudent,
-        refreshTeam,
-        refreshTeams,
-        refreshToken,
-        refreshTokens,
-        refreshUser,
-        refreshUserOrganizations,
-        refreshUserSpace,
-        refreshUserSpaces,
-        registerToWaitingList,
-        removeMemberFromOrganization,
-        removeMemberFromOrganizationSpace,
-        removeMemberFromTeam,
-        removeRoleFromOrganizationMember,
-        removeRoleFromTeamMember,
-        removeStudentFromCourse,
-        requestEmailUpdate,
-        requestInvite,
-        requestJoin,
-        requestJoinToken,
-        requestPlatformSupport,
-        requestPlatformSupport2,
-        resetAssignmentForStudent,
-        searchContacts,
-        searchPublicItems,
-        searchUsers,
-        sendInvite,
-        sendInviteToContact,
-        sendLinkedinConnectionRequest,
-        sendOutboundEmailToUser,
-        setCourseItems,
-        subscribeUserToOutbounds,
-        toInbound,
-        toOutbound,
-        tryBulkEmailsOutbounds,
-        unassignRoleFromUser,
-        unassignTagFromContact,
-        unlinkUserFromContact,
-        unsubscribeContactFromOutbounds,
-        unsubscribeInviteeFromOutbounds,
-        unsubscribeUserFromOutbounds,
-        updateCell,
-        updateContact,
-        updateCourse,
-        updateDataset,
-        updateDatasource,
-        updateDocument,
-        updateDocumentModel,
-        updateExercise,
-        updateExercisePoints,
-        updateMe,
-        updateNotebook,
-        updateNotebookModel,
-        updateOrganization,
-        updateOrganizationSpace,
-        updatePage,
-        updateSecret,
-        updateSpace,
-        updateTeam,
-        updateToken,
-        updateUserCredits,
-        updateUserCreditsQuota,
-        updateUserOnboarding,
-        updateUserSettings,
-        validateUserMFACode,
-        whoami,
+        // Authentication & Profile
+        useLogin,
+        useLogout,
+        useMe,
+        useUpdateMe,
+        useWhoami,
+        useChangePassword,
+        useRequestEmailUpdate,
+        useConfirmEmailUpdate,
+        useRequestJoin,
+        useRequestJoinToken,
+        useJoinWithInvite,
+        useConfirmJoinWithToken,
+        useCreateTokenForPasswordChange,
+        useConfirmPasswordWithToken,
+        useOAuth2AuthorizationURL,
+        useOAuth2AuthorizationLinkURL,
+        useGetGitHubProfile,
+        useGetLinkedinProfile,
+        usePostLinkedinShare,
+        usePostLinkedinShareWithUpload,
+        useRegisterToWaitingList,
+        // Proxy
+        useProxyGET,
+        useProxyPOST,
+        useProxyPUT,
+        // Users
+        useUser,
+        useUserByHandle,
+        useSearchUsers,
+        useUpdateUserOnboarding,
+        useUpdateUserSettings,
+        useRefreshUser,
+        useUserCredits,
+        useUpdateUserCredits,
+        useAssignRoleToUser,
+        useUnassignRoleFromUser,
+        useUpdateUserCreditsQuota,
+        useUsages,
+        useUsagesForUser,
+        usePlatformUsages,
+        // Organizations
+        useOrganization,
+        useOrganizationByHandle,
+        useUserOrganizations,
+        useCreateOrganization,
+        useUpdateOrganization,
+        useAddMemberToOrganization,
+        useRemoveMemberFromOrganization,
+        useAddRoleToOrganizationMember,
+        useRemoveRoleFromOrganizationMember,
+        useRefreshOrganization,
+        useRefreshUserOrganizations,
+        useUserOrganizationById,
+        useClearCachedOrganizations,
+        // Teams
+        useTeam,
+        useTeamByHandle,
+        useTeamsByOrganization,
+        useCreateTeam,
+        useUpdateTeam,
+        useAddMemberToTeam,
+        useRemoveMemberFromTeam,
+        useAddRoleToTeamMember,
+        useRemoveRoleFromTeamMember,
+        useRefreshTeam,
+        useRefreshTeams,
+        useClearCachedTeams,
+        // Schools
+        useSchools,
+        useRefreshSchools,
+        // Spaces
+        useSpace,
+        useOrganizationSpace,
+        useOrganizationSpaceByHandle,
+        useOrganizationSpaces,
+        useUserSpace,
+        useUserSpaceByHandle,
+        useUserSpaces,
+        useCreateSpace,
+        useUpdateSpace,
+        useUpdateOrganizationSpace,
+        useAddMemberToOrganizationSpace,
+        useRemoveMemberFromOrganizationSpace,
+        useMakeSpacePublic,
+        useMakeSpacePrivate,
+        useRefreshOrganizationSpace,
+        useRefreshOrganizationSpaces,
+        useRefreshUserSpaces,
+        useRefreshUserSpace,
+        useRefreshLayout,
+        useExportSpace,
+        // Courses
+        useCourse,
+        useUpdateCourse,
+        usePublicCourses,
+        useInstructorCourses,
+        useCourseEnrollments,
+        useEnrollStudentToCourse,
+        useRemoveStudentFromCourse,
+        useStudent,
+        useConfirmCourseItemCompletion,
+        useSetCourseItems,
+        useRefreshCourse,
+        useRefreshPublicCourses,
+        useRefreshInstructorCourses,
+        useRefreshCoursesEnrollments,
+        useRefreshStudent,
+        // Notebooks
+        useNotebook,
+        useNotebooksBySpace,
+        useCreateNotebook,
+        useUpdateNotebook,
+        useUpdateNotebookModel,
+        useCloneNotebook,
+        useRefreshNotebook,
+        useRefreshSpaceNotebooks,
+        // Documents
+        useDocument,
+        useDocumentsBySpace,
+        useUpdateDocument,
+        useUpdateDocumentModel,
+        useCloneDocument,
+        useRefreshDocument,
+        useRefreshSpaceDocuments,
+        // Cells
+        useCell,
+        useCellsBySpace,
+        useUpdateCell,
+        useCloneCell,
+        useRefreshCell,
+        useRefreshSpaceCells,
+        // Datasets
+        useDataset,
+        useDatasetsBySpace,
+        useUpdateDataset,
+        useRefreshDataset,
+        useRefreshSpaceDatasets,
+        // Environments
+        useEnvironment,
+        useEnvironmentsBySpace,
+        useRefreshEnvironment,
+        useRefreshSpaceEnvironments,
+        // Lessons
+        useLesson,
+        useLessonsBySpace,
+        useCloneLesson,
+        useRefreshLesson,
+        useRefreshSpaceLessons,
+        // Exercises
+        useExercise,
+        useExercisesBySpace,
+        useUpdateExercise,
+        useCloneExercise,
+        useUpdateExercisePoints,
+        useRefreshExercise,
+        useRefreshSpaceExercises,
+        // Assignments
+        useAssignment,
+        useAssignmentsBySpace,
+        useCloneAssignment,
+        useAssignmentForStudent,
+        useAssignmentStudentVersion,
+        useGradeAssignmentForStudent,
+        useResetAssignmentForStudent,
+        useRefreshAssignment,
+        useRefreshAssignmentForStudent,
+        useRefreshSpaceAssignments,
+        // Items (Generic)
+        useDeleteItem,
+        useSpaceItems,
+        useMakeItemPublic,
+        useMakeItemPrivate,
+        useSearchPublicItems,
+        usePublicItems,
+        useRefreshPublicItems,
+        useRefreshSpaceItems,
+        useClearCachedPublicItems,
+        useClearCachedItems,
+        // Pages
+        usePage,
+        usePages,
+        useCreatePage,
+        useUpdatePage,
+        useDeletePage,
+        // Datasources
+        useDatasource,
+        useDatasources,
+        useCreateDatasource,
+        useUpdateDatasource,
+        // Secrets
+        useSecret,
+        useSecrets,
+        useCreateSecret,
+        useUpdateSecret,
+        useDeleteSecret,
+        // Tokens
+        useToken,
+        useTokens,
+        useCreateToken,
+        useUpdateToken,
+        // Invites
+        useInvite,
+        useInvitesByUser,
+        usePutInvite,
+        useRequestInvite,
+        useSendInvite,
+        useRefreshInvite,
+        useRefreshInvites,
+        useClearCachedInvites,
+        // Contacts
+        useContact,
+        useContactByHandle,
+        useSearchContacts,
+        useCreateContact,
+        useUpdateContact,
+        useDeleteContact,
+        useAssignTagToContact,
+        useUnassignTagFromContact,
+        useSendInviteToContact,
+        useEnrichContactEmail,
+        useEnrichContactLinkedin,
+        useSendLinkedinConnectionRequest,
+        useLinkUserWithContact,
+        useUnlinkUserFromContact,
+        useRefreshContact,
+        // Inbounds
+        useInbounds,
+        useInbound,
+        useInboundByHandle,
+        useRefreshInbound,
+        // Outbounds
+        useOutbound,
+        useOutbounds,
+        useDraftBulkEmailsOutbounds,
+        useTryBulkEmailsOutbounds,
+        useLaunchBulkEmailsOutbounds,
+        useSendOutboundEmailToUser,
+        useDeleteOutbound,
+        useSubscribeUserToOutbounds,
+        useUnsubscribeUserFromOutbounds,
+        useUnsubscribeContactFromOutbounds,
+        useUnsubscribeInviteeFromOutbounds,
+        useRefreshOutbound,
+        // MFA
+        useEnableUserMFA,
+        useDisableUserMFA,
+        useValidateUserMFACode,
+        // Checkout & Credits
+        useCreateCheckoutSession,
+        useBurnCredit,
+        useStripePrices,
+        // Support & Growth
+        useRequestPlatformSupport,
+        useRequestPlatformSupport2,
+        useUserSurveys,
+        useGrowthKPI,
+        // Query keys for manual operations
+        queryKeys,
+        // Upload
         notebookUploadLoading,
         notebookUploadProgress,
         resetNotebookUpload,
diff --git a/node_modules/@datalayer/core/lib/hooks/useCache0.d.ts b/node_modules/@datalayer/core/lib/hooks/useCache0.d.ts
new file mode 100644
index 0000000..ac41243
--- /dev/null
+++ b/node_modules/@datalayer/core/lib/hooks/useCache0.d.ts
@@ -0,0 +1,312 @@
+import { IAnyOrganization, IAnySpace, IAssignment, ICell, IContact, ICourse, IDataset, IDatasource, IDocument, IEnvironment, IExercise, IIAMToken, IInbound, IInvite, IItemType, ILesson, ILinkedInUser, INotebook, IOrganization, IOutbound, IPage, ISchool, ISecret, ISpaceItem, IStudent, ITeam, IUsage, IUser, IUserOnboarding, IUserSettings, LinkedInUser, WaitingListFormData } from '../models';
+import { IPrice } from './../components/checkout';
+import { type IRESTBaseResponse } from '../models';
+type CacheProps = {
+    loginRoute?: string;
+};
+type ISearchOpts = {
+    q: string;
+    types: string[];
+    max: number;
+    public: boolean;
+};
+/**
+ * Callbacks to Datalayer service.
+ *
+ * It assumes to be used within a {@link Router} component. If not
+ * you must set the options `loginRoute` to `null` (raise an error _Unauthorized_
+ * instead of redirecting to the login page).
+ *
+ * @deprecated use useCache instead.
+ */
+export declare const useCache0: ({ loginRoute }?: CacheProps) => {
+    login: (handle: any, password: any) => Promise<any>;
+    logout: () => Promise<any>;
+    getMe: (token?: string) => Promise<IUser | null>;
+    updateMe: (email: any, firstName: any, lastName: any) => Promise<any>;
+    whoami: () => Promise<any>;
+    requestJoin: (handle: any, email: any, firstName: any, lastName: any, password: any, passwordConfirm: any) => Promise<any>;
+    requestJoinToken: (handle: any, email: any, firstName: any, lastName: any, password: any, passwordConfirm: any) => Promise<any>;
+    joinWithInvite: (formValues: any, token: any) => Promise<any>;
+    confirmJoinWithToken: (userHandle: any, token: any) => Promise<any>;
+    changePassword: (handle: any, password: any, passwordConfirm: any) => Promise<any>;
+    createTokenForPasswordChange: (handle: any, password: any, passwordConfirm: any) => Promise<any>;
+    confirmPassworkWithToken: (userHandle: any, token: any) => Promise<any>;
+    requestEmailUpdate: (email: any) => Promise<any>;
+    confirmEmailUpdate: (token: any) => Promise<any>;
+    getOAuth2AuthorizationURL: (queryArgs: Record<string, string>) => Promise<{
+        success: boolean;
+        autorization_url: string;
+    }>;
+    getOAuth2AuthorizationLinkURL: (queryArgs: Record<string, string>) => Promise<{
+        success: boolean;
+        autorization_url: string;
+    }>;
+    getGitHubProfile: (accessToken: string) => Promise<any>;
+    getLinkedinProfile: (accessToken: string) => Promise<LinkedInUser>;
+    postLinkedinShare: (linkedinUser: ILinkedInUser, postText: string, accessToken: string) => Promise<any>;
+    postLinkedinShareWithUpload: (linkedinUser: ILinkedInUser, postText: string, uploadObject: string, accessToken: string) => Promise<any>;
+    registerToWaitingList: (formData: WaitingListFormData) => void;
+    proxyGET: (url: string, token: string) => Promise<any>;
+    proxyPOST: (url: string, body: object, token: string) => Promise<any>;
+    proxyPUT: (url: string, body: object, token: string) => Promise<any>;
+    getUser: (id: string) => IUser | undefined;
+    getUserByHandle: (handle: string) => IUser | undefined;
+    searchUsers: (namingPattern: string) => Promise<any>;
+    refreshUser: (userId: string) => Promise<any>;
+    assignRoleToUser: (userId: any, roleName: any) => Promise<any>;
+    unassignRoleFromUser: (userId: any, roleName: any) => Promise<any>;
+    updateUserOnboarding: (onboarding: IUserOnboarding) => Promise<any>;
+    updateUserSettings: (userId: string, settings: IUserSettings) => Promise<any>;
+    getUserCredits: (userId: any) => Promise<any>;
+    updateUserCredits: (userId: any, credits: any, brand: any) => Promise<any>;
+    updateUserCreditsQuota: (userId: string, quota?: number) => Promise<any>;
+    getUserSurveys: (userId: string) => Promise<any>;
+    getUsages: () => Promise<{
+        success: boolean;
+        message: string;
+        usages?: IUsage[];
+    }>;
+    getUsagesForUser: (userId: string) => Promise<{
+        success: boolean;
+        message: string;
+        usages?: IUsage[];
+    }>;
+    createOrganization: (organization: Partial<IOrganization>) => Promise<any>;
+    getOrganizationById: (organizationId: string) => IOrganization | undefined;
+    getOrganizationByHandle: (organizationHandle: string) => IOrganization | undefined;
+    getUserOrganizations: () => IAnyOrganization[];
+    getUserOrganizationById: (organizationId: string) => IAnyOrganization | undefined;
+    updateOrganization: (organization: Partial<IAnyOrganization>) => Promise<any>;
+    refreshOrganization: (user: IUser, organizationId: string) => Promise<any>;
+    refreshUserOrganizations: (user: IUser) => Promise<any>;
+    addMemberToOrganization: (organizationId: string, userId: string) => Promise<any>;
+    removeMemberFromOrganization: (organizationId: string, userId: string) => Promise<any>;
+    addRoleToOrganizationMember: (organizationId: string, userId: string, roleName: string) => Promise<any>;
+    removeRoleFromOrganizationMember: (organizationId: string, userId: string, roleName: string) => Promise<any>;
+    clearCachedOrganizations: () => void;
+    createTeam: (team: Partial<ITeam>, organization: IAnyOrganization) => Promise<any>;
+    getTeamById: (teamId: string) => ITeam | undefined;
+    getTeamByHandle: (teamHandle: string) => ITeam | undefined;
+    getTeamsByOrganizationId: (organizationId: string) => ITeam[] | undefined;
+    updateTeam: (team: Partial<ITeam>) => Promise<any>;
+    refreshTeam: (teamId: string, organizationId: string) => Promise<any>;
+    refreshTeams: (organizationId: string) => Promise<any>;
+    addMemberToTeam: (teamId: string, userId: string) => Promise<any>;
+    removeMemberFromTeam: (teamId: string, userId: string) => Promise<any>;
+    addRoleToTeamMember: (teamId: string, userId: string, roleName: string) => Promise<any>;
+    removeRoleFromTeamMember: (teamId: string, userId: string, roleName: string) => Promise<any>;
+    clearCachedTeams: () => void;
+    getSchools: () => ISchool[];
+    refreshSchools: () => Promise<any>;
+    createSpace: (space: Partial<IAnySpace>, organization?: IAnyOrganization) => Promise<any>;
+    getOrganizationSpace: (organizationId: string, spaceId: string) => IAnySpace | undefined;
+    getOrganizationSpaceByHandle: (organizationHandle: string, spaceHandle: string) => IAnySpace | undefined;
+    getOrganizationSpaces: (organizationId: string) => IAnySpace[];
+    getUserSpace: (userId: string) => IAnySpace | undefined;
+    getUserSpaceByHandle: (userHandle: string) => IAnySpace | undefined;
+    getUserSpaces: () => IAnySpace[];
+    updateSpace: (space: Partial<IAnySpace>) => Promise<any>;
+    updateOrganizationSpace: (organization: IAnyOrganization, space: Partial<IAnySpace>) => Promise<any>;
+    refreshOrganizationSpace: (organizationId: string, spaceId: string) => Promise<any>;
+    refreshOrganizationSpaces: (organizationId: string) => Promise<any>;
+    refreshUserSpace: (userId: string, spaceId: string) => Promise<any>;
+    refreshUserSpaces: () => Promise<any>;
+    refreshLayout: (accountHandle: string, spaceHandle?: string, user?: IUser) => Promise<any>;
+    exportSpace: (spaceId: string) => Promise<any>;
+    addMemberToOrganizationSpace: (organizationId: string, spaceId: string, accountId: string) => Promise<any>;
+    removeMemberFromOrganizationSpace: (organizationId: string, spaceId: string, accountId: string) => Promise<any>;
+    makeSpacePublic: (spaceId: string) => Promise<any>;
+    makeSpacePrivate: (spaceId: string) => Promise<any>;
+    getCourse: (courseId: string) => ICourse | undefined;
+    updateCourse: (courseId: any, name: any, description: any) => Promise<any>;
+    refreshCourse: (courseId: string) => Promise<any>;
+    getPublicCourses: () => ICourse[];
+    refreshPublicCourses: () => Promise<any>;
+    getInstructorCourses: () => ICourse[];
+    refreshInstructorCourses: () => Promise<any>;
+    getCoursesEnrollments: () => ICourse[];
+    refreshCoursesEnrollments: () => Promise<any>;
+    enrollStudentToCourse: (courseId: string, studentId: string) => Promise<any>;
+    removeStudentFromCourse: (courseId: string, studentId: string) => Promise<any>;
+    getStudent: (courseId: any, studentId: any) => IStudent | undefined;
+    refreshStudent: (courseId: any, studentHandle: any) => Promise<any>;
+    confirmCourseItemCompletion: (courseId: any, itemType: IItemType, itemId: string, completed: boolean) => Promise<any>;
+    setCourseItems: (courseId: any, itemIds: any) => Promise<any>;
+    createNotebook: (spaceId: string, name: string, description?: string, notebookType?: string) => Promise<any>;
+    getNotebook: (notebookId: any) => INotebook | undefined;
+    getSpaceNotebook: (id: any) => INotebook | undefined;
+    getSpaceNotebooks: () => INotebook[];
+    updateNotebook: (id: any, name: any, description: any) => Promise<any>;
+    updateNotebookModel: (notebookId: any, nbformat: any) => Promise<any>;
+    cloneNotebook: (notebookId: string) => Promise<any>;
+    refreshNotebook: (notebookId: string) => Promise<any>;
+    refreshSpaceNotebooks: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
+    getDocument: (id: any) => IDocument | undefined;
+    getSpaceDocument: (id: any) => IDocument | undefined;
+    getSpaceDocuments: () => IDocument[];
+    updateDocument: (id: any, name: any, description: any) => Promise<any>;
+    updateDocumentModel: (id: any, model: any) => Promise<any>;
+    cloneDocument: (documentId: string) => Promise<any>;
+    refreshDocument: (id: string) => Promise<any>;
+    refreshSpaceDocuments: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
+    getCell: (id: string) => ICell | undefined;
+    getSpaceCells: () => ICell[];
+    updateCell: (cell: {
+        id: string;
+        name: string;
+        description: string;
+        source: string;
+        outputshotUrl?: string;
+        outputshotData?: string;
+        spaceId: string;
+    }) => Promise<any>;
+    cloneCell: (cellId: string) => Promise<any>;
+    refreshCell: (id: string) => Promise<any>;
+    refreshSpaceCells: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
+    getDataset: (id: any) => IDataset | undefined;
+    getSpaceDatasets: () => IDataset[];
+    updateDataset: (id: any, name: any, description: any) => Promise<any>;
+    refreshDataset: (id: string) => Promise<any>;
+    refreshSpaceDatasets: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
+    getEnvironment: (id: string) => IEnvironment | undefined;
+    getSpaceEnvironments: () => IEnvironment[];
+    refreshEnvironment: (id: string) => Promise<any>;
+    refreshSpaceEnvironments: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
+    getLesson: (id: any) => ILesson | undefined;
+    getSpaceLesson: (id: any) => ILesson | undefined;
+    getSpaceLessons: () => ILesson[];
+    cloneLesson: (lessonId: string) => Promise<any>;
+    refreshLesson: (id: string) => Promise<any>;
+    refreshSpaceLessons: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
+    getExercise: (id: string) => IExercise | undefined;
+    getSpaceExercises: () => IExercise[];
+    updateExercise: ({ id, name, description, help, codePre, codeSolution, codeQuestion, codeTest, }: {
+        id: any;
+        name: any;
+        description: any;
+        help: any;
+        codePre: any;
+        codeSolution: any;
+        codeQuestion: any;
+        codeTest: any;
+    }) => Promise<any>;
+    updateExercisePoints: (id: any, codeStudent: any, points: any) => Promise<any>;
+    cloneExercise: (exerciseId: string) => Promise<any>;
+    refreshExercise: (id: string) => Promise<any>;
+    refreshSpaceExercises: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
+    getAssignment: (assignmentId: any) => IAssignment | undefined;
+    getAssignmentForStudent: (assignmentId: string) => IAssignment | undefined;
+    getAssignmentStudentVersion: (assignmentId: any) => Promise<any>;
+    getSpaceAssignment: (id: any) => IAssignment | undefined;
+    getSpaceAssignments: () => IAssignment[];
+    cloneAssignment: (assignmentId: string) => Promise<any>;
+    refreshAssignment: (assignmentId: string) => Promise<any>;
+    refreshAssignmentForStudent: (courseId: string, user: IUser, assignmentId: string) => Promise<any>;
+    refreshSpaceAssignments: (space: IAnySpace, organization?: IAnyOrganization) => Promise<any>;
+    gradeAssignmentForStudent: (courseId: string, user: IUser, assignmentId: string, model: any) => Promise<any>;
+    resetAssignmentForStudent: (courseId: string, user: IUser, assignmentId: string) => Promise<any>;
+    getPublicItems: () => ISpaceItem[];
+    getSpaceItems: () => ISpaceItem[];
+    searchPublicItems: (opts?: ISearchOpts) => Promise<any>;
+    makeItemPublic: (id: string) => Promise<any>;
+    makeItemPrivate: (id: string) => Promise<any>;
+    deleteItem: (itemId: string) => Promise<any>;
+    refreshPublicItems: () => Promise<any>;
+    refreshSpaceItems: (spaceId: string) => Promise<any>;
+    clearCachedPublicItems: () => void;
+    clearCachedItems: () => void;
+    createPage: (page: Omit<IPage, "id">) => Promise<any>;
+    getPage: (pageId: string) => IPage | undefined;
+    getPages: () => IPage[];
+    updatePage: (page: Pick<IPage, "id" | "name" | "description" | "tags">) => Promise<any>;
+    deletePage: (page: IPage) => Promise<any>;
+    refreshPage: (pageId: string) => Promise<any>;
+    refreshPages: () => Promise<any>;
+    clearCachedPages: () => void;
+    createDatasource: (datasource: Omit<IDatasource, "id">) => Promise<any>;
+    getDatasource: (datasourceId: string) => IDatasource | undefined;
+    getDatasources: () => IDatasource[];
+    updateDatasource: (datasource: IDatasource) => Promise<any>;
+    refreshDatasource: (datasourceId: string) => Promise<any>;
+    refreshDatasources: () => Promise<any>;
+    clearCachedDatasources: () => void;
+    createSecret: (secret: Omit<ISecret, "id">) => Promise<any>;
+    getSecret: (secretId: string) => ISecret | undefined;
+    getSecrets: () => ISecret[];
+    updateSecret: (secret: ISecret) => Promise<any>;
+    deleteSecret: (secret: ISecret) => Promise<any>;
+    refreshSecret: (secretId: string) => Promise<any>;
+    refreshSecrets: () => Promise<any>;
+    clearCachedSecrets: () => void;
+    createToken: (token: Omit<IIAMToken, "id" | "value">) => Promise<any>;
+    getToken: (tokenId: string) => IIAMToken | undefined;
+    getTokens: () => IIAMToken[];
+    updateToken: (token: IIAMToken) => Promise<any>;
+    refreshToken: (tokenId: string) => Promise<any>;
+    refreshTokens: () => Promise<any>;
+    clearCachedTokens: () => void;
+    requestInvite: (firstName: string, lastName: string, email: string, socialUrl: string) => Promise<any>;
+    sendInvite: (invite: IInvite) => Promise<any>;
+    getInvite: (token: string) => IInvite | undefined;
+    getInvites: () => IInvite[];
+    putInvite: (token: string) => Promise<any>;
+    refreshInvite: (token: string) => Promise<any>;
+    refreshInvites: (accountId: string) => Promise<any>;
+    refreshAccount: (accountHandle: string) => Promise<any>;
+    clearCachedInvites: () => void;
+    createContact: (contact: IContact) => Promise<any>;
+    getContactById: (contactId: string) => IContact | undefined;
+    getContactByHandle: (contactHandle: string) => IContact | undefined;
+    updateContact: (contactId: any, contact: IContact) => Promise<any>;
+    deleteContact: (contactId: string) => Promise<any>;
+    searchContacts: (query: string) => Promise<any>;
+    refreshContact: (contactId: string) => Promise<any>;
+    assignTagToContact: (contactId: any, tagName: any) => Promise<any>;
+    unassignTagFromContact: (contactId: any, tagName: any) => Promise<any>;
+    sendInviteToContact: (contact: IContact, message: string) => Promise<any>;
+    enrichContactEmail: (contactId: any, useDomain: any) => Promise<any>;
+    enrichContactLinkedin: (contactId: any) => Promise<any>;
+    sendLinkedinConnectionRequest: (contact: IContact, message: string) => Promise<any>;
+    linkUserWithContact: (userId: any, contactId: any) => Promise<any>;
+    unlinkUserFromContact: (userId: any, contactId: any) => Promise<any>;
+    getInbound: (id: string) => IInbound | undefined;
+    getInboundByHandle: (handle: string) => IInbound | undefined;
+    getInbounds: () => Promise<any>;
+    refreshInbound: (userId: string) => Promise<any>;
+    toInbound: (u: any) => IInbound | undefined;
+    getOutbound: (id: string) => IOutbound | undefined;
+    getOutbounds: () => Promise<any>;
+    refreshOutbound: (outboundId: string) => Promise<any>;
+    draftBulkEmailsOutbounds: (params: any) => Promise<any>;
+    tryBulkEmailsOutbounds: (outboundId: string) => Promise<any>;
+    launchBulkEmailsOutbounds: (outboundId: string) => Promise<any>;
+    sendOutboundEmailToUser: (userId: string, recipient: string, subject: string, content: string) => Promise<any>;
+    deleteOutbound: (outboundId: string) => Promise<any>;
+    subscribeUserToOutbounds: (userId: string) => Promise<any>;
+    unsubscribeUserFromOutbounds: (userId: string) => Promise<any>;
+    unsubscribeContactFromOutbounds: (contactId: string) => Promise<any>;
+    unsubscribeInviteeFromOutbounds: (token: string) => Promise<any>;
+    toOutbound: (u: any) => IOutbound | undefined;
+    enableUserMFA: () => Promise<any>;
+    disableUserMFA: () => Promise<any>;
+    validateUserMFACode: (userUid: any, code: string) => Promise<any>;
+    createCheckoutSession: (product: any, location: any) => Promise<any>;
+    burnCredit: (credits: any) => Promise<any>;
+    refreshStripePrices: () => Promise<IRESTBaseResponse & {
+        prices: IPrice[];
+    }>;
+    requestPlatformSupport: (subject: any, message: any, email: any, brand: any) => Promise<any>;
+    requestPlatformSupport2: (accountHandle: any, firstName: any, lastName: any, email: any, message: any) => Promise<any>;
+    getGrowthKPI: () => Promise<any>;
+    getPlatformUsages: () => Promise<{
+        success: boolean;
+        message: string;
+        usages?: IUsage[];
+    }>;
+    clearAllCaches: () => void;
+    notebookUploadLoading: boolean;
+    notebookUploadProgress: number;
+    resetNotebookUpload: () => void;
+};
+export default useCache0;
diff --git a/node_modules/@datalayer/core/lib/hooks/useCache0.js b/node_modules/@datalayer/core/lib/hooks/useCache0.js
new file mode 100644
index 0000000..60706d1
--- /dev/null
+++ b/node_modules/@datalayer/core/lib/hooks/useCache0.js
@@ -0,0 +1,3189 @@
+/*
+ * Copyright (c) 2023-2025 Datalayer, Inc.
+ * Distributed under the terms of the Modified BSD License.
+ */
+/************************************
+ *
+ * DEPRECATED - use useCache instead.
+ *
+ ***********************************/
+import { URLExt } from '@jupyterlab/coreutils';
+import { BOOTSTRAP_USER_ONBOARDING, LinkedInUser, asContact, asDatasource, asInbound, asInvite, asOrganization, asOutbound, asPage, asSecret, asSpace, asSurvey, asTeam, asToken, asUsage, asUser, } from '../models';
+import { useCoreStore, useIAMStore } from '../state';
+import { asDisplayName, namesAsInitials, asArray } from '../utils';
+import { IAMProvidersSpecs } from '../models';
+import { newUserMock } from './../mocks';
+import { useDatalayer } from './useDatalayer';
+import { useAuthorization } from './useAuthorization';
+import { useUploadForm } from './useUpload';
+import { OUTPUTSHOT_PLACEHOLDER_DEFAULT_SVG } from './assets';
+const CONTACTS_BY_HANDLE = new Map();
+const CONTACTS_BY_ID = new Map();
+const COURSES_BY_ID = new Map();
+const COURSES_ENROLLMENTS_BY_ID = new Map();
+const COURSES_INSTRUCTORS_BY_ID = new Map();
+const DATASOURCES_BY_ID = new Map();
+const INBOUNDS_BY_HANDLE = new Map();
+const INBOUNDS_BY_ID = new Map();
+const INVITES_BY_TOKEN = new Map();
+const ORGANISATIONS_BY_HANDLE = new Map();
+const ORGANISATIONS_BY_ID = new Map();
+const ORGANISATIONS_FOR_USER_BY_ID = new Map();
+const OUTBOUNDS_BY_ID = new Map();
+const PAGES_BY_ID = new Map();
+const PUBLIC_COURSES_BY_ID = new Map();
+const PUBLIC_ITEMS_BY_ID = new Map();
+const SCHOOLS_BY_ID = new Map();
+const SECRETS_BY_ID = new Map();
+const SPACES_BY_HANDLE_BY_ORGANISATION_HANDLE = new Map();
+const SPACES_BY_ID_BY_ORGANISATION_ID = new Map();
+const SPACES_FOR_USER_BY_HANDLE = new Map();
+const SPACES_FOR_USER_BY_ID = new Map();
+const SPACE_ASSIGNMENTS_BY_ID = new Map();
+const SPACE_CELLS_BY_ID = new Map();
+const SPACE_DATASETS_BY_ID = new Map();
+const SPACE_DOCUMENTS_BY_ID = new Map();
+const SPACE_ENVIRONMENTS_BY_ID = new Map();
+const SPACE_EXERCISES_BY_ID = new Map();
+const SPACE_ITEMS_CACHE = new Map();
+const SPACE_LESSONS_BY_ID = new Map();
+const SPACE_NOTEBOOKS_BY_ID = new Map();
+const STUDENTS_BY_ID = new Map();
+const STUDENT_ASSIGNMENTS_BY_ID = new Map();
+const TEAMS_BY_HANDLE = new Map();
+const TEAMS_BY_ID = new Map();
+const TEAMS_BY_ORGANIZATION_BY_ID = new Map();
+const TOKENS_BY_ID = new Map();
+const USERS_BY_HANDLE = new Map();
+const USERS_BY_ID = new Map();
+const DEFAULT_SEARCH_OPTS = {
+    q: '*',
+    types: ['page'],
+    max: 3,
+    public: true,
+};
+/**
+ * Callbacks to Datalayer service.
+ *
+ * It assumes to be used within a {@link Router} component. If not
+ * you must set the options `loginRoute` to `null` (raise an error _Unauthorized_
+ * instead of redirecting to the login page).
+ *
+ * @deprecated use useCache instead.
+ */
+export const useCache0 = ({ loginRoute = '/login' } = {}) => {
+    const coreStore = useCoreStore();
+    const { configuration } = coreStore;
+    const { user } = useIAMStore();
+    const { requestDatalayer } = useDatalayer({ loginRoute });
+    const { checkIsOrganizationMember } = useAuthorization();
+    // Hook for notebook upload/creation
+    const { isLoading: notebookUploadLoading, uploadAndSubmit: uploadNotebook, progress: notebookUploadProgress, reset: resetNotebookUpload, } = useUploadForm(`${coreStore.configuration.spacerRunUrl}/api/spacer/v1/notebooks`);
+    // Caches -------------------------------------------------------------------
+    const clearAllCaches = () => {
+        CONTACTS_BY_HANDLE.clear();
+        CONTACTS_BY_ID.clear();
+        COURSES_BY_ID.clear();
+        COURSES_ENROLLMENTS_BY_ID.clear();
+        COURSES_INSTRUCTORS_BY_ID.clear();
+        DATASOURCES_BY_ID.clear();
+        INBOUNDS_BY_HANDLE.clear();
+        INBOUNDS_BY_ID.clear();
+        INVITES_BY_TOKEN.clear();
+        ORGANISATIONS_BY_HANDLE.clear();
+        ORGANISATIONS_BY_ID.clear();
+        ORGANISATIONS_FOR_USER_BY_ID.clear();
+        PAGES_BY_ID.clear();
+        OUTBOUNDS_BY_ID.clear();
+        PUBLIC_COURSES_BY_ID.clear();
+        PUBLIC_ITEMS_BY_ID.clear();
+        SCHOOLS_BY_ID.clear();
+        SECRETS_BY_ID.clear();
+        SPACES_BY_HANDLE_BY_ORGANISATION_HANDLE.clear();
+        SPACES_BY_ID_BY_ORGANISATION_ID.clear();
+        SPACES_FOR_USER_BY_HANDLE.clear();
+        SPACES_FOR_USER_BY_ID.clear();
+        SPACE_ASSIGNMENTS_BY_ID.clear();
+        SPACE_CELLS_BY_ID.clear();
+        SPACE_DATASETS_BY_ID.clear();
+        SPACE_DOCUMENTS_BY_ID.clear();
+        SPACE_ENVIRONMENTS_BY_ID.clear();
+        SPACE_EXERCISES_BY_ID.clear();
+        SPACE_ITEMS_CACHE.clear();
+        SPACE_LESSONS_BY_ID.clear();
+        SPACE_NOTEBOOKS_BY_ID.clear();
+        STUDENTS_BY_ID.clear();
+        STUDENT_ASSIGNMENTS_BY_ID.clear();
+        TOKENS_BY_ID.clear();
+        USERS_BY_HANDLE.clear();
+        USERS_BY_ID.clear();
+    };
+    const clearCachedItems = () => {
+        PUBLIC_ITEMS_BY_ID.clear();
+        SPACE_ASSIGNMENTS_BY_ID.clear();
+        SPACE_DATASETS_BY_ID.clear();
+        SPACE_DOCUMENTS_BY_ID.clear();
+        SPACE_ENVIRONMENTS_BY_ID.clear();
+        SPACE_EXERCISES_BY_ID.clear();
+        SPACE_ITEMS_CACHE.clear();
+        SPACE_ITEMS_CACHE.clear();
+        SPACE_LESSONS_BY_ID.clear();
+        SPACE_NOTEBOOKS_BY_ID.clear();
+        SPACE_CELLS_BY_ID.clear();
+        SPACE_CELLS_BY_ID.clear();
+    };
+    // Authentication ------------------------------------------------------------------
+    const login = (handle, password) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/login`,
+            method: 'POST',
+            body: {
+                handle,
+                password,
+            },
+        });
+    };
+    const logout = () => {
+        clearAllCaches();
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/logout`,
+            method: 'GET',
+        });
+    };
+    // Join ------------------------------------------------------------------
+    const requestJoin = (handle, email, firstName, lastName, password, passwordConfirm) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/join/request`,
+            method: 'POST',
+            body: {
+                handle,
+                email,
+                firstName,
+                lastName,
+                password,
+                passwordConfirm,
+            },
+        });
+    };
+    const requestJoinToken = (handle, email, firstName, lastName, password, passwordConfirm) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/join/request/token`,
+            method: 'POST',
+            body: {
+                handle,
+                email,
+                firstName,
+                lastName,
+                password,
+                passwordConfirm,
+            },
+        });
+    };
+    const joinWithInvite = (formValues, token) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/join/invites/token`,
+            method: 'POST',
+            body: {
+                ...formValues,
+                token,
+            },
+        });
+    };
+    const confirmJoinWithToken = (userHandle, token) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/join/users/${userHandle}/tokens/${token}`,
+            method: 'GET',
+        });
+    };
+    // Password ------------------------------------------------------------------
+    const changePassword = (handle, password, passwordConfirm) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/password`,
+            method: 'PUT',
+            body: {
+                handle,
+                password,
+                passwordConfirm,
+            },
+        });
+    };
+    const createTokenForPasswordChange = (handle, password, passwordConfirm) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/password/token`,
+            method: 'POST',
+            body: {
+                handle,
+                password,
+                passwordConfirm,
+            },
+        });
+    };
+    const confirmPassworkWithToken = (userHandle, token) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/password/confirm/users/${userHandle}/tokens/${token}`,
+            method: 'PUT',
+        });
+    };
+    // OAuth2 -------------------------------------------------------------------
+    const getOAuth2AuthorizationURL = async (queryArgs) => {
+        return requestDatalayer({
+            url: URLExt.join(configuration.iamRunUrl, 'api/iam/v1/oauth2/authz/url') +
+                URLExt.objectToQueryString(queryArgs),
+            notifyOnError: false,
+        });
+    };
+    const getOAuth2AuthorizationLinkURL = async (queryArgs) => {
+        return requestDatalayer({
+            url: URLExt.join(configuration.iamRunUrl, 'api/iam/v1/oauth2/authz/url/link') + URLExt.objectToQueryString(queryArgs),
+        });
+    };
+    // IAM Providers ------------------------------------------------------------
+    const getGitHubProfile = async (accessToken) => {
+        return fetch(IAMProvidersSpecs.GitHub.userInfoURL, {
+            method: 'GET',
+            headers: {
+                Accept: 'application/vnd.github+json',
+                Authorization: `Bearer ${accessToken}`,
+                'X-GitHub-Api-Version': '2022-11-28',
+            },
+        }).then(resp => resp.json());
+    };
+    /*
+     * CORS is not supported @see https://github.com/linkedin-developers/linkedin-api-js-client
+     */
+    const getLinkedinProfile = async (accessToken) => {
+        return proxyGET(IAMProvidersSpecs.LinkedIn.userInfoURL, accessToken).then(resp => {
+            return new LinkedInUser(resp.response);
+        });
+    };
+    const postLinkedinShare = async (linkedinUser, postText, accessToken) => {
+        const POST_SHARE_REQUEST = {
+            author: linkedinUser.getUrn(),
+            lifecycleState: 'PUBLISHED',
+            specificContent: {
+                'com.linkedin.ugc.ShareContent': {
+                    shareCommentary: {
+                        text: postText,
+                    },
+                    shareMediaCategory: 'NONE',
+                },
+            },
+            visibility: {
+                'com.linkedin.ugc.MemberNetworkVisibility': 'PUBLIC',
+            },
+        };
+        return proxyPOST(IAMProvidersSpecs.LinkedIn.postShareURL, POST_SHARE_REQUEST, accessToken);
+    };
+    const postLinkedinShareWithUpload = async (linkedinUser, postText, uploadObject, accessToken) => {
+        const REGISTER_UPLOAD_REQUEST = {
+            registerUploadRequest: {
+                recipes: ['urn:li:digitalmediaRecipe:feedshare-image'],
+                owner: linkedinUser.getUrn(),
+                serviceRelationships: [
+                    {
+                        relationshipType: 'OWNER',
+                        identifier: 'urn:li:userGeneratedContent',
+                    },
+                ],
+            },
+        };
+        return proxyPOST(IAMProvidersSpecs.LinkedIn.registerUploadURL, REGISTER_UPLOAD_REQUEST, accessToken).then(registerUploadReponse => {
+            /*
+              {
+                "value": {
+                    "uploadMechanism": {
+                        "com.linkedin.digitalmedia.uploading.MediaUploadHttpRequest": {
+                            "headers": {},
+                            "uploadUrl": "https://api.linkedin.com/mediaUpload/C5522AQGTYER3k3ByHQ/feedshare-uploadedImage/0?ca=vector_feedshare&cn=uploads&m=AQJbrN86Zm265gAAAWemyz2pxPSgONtBiZdchrgG872QltnfYjnMdb2j3A&app=1953784&sync=0&v=beta&ut=2H-IhpbfXrRow1"
+                        }
+                    },
+                    "mediaArtifact": "urn:li:digitalmediaMediaArtifact:(urn:li:digitalmediaAsset:C5522AQGTYER3k3ByHQ,urn:li:digitalmediaMediaArtifactClass:feedshare-uploadedImage)",
+                    "asset": "urn:li:digitalmediaAsset:C5522AQGTYER3k3ByHQ"
+                }
+              }
+              */
+            const asset = registerUploadReponse.response.value.asset;
+            const uploadURL = registerUploadReponse.response.value.uploadMechanism['com.linkedin.digitalmedia.uploading.MediaUploadHttpRequest'].uploadUrl;
+            const UPLOAD_OBJECT_REQUEST = {
+                uploadURL: uploadURL,
+                content: uploadObject,
+                userURN: linkedinUser.getUrn(),
+            };
+            return proxyPUT(uploadURL, UPLOAD_OBJECT_REQUEST, accessToken).then(resp => {
+                const share = {
+                    author: linkedinUser.getUrn(),
+                    lifecycleState: 'PUBLISHED',
+                    specificContent: {
+                        'com.linkedin.ugc.ShareContent': {
+                            shareCommentary: {
+                                text: postText,
+                            },
+                            shareMediaCategory: 'IMAGE',
+                            media: [
+                                {
+                                    status: 'READY',
+                                    description: {
+                                        text: 'Datalayer Notebook',
+                                    },
+                                    media: asset,
+                                    title: {
+                                        text: 'Datalayer Notebook',
+                                    },
+                                },
+                            ],
+                        },
+                    },
+                    visibility: {
+                        'com.linkedin.ugc.MemberNetworkVisibility': 'PUBLIC',
+                    },
+                };
+                return proxyPOST(IAMProvidersSpecs.LinkedIn.postShareURL, share, accessToken);
+            });
+        });
+    };
+    // Proxy -------------------------------------------------------------------
+    const proxyGET = async (url, token) => {
+        return requestDatalayer({
+            url: URLExt.join(configuration.iamRunUrl, 'api/iam/v1/proxy/request'),
+            method: 'POST',
+            body: {
+                request_method: 'GET',
+                request_url: url,
+                request_token: token,
+            },
+        });
+    };
+    const proxyPOST = async (url, body, token) => {
+        return requestDatalayer({
+            url: URLExt.join(configuration.iamRunUrl, 'api/iam/v1/proxy/request'),
+            method: 'POST',
+            body: {
+                request_method: 'POST',
+                request_url: url,
+                request_token: token,
+                request_body: body,
+            },
+        });
+    };
+    const proxyPUT = async (url, body, token) => {
+        return requestDatalayer({
+            url: URLExt.join(configuration.iamRunUrl, 'api/iam/v1/proxy/request'),
+            method: 'POST',
+            body: {
+                request_method: 'PUT',
+                request_url: url,
+                request_token: token,
+                request_body: body,
+            },
+        });
+    };
+    // Waiting List -------------------------------------------------------------
+    const registerToWaitingList = (formData) => {
+        requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/waitinglist/register`,
+            method: 'POST',
+            body: {
+                firstName: formData.firstName,
+                lastName: formData.lastName,
+                email: formData.email,
+                affiliation: formData.affiliation || '',
+            },
+        })
+            .then(resp => {
+            // Special case, make the error very explicit to the user...
+            if (!resp.success) {
+                alert('Sorry, something has gone wrong... Please send an email to eric@datalayer.io to register to the waiting list.');
+            }
+        })
+            .catch(err => {
+            // Special case, make the error very explicit to the user...
+            console.error(err);
+            alert('Sorry, something has gone wrong... Please send an email to eric@datalayer.io to register to the waiting list.');
+        });
+    };
+    // Profile ------------------------------------------------------------------
+    const getMe = async (token) => {
+        const resp = await requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/me`,
+            method: 'GET',
+            token,
+        });
+        const me = resp.me;
+        if (me) {
+            const user = asUser(me);
+            return user;
+        }
+        return null;
+    };
+    const updateMe = (email, firstName, lastName) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/me`,
+            method: 'PUT',
+            body: {
+                email,
+                firstName,
+                lastName,
+            },
+        });
+    };
+    const whoami = () => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/whoami`,
+            method: 'GET',
+        });
+    };
+    const requestEmailUpdate = email => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/me/email`,
+            method: 'PUT',
+            body: {
+                email,
+            },
+        });
+    };
+    const confirmEmailUpdate = token => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/me/email`,
+            method: 'POST',
+            body: {
+                token,
+            },
+        });
+    };
+    // Onboarding ---------------------------------------------------------------
+    const updateUserOnboarding = (onboarding) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/onboardings`,
+            method: 'PUT',
+            body: {
+                onboarding,
+            },
+        });
+    };
+    // Settings -----------------------------------------------------------------
+    const updateUserSettings = (userId, settings) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/users/${userId}/settings`,
+            method: 'PUT',
+            body: {
+                aiagents_url_s: settings.aiAgentsUrl,
+                can_invite_b: settings.canInvite || false,
+            },
+        });
+    };
+    // Pages ------------------------------------------------------------------
+    const toPage = (s) => {
+        if (s) {
+            const page = asPage(s);
+            PAGES_BY_ID.set(s.uid, page);
+            return page;
+        }
+    };
+    const createPage = (page) => {
+        return requestDatalayer({
+            url: `${configuration.libraryRunUrl}/api/library/v1/pages`,
+            method: 'POST',
+            body: { ...page },
+        }).then(resp => {
+            if (resp.success) {
+                if (resp.page) {
+                    const pageId = resp.page.uid;
+                    PAGES_BY_ID.set(pageId, {
+                        ...page,
+                        id: pageId,
+                    });
+                }
+            }
+            return resp;
+        });
+    };
+    const updatePage = (page) => {
+        return requestDatalayer({
+            url: `${configuration.libraryRunUrl}/api/library/v1/pages/${page.id}`,
+            method: 'PUT',
+            body: {
+                name: page.name,
+                description: page.description,
+                tags: page.tags,
+            },
+        }).then(resp => {
+            if (resp.success) {
+                if (resp.page) {
+                    toPage(resp.page);
+                }
+            }
+            return resp;
+        });
+    };
+    const deletePage = (page) => {
+        return requestDatalayer({
+            url: `${configuration.libraryRunUrl}/api/library/v1/pages/${page.id}`,
+            method: 'DELETE',
+        });
+    };
+    const getPage = (pageId) => PAGES_BY_ID.get(pageId);
+    const clearCachedPages = () => PAGES_BY_ID.clear();
+    const refreshPage = (pageId) => {
+        return requestDatalayer({
+            url: `${configuration.libraryRunUrl}/api/library/v1/pages/${pageId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                if (resp.page) {
+                    toPage(resp.page);
+                }
+            }
+            return resp;
+        });
+    };
+    const getPages = () => {
+        return Array.from(PAGES_BY_ID.values());
+    };
+    const refreshPages = () => {
+        return requestDatalayer({
+            url: `${configuration.libraryRunUrl}/api/library/v1/pages`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const pages = resp.pages;
+                if (pages) {
+                    PAGES_BY_ID.clear();
+                    pages.forEach(page => {
+                        toPage(page);
+                    });
+                }
+            }
+            return resp;
+        });
+    };
+    // Datasources ------------------------------------------------------------------
+    const toDatasource = (s) => {
+        if (s) {
+            const datasource = asDatasource(s);
+            DATASOURCES_BY_ID.set(s.uid, datasource);
+            return datasource;
+        }
+    };
+    const createDatasource = (datasource) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/datasources`,
+            method: 'POST',
+            body: { ...datasource },
+        }).then(resp => {
+            if (resp.success) {
+                if (resp.datasource) {
+                    toDatasource(resp.datasource);
+                }
+            }
+            return resp;
+        });
+    };
+    const updateDatasource = (datasource) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/datasources/${datasource.id}`,
+            method: 'PUT',
+            body: { ...datasource },
+        }).then(resp => {
+            if (resp.success) {
+                if (resp.datasource) {
+                    toDatasource(resp.datasource);
+                }
+            }
+            return resp;
+        });
+    };
+    const getDatasource = (datasourceId) => DATASOURCES_BY_ID.get(datasourceId);
+    const clearCachedDatasources = () => DATASOURCES_BY_ID.clear();
+    const refreshDatasource = (datasourceId) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/datasources/${datasourceId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                if (resp.datasource) {
+                    toDatasource(resp.datasource);
+                }
+            }
+            return resp;
+        });
+    };
+    const getDatasources = () => {
+        return Array.from(DATASOURCES_BY_ID.values());
+    };
+    const refreshDatasources = () => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/datasources`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const datasources = resp.datasources;
+                if (datasources) {
+                    SECRETS_BY_ID.clear();
+                    datasources.forEach(datasource => {
+                        toDatasource(datasource);
+                    });
+                }
+            }
+            return resp;
+        });
+    };
+    // Secrets ------------------------------------------------------------------
+    const toSecret = (s) => {
+        if (s) {
+            const secret = asSecret(s);
+            SECRETS_BY_ID.set(s.uid, secret);
+            return secret;
+        }
+    };
+    const createSecret = (secret) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/secrets`,
+            method: 'POST',
+            body: { ...secret },
+        }).then(resp => {
+            if (resp.success) {
+                if (resp.secret) {
+                    toSecret(resp.secret);
+                }
+            }
+            return resp;
+        });
+    };
+    const updateSecret = (secret) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/secrets/${secret.id}`,
+            method: 'PUT',
+            body: { ...secret },
+        }).then(resp => {
+            if (resp.success) {
+                if (resp.secret) {
+                    toSecret(resp.secret);
+                }
+            }
+            return resp;
+        });
+    };
+    const deleteSecret = (secret) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/secrets/${secret.id}`,
+            method: 'DELETE',
+        });
+    };
+    const getSecret = (secretId) => SECRETS_BY_ID.get(secretId);
+    const clearCachedSecrets = () => SECRETS_BY_ID.clear();
+    const refreshSecret = (secretId) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/secrets/${secretId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                if (resp.secret) {
+                    toSecret(resp.secret);
+                }
+            }
+            return resp;
+        });
+    };
+    const getSecrets = () => {
+        return Array.from(SECRETS_BY_ID.values());
+    };
+    const refreshSecrets = () => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/secrets`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const secrets = resp.secrets;
+                if (secrets) {
+                    SECRETS_BY_ID.clear();
+                    secrets.forEach(secret => {
+                        toSecret(secret);
+                    });
+                }
+            }
+            return resp;
+        });
+    };
+    // Tokens ------------------------------------------------------------------
+    const toToken = (s) => {
+        if (s) {
+            const token = asToken(s);
+            TOKENS_BY_ID.set(s.uid, token);
+            return token;
+        }
+    };
+    const createToken = (token) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/tokens`,
+            method: 'POST',
+            body: {
+                ...token,
+                expirationDate: token.expirationDate.getTime(),
+            },
+        }).then(resp => {
+            if (resp.success) {
+                if (resp.token) {
+                    toToken(resp.token);
+                }
+            }
+            return resp;
+        });
+    };
+    const updateToken = (token) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/tokens/${token.id}`,
+            method: 'PUT',
+            body: { ...token },
+        }).then(resp => {
+            if (resp.success) {
+                if (resp.token) {
+                    toToken(resp.token);
+                }
+            }
+            return resp;
+        });
+    };
+    const getToken = (tokenId) => TOKENS_BY_ID.get(tokenId);
+    const clearCachedTokens = () => TOKENS_BY_ID.clear();
+    const refreshToken = (tokenId) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/tokens/${tokenId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                if (resp.token) {
+                    toToken(resp.token);
+                }
+            }
+            return resp;
+        });
+    };
+    const getTokens = () => {
+        return Array.from(TOKENS_BY_ID.values());
+    };
+    const refreshTokens = () => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/tokens`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const tokens = resp.tokens;
+                if (tokens) {
+                    TOKENS_BY_ID.clear();
+                    tokens.forEach(token => {
+                        toToken(token);
+                    });
+                }
+            }
+            return resp;
+        });
+    };
+    // Layout -------------------------------------------------------------------
+    const refreshLayout = (accountHandle, spaceHandle, user) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/layouts/accounts/${accountHandle}${spaceHandle !== undefined ? '/spaces/' + spaceHandle : ''}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                if (resp.user) {
+                    toUser(resp.user);
+                }
+                let organization = undefined;
+                if (resp.organization) {
+                    organization = toOrganization(resp.organization);
+                    if (user && checkIsOrganizationMember(user, organization)) {
+                        ORGANISATIONS_FOR_USER_BY_ID.set(organization.id, organization);
+                    }
+                }
+                if (resp.space) {
+                    const space = toSpace(resp.space);
+                    if (organization) {
+                        let osById = SPACES_BY_ID_BY_ORGANISATION_ID.get(organization.id);
+                        if (!osById) {
+                            osById = new Map();
+                            SPACES_BY_ID_BY_ORGANISATION_ID.set(organization.id, osById);
+                        }
+                        osById.set(space.id, space);
+                        let osByHandle = SPACES_BY_HANDLE_BY_ORGANISATION_HANDLE.get(organization.handle);
+                        if (!osByHandle) {
+                            osByHandle = new Map();
+                            SPACES_BY_HANDLE_BY_ORGANISATION_HANDLE.set(organization.handle, osByHandle);
+                        }
+                        osByHandle.set(space.handle, space);
+                    }
+                    else {
+                        SPACES_FOR_USER_BY_HANDLE.set(space.handle, space);
+                        SPACES_FOR_USER_BY_ID.set(space.id, space);
+                    }
+                }
+            }
+            return resp;
+        });
+    };
+    // Invites -------------------------------------------------------------------
+    const requestInvite = (firstName, lastName, email, socialUrl) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/invites/request`,
+            method: 'POST',
+            body: {
+                first_name: firstName,
+                last_name: lastName,
+                email: email,
+                social_url: socialUrl,
+            },
+        });
+    };
+    const sendInvite = (invite) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/invites`,
+            method: 'POST',
+            body: {
+                email: invite.to.email,
+                firstName: invite.to.firstName,
+                lastName: invite.to.lastName,
+                message: invite.message,
+                brand: invite.brand,
+            },
+        });
+    };
+    const getInvite = (token) => INVITES_BY_TOKEN.get(token);
+    const clearCachedInvites = () => INVITES_BY_TOKEN.clear();
+    const refreshInvite = (token) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/invites/tokens/${token}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const i = resp.invite;
+                if (i) {
+                    const invite = asInvite(i);
+                    if (invite.token) {
+                        INVITES_BY_TOKEN.set(invite.token, invite);
+                    }
+                }
+            }
+            return resp;
+        });
+    };
+    const getInvites = () => {
+        return Array.from(INVITES_BY_TOKEN.values());
+    };
+    const refreshInvites = (accountId) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/invites/users/${accountId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.invites.forEach(i => {
+                    const invite = asInvite(i);
+                    if (invite.token) {
+                        INVITES_BY_TOKEN.set(invite.token, invite);
+                    }
+                });
+            }
+            return resp;
+        });
+    };
+    const putInvite = (token) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/invites/tokens/${token}`,
+            method: 'PUT',
+        });
+    };
+    // Accounts -------------------------------------------------------------------
+    const refreshAccount = (accountHandle) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/accounts/${accountHandle}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                if (resp.user) {
+                    toUser(resp.user);
+                }
+                if (resp.organization) {
+                    toOrganization(resp.organization);
+                }
+            }
+            return resp;
+        });
+    };
+    // Contacts ---------------------------------------------------------------------
+    const toContact = (c) => {
+        if (c) {
+            const contact = asContact(c);
+            CONTACTS_BY_ID.set(contact.id, contact);
+            CONTACTS_BY_HANDLE.set(contact.handle, contact);
+            return contact;
+        }
+    };
+    const getContactById = (contactId) => CONTACTS_BY_ID.get(contactId);
+    const getContactByHandle = (contactHandle) => CONTACTS_BY_HANDLE.get(contactHandle);
+    const createContact = (contact) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/contacts`,
+            method: 'POST',
+            body: {
+                contact,
+            },
+        }).then(resp => {
+            if (resp.success) {
+                toContact(resp.contact);
+            }
+            return resp;
+        });
+    };
+    const updateContact = (contactId, contact) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}`,
+            method: 'PUT',
+            body: {
+                contact,
+            },
+        }).then(resp => {
+            if (resp.success) {
+                toContact(resp.contact);
+            }
+            return resp;
+        });
+    };
+    const refreshContact = (contactId) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                toContact(resp.contact);
+            }
+            return resp;
+        });
+    };
+    const searchContacts = (query) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/search`,
+            method: 'POST',
+            body: {
+                query,
+            },
+        }).then(resp => {
+            if (resp.success) {
+                const contacts = resp.contacts.map(contact => toContact(contact));
+                resp.contacts = contacts;
+            }
+            return resp;
+        });
+    };
+    const assignTagToContact = (contactId, tagName) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}/tags/${tagName}`,
+            method: 'POST',
+        });
+    };
+    const unassignTagFromContact = (contactId, tagName) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}/tags/${tagName}`,
+            method: 'DELETE',
+        });
+    };
+    const deleteContact = (contactId) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}`,
+            method: 'DELETE',
+        });
+    };
+    const sendInviteToContact = (contact, message) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/invites`,
+            method: 'POST',
+            body: {
+                contactId: contact.id,
+                message,
+            },
+        });
+    };
+    // Contacts Enrich ----------------------------------------------------------
+    const enrichContactEmail = (contactId, useDomain) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}/enrich/email?useDomain=${useDomain}`,
+            method: 'GET',
+        });
+    };
+    const enrichContactLinkedin = contactId => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contactId}/enrich/linkedin`,
+            method: 'GET',
+        });
+    };
+    const sendLinkedinConnectionRequest = (contact, message) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/${contact.id}/connect/linkedin`,
+            method: 'POST',
+            body: {
+                message,
+            },
+        }).then(resp => {
+            if (resp.success) {
+                toContact(resp.contact);
+            }
+            return resp;
+        });
+    };
+    // Contacts Links -----------------------------------------------------------
+    const linkUserWithContact = (userId, contactId) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/users/${userId}/contacts/${contactId}/link`,
+            method: 'POST',
+        });
+    };
+    const unlinkUserFromContact = (userId, contactId) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/users/${userId}/contacts/${contactId}/link`,
+            method: 'DELETE',
+        });
+    };
+    // Users --------------------------------------------------------------------
+    const toUser = (u) => {
+        if (u) {
+            const user = asUser(u);
+            USERS_BY_ID.set(user.id, user);
+            USERS_BY_HANDLE.set(user.handle, user);
+            return user;
+        }
+    };
+    const getUser = (id) => USERS_BY_ID.get(id);
+    const getUserByHandle = (handle) => USERS_BY_HANDLE.get(handle);
+    const refreshUser = (userId) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/users/${userId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                toUser(resp.user);
+            }
+            return resp;
+        });
+    };
+    const searchUsers = (namingPattern) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/users/search`,
+            method: 'POST',
+            body: {
+                namingPattern,
+            },
+        }).then(resp => {
+            if (resp.success) {
+                const users = resp.users.map(user => toUser(user));
+                resp.users = users;
+            }
+            return resp;
+        });
+    };
+    // User Roles ---------------------------------------------------------------
+    const assignRoleToUser = (userId, roleName) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/users/${userId}/roles/${roleName}`,
+            method: 'POST',
+        });
+    };
+    const unassignRoleFromUser = (userId, roleName) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/users/${userId}/roles/${roleName}`,
+            method: 'DELETE',
+        });
+    };
+    // Organizations -------------------------------------------------------------------
+    const toOrganization = (org) => {
+        const organization = asOrganization(org);
+        ORGANISATIONS_BY_ID.set(organization.id, organization);
+        ORGANISATIONS_BY_HANDLE.set(organization.handle, organization);
+        return organization;
+    };
+    const createOrganization = (organization) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/organizations`,
+            method: 'POST',
+            body: {
+                handle: organization.handle,
+                name: organization.name,
+                description: organization.description,
+            },
+        }).then(resp => {
+            const organization = toOrganization(resp.organization);
+            ORGANISATIONS_FOR_USER_BY_ID.set(organization.id, organization);
+            return resp;
+        });
+    };
+    const getOrganizationById = (organizationId) => ORGANISATIONS_BY_ID.get(organizationId);
+    const getOrganizationByHandle = (organizationHandle) => ORGANISATIONS_BY_HANDLE.get(organizationHandle);
+    const clearCachedOrganizations = () => {
+        ORGANISATIONS_BY_HANDLE.clear();
+        ORGANISATIONS_BY_ID.clear();
+        ORGANISATIONS_FOR_USER_BY_ID.clear();
+    };
+    const refreshOrganization = (user, organizationId) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const org = resp.organization;
+                if (org) {
+                    const organization = toOrganization(org);
+                    if (checkIsOrganizationMember(user, organization)) {
+                        ORGANISATIONS_FOR_USER_BY_ID.set(organizationId, organization);
+                    }
+                }
+            }
+            return resp;
+        });
+    };
+    const updateOrganization = (organization) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organization.id}`,
+            method: 'PUT',
+            body: {
+                name: organization.name,
+                description: organization.description,
+            },
+        }).then(resp => {
+            if (resp.success) {
+                const org = getOrganizationById(organization.id);
+                if (org) {
+                    org.name = organization.name;
+                    org.description = organization.description;
+                }
+            }
+            return resp;
+        });
+    };
+    const getUserOrganizations = () => Array.from(ORGANISATIONS_FOR_USER_BY_ID.values());
+    const getUserOrganizationById = (organizationId) => ORGANISATIONS_FOR_USER_BY_ID.get(organizationId);
+    const refreshUserOrganizations = (user) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/organizations`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.organizations.forEach(org => {
+                    const organization = toOrganization(org);
+                    if (checkIsOrganizationMember(user, organization)) {
+                        ORGANISATIONS_FOR_USER_BY_ID.set(organization.id, organization);
+                    }
+                });
+            }
+            return resp;
+        });
+    };
+    const addMemberToOrganization = (organizationId, userId) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}/members/${userId}`,
+            method: 'POST',
+        });
+    };
+    const removeMemberFromOrganization = (organizationId, userId) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}/members/${userId}`,
+            method: 'DELETE',
+        });
+    };
+    const addRoleToOrganizationMember = (organizationId, userId, roleName) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}/members/${userId}/roles/${roleName}`,
+            method: 'POST',
+        });
+    };
+    const removeRoleFromOrganizationMember = (organizationId, userId, roleName) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}/members/${userId}/roles/${roleName}`,
+            method: 'DELETE',
+        });
+    };
+    // Teams -------------------------------------------------------------------
+    const toTeam = (org, organizationId) => {
+        const team = asTeam(org, organizationId);
+        TEAMS_BY_ID.set(team.id, team);
+        TEAMS_BY_HANDLE.set(team.handle, team);
+        return team;
+    };
+    const createTeam = (team, organization) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/teams`,
+            method: 'POST',
+            body: {
+                handle: team.handle,
+                name: team.name,
+                description: team.description,
+                organizationId: organization.id,
+            },
+        }).then(resp => {
+            const team = toTeam(resp.team, organization.id);
+            TEAMS_BY_HANDLE.set(team.handle, team);
+            TEAMS_BY_ID.set(team.id, team);
+            return resp;
+        });
+    };
+    const getTeamById = (teamId) => TEAMS_BY_ID.get(teamId);
+    const getTeamByHandle = (teamHandle) => TEAMS_BY_HANDLE.get(teamHandle);
+    const clearCachedTeams = () => {
+        TEAMS_BY_HANDLE.clear();
+        TEAMS_BY_ID.clear();
+    };
+    const refreshTeam = (teamId, organizationId) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const t = resp.team;
+                if (t) {
+                    const team = toTeam(t, organizationId);
+                    TEAMS_BY_HANDLE.set(team.handle, team);
+                    TEAMS_BY_ID.set(team.id, team);
+                }
+            }
+            return resp;
+        });
+    };
+    const updateTeam = (team) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/teams/${team.id}`,
+            method: 'PUT',
+            body: {
+                name: team.name,
+                description: team.description,
+            },
+        }).then(resp => {
+            if (resp.success) {
+                const t = resp.team;
+                if (t) {
+                    const tt = toTeam(t, team.organization.id);
+                    TEAMS_BY_HANDLE.set(team.handle, tt);
+                    TEAMS_BY_ID.set(team.id, tt);
+                }
+            }
+            return resp;
+        });
+    };
+    const getTeamsByOrganizationId = (organizationId) => TEAMS_BY_ORGANIZATION_BY_ID.get(organizationId);
+    const refreshTeams = (organizationId) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/${organizationId}/teams`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const teams = resp.teams.map(t => {
+                    const team = toTeam(t, organizationId);
+                    TEAMS_BY_HANDLE.set(team.handle, team);
+                    TEAMS_BY_ID.set(team.id, team);
+                    return team;
+                });
+                TEAMS_BY_ORGANIZATION_BY_ID.set(organizationId, teams);
+            }
+            return resp;
+        });
+    };
+    const addMemberToTeam = (teamId, userId) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}/members/${userId}`,
+            method: 'POST',
+        });
+    };
+    const removeMemberFromTeam = (teamId, userId) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}/members/${userId}`,
+            method: 'DELETE',
+        });
+    };
+    const addRoleToTeamMember = (teamId, userId, roleName) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}/members/${userId}/roles/${roleName}`,
+            method: 'POST',
+        });
+    };
+    const removeRoleFromTeamMember = (teamId, userId, roleName) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/teams/${teamId}/members/${userId}/roles/${roleName}`,
+            method: 'DELETE',
+        });
+    };
+    // Schools -------------------------------------------------------------------
+    const getSchools = () => {
+        return Array.from(SCHOOLS_BY_ID.values());
+    };
+    const refreshSchools = () => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/organizations/schools`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.orgs.forEach(s => {
+                    const dean = undefined;
+                    const students = new Array();
+                    const members = new Array();
+                    const courses = new Array();
+                    const school = {
+                        id: s.uid,
+                        type: 'school',
+                        handle: s.handle_s,
+                        name: s.name_t,
+                        description: s.description_t,
+                        dean,
+                        members,
+                        students,
+                        courses,
+                        public: s.public_b,
+                        creationDate: new Date(s.creation_ts_dt),
+                        setMembers(members) {
+                            this.members = members;
+                        },
+                    };
+                    SCHOOLS_BY_ID.set(school.id, school);
+                });
+            }
+            return resp;
+        });
+    };
+    // Spaces -------------------------------------------------------------------
+    const toSpace = (spc) => {
+        const space = asSpace(spc);
+        return space;
+    };
+    const createSpace = (space, organization) => {
+        const seedSpaceId = space.variant === 'course' ? space.seedSpace?.id : undefined;
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces`,
+            method: 'POST',
+            body: {
+                name: space.name,
+                description: space.description,
+                variant: space.variant,
+                public: space.public,
+                spaceHandle: space.handle,
+                organizationId: organization?.id,
+                seedSpaceId,
+            },
+        }).then(resp => {
+            const spc = resp.space;
+            if (spc) {
+                const space = toSpace(spc);
+                if (organization) {
+                    let os = SPACES_BY_ID_BY_ORGANISATION_ID.get(organization.id);
+                    if (!os) {
+                        os = new Map();
+                        SPACES_BY_ID_BY_ORGANISATION_ID.set(organization.id, os);
+                    }
+                    os.set(space.id, space);
+                }
+                else {
+                    SPACES_FOR_USER_BY_HANDLE.set(space.handle, space);
+                    SPACES_FOR_USER_BY_ID.set(space.id, space);
+                }
+            }
+            return resp;
+        });
+    };
+    const getOrganizationSpace = (organizationId, spaceId) => {
+        const organizationSpaces = SPACES_BY_ID_BY_ORGANISATION_ID.get(organizationId);
+        return organizationSpaces ? organizationSpaces.get(spaceId) : undefined;
+    };
+    const getOrganizationSpaceByHandle = (organizationHandle, spaceHandle) => {
+        const organizationSpaces = SPACES_BY_HANDLE_BY_ORGANISATION_HANDLE.get(organizationHandle);
+        return organizationSpaces ? organizationSpaces.get(spaceHandle) : undefined;
+    };
+    const refreshOrganizationSpace = (organizationId, spaceId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/organizations/${organizationId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const spc = resp.space;
+                if (spc) {
+                    const space = toSpace(spc);
+                    let os = SPACES_BY_ID_BY_ORGANISATION_ID.get(organizationId);
+                    if (!os) {
+                        os = new Map();
+                        SPACES_BY_ID_BY_ORGANISATION_ID.set(organizationId, os);
+                    }
+                    os.set(space.id, space);
+                }
+            }
+            return resp;
+        });
+    };
+    const exportSpace = (spaceId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/export`,
+            method: 'GET',
+        });
+    };
+    const updateOrganizationSpace = (organization, space) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/organizations/${organization.id}`,
+            method: 'PUT',
+            body: {
+                name: space.name,
+                description: space.description,
+            },
+        }).then(resp => {
+            if (resp.success) {
+                const spc = getOrganizationSpace(organization.id, space.id);
+                if (spc) {
+                    spc.name = space.name;
+                    spc.description = space.description;
+                }
+            }
+            return resp;
+        });
+    };
+    const getOrganizationSpaces = (organizationId) => {
+        const spaces = SPACES_BY_ID_BY_ORGANISATION_ID.get(organizationId);
+        if (spaces) {
+            return Array.from(spaces.values());
+        }
+        return [];
+    };
+    const refreshOrganizationSpaces = (organizationId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/organizations/${organizationId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.spaces.forEach(org => {
+                    const space = toSpace(org);
+                    let organizationSpaces = SPACES_BY_ID_BY_ORGANISATION_ID.get(organizationId);
+                    if (!organizationSpaces) {
+                        organizationSpaces = new Map();
+                        SPACES_BY_ID_BY_ORGANISATION_ID.set(organizationId, organizationSpaces);
+                    }
+                    organizationSpaces.set(space.id, space);
+                });
+            }
+            return resp;
+        });
+    };
+    const getUserSpaces = () => Array.from(SPACES_FOR_USER_BY_ID.values());
+    const refreshUserSpaces = () => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/users/me`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.spaces.forEach(spc => {
+                    const space = toSpace(spc);
+                    SPACES_FOR_USER_BY_HANDLE.set(space.handle, space);
+                    SPACES_FOR_USER_BY_ID.set(space.id, space);
+                });
+            }
+            return resp;
+        });
+    };
+    const getUserSpace = (userId) => SPACES_FOR_USER_BY_ID.get(userId);
+    const getUserSpaceByHandle = (userHandle) => SPACES_FOR_USER_BY_HANDLE.get(userHandle);
+    const refreshUserSpace = (userId, spaceId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/users/${userId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const spc = resp.space;
+                if (spc) {
+                    const space = toSpace(spc);
+                    SPACES_FOR_USER_BY_HANDLE.set(space.handle, space);
+                    SPACES_FOR_USER_BY_ID.set(spaceId, space);
+                }
+            }
+            return resp;
+        });
+    };
+    const updateSpace = (space) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/users/${user?.id}`,
+            method: 'PUT',
+            body: {
+                name: space.name,
+                description: space.description,
+            },
+        }).then(resp => {
+            if (resp.success) {
+                const spc = getUserSpace(space.id);
+                if (spc) {
+                    spc.name = space.name;
+                    spc.description = space.description;
+                }
+            }
+            return resp;
+        });
+    };
+    const addMemberToOrganizationSpace = (organizationId, spaceId, accountId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/organizations/${organizationId}/members/${accountId}`,
+            method: 'POST',
+        });
+    };
+    const removeMemberFromOrganizationSpace = (organizationId, spaceId, accountId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/organizations/${organizationId}/members/${accountId}`,
+            method: 'DELETE',
+        }).then(resp => {
+            //      if (resp.success) {
+            //        OR.delete(accountHandle);
+            //      }
+            return resp;
+        });
+    };
+    const makeSpacePublic = (spaceId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/public`,
+            method: 'PUT',
+        });
+    };
+    const makeSpacePrivate = (spaceId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/private`,
+            method: 'PUT',
+        });
+    };
+    // Courses -------------------------------------------------------------------
+    const toStudentItem = (raw_student_item, itemId) => {
+        const studentItem = {
+            id: raw_student_item.uid,
+            type: 'student_item',
+            student: user,
+            points: raw_student_item.points_i ?? 0,
+            completed: raw_student_item.completed_b,
+            itemId,
+            itemType: raw_student_item.item_type_s,
+            pass: raw_student_item.pass_b,
+            codeStudent: raw_student_item.code_student_t,
+            invalid: raw_student_item.invalid_b,
+            invalidReason: raw_student_item.invalid_reason_t,
+            nbgrades: raw_student_item.nbgrades,
+            nbgradesTotalPoints: raw_student_item.nbgrades_total_points_f,
+            nbgradesTotalScore: raw_student_item.nbgrades_total_score_f,
+        };
+        return studentItem;
+    };
+    const toStudent = (raw_student, courseId) => {
+        let student = undefined;
+        if (raw_student) {
+            const user = toUser(raw_student);
+            if (user) {
+                let studentItems;
+                if (raw_student.student_items) {
+                    studentItems = new Map();
+                    raw_student.student_items.forEach(raw_student_item => {
+                        const itemId = raw_student_item.item_uid;
+                        const studentItem = toStudentItem(raw_student_item, itemId);
+                        studentItems?.set(itemId, studentItem);
+                    });
+                }
+                student = {
+                    ...user,
+                    studentItems,
+                };
+                STUDENTS_BY_ID.set(courseId + '-' + student.id, student);
+            }
+        }
+        return student;
+    };
+    const toCourse = (raw_course, cache) => {
+        const owner = newUserMock();
+        USERS_BY_ID.set(owner.id, owner);
+        let instructor = undefined;
+        if (raw_course.members) {
+            let raw_instructor = raw_course.members;
+            if (Array.isArray(raw_instructor)) {
+                raw_instructor = raw_instructor[0];
+            }
+            instructor = {
+                id: raw_instructor.uid,
+                handle: raw_instructor.handle_s,
+                email: raw_instructor.email_s,
+                firstName: raw_instructor.first_name_t,
+                lastName: raw_instructor.last_name_t,
+                initials: namesAsInitials(raw_instructor.to_first_name_t, raw_instructor.to_last_name_t),
+                displayName: asDisplayName(raw_instructor.first_name_t, raw_instructor.last_name_t),
+                roles: [],
+                iamProviders: [],
+                setRoles: (roles) => { },
+                unsubscribedFromOutbounds: false,
+                onboarding: BOOTSTRAP_USER_ONBOARDING,
+                linkedContactId: undefined,
+                events: [],
+                settings: {},
+            };
+            USERS_BY_ID.set(instructor.id, instructor);
+        }
+        let students = undefined;
+        if (raw_course.students) {
+            students = new Map();
+            raw_course.students.forEach(raw_stud => {
+                const student = toStudent(raw_stud, raw_course.uid);
+                if (student) {
+                    students.set(student.id, student);
+                }
+            });
+        }
+        let itemIds = new Array();
+        let raw_item_uids = raw_course.item_uids_s;
+        if (raw_item_uids && raw_item_uids !== '()') {
+            raw_item_uids = raw_item_uids.replace('(', '').replace(')', '');
+            itemIds = raw_item_uids.split(' ');
+        }
+        const items = new Array();
+        if (raw_course.items) {
+            raw_course.items.forEach(item => {
+                const i = toItem(item);
+                items.push(i);
+            });
+        }
+        const course = {
+            id: raw_course.uid,
+            handle: raw_course.handle_s,
+            type: 'space',
+            variant: 'course',
+            name: raw_course.name_t,
+            description: raw_course.description_t,
+            creationDate: new Date(raw_course.creation_ts_dt),
+            public: raw_course.public_b ?? false,
+            items,
+            itemIds,
+            instructor,
+            students,
+            owner,
+        };
+        cache.set(course.id, course);
+        return course;
+    };
+    const getCourse = (courseId) => COURSES_BY_ID.get(courseId);
+    const updateCourse = (courseId, name, description) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}`,
+            method: 'PUT',
+            body: {
+                name,
+                description,
+            },
+        });
+    };
+    const refreshCourse = (courseId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const raw_course = resp.course;
+                if (raw_course) {
+                    toCourse(raw_course, COURSES_BY_ID);
+                }
+            }
+            return resp;
+        });
+    };
+    const enrollStudentToCourse = (courseId, studentId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}/enrollments/students/${studentId}`,
+            method: 'POST',
+        });
+    };
+    const removeStudentFromCourse = (courseId, studentId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}/enrollments/students/${studentId}`,
+            method: 'DELETE',
+        }).then(resp => {
+            if (resp.success) {
+                STUDENTS_BY_ID.delete(courseId);
+            }
+            return resp;
+        });
+    };
+    const getStudent = (courseId, studentId) => STUDENTS_BY_ID.get(courseId + '-' + studentId);
+    const refreshStudent = (courseId, studentHandle) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}/enrollments/students/${studentHandle}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                toStudent(resp.student, courseId);
+            }
+            return resp;
+        });
+    };
+    const getPublicCourses = () => Array.from(PUBLIC_COURSES_BY_ID.values());
+    const refreshPublicCourses = () => {
+        return requestDatalayer({
+            url: `${configuration.libraryRunUrl}/api/library/v1/courses/public`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.courses.forEach(course => {
+                    toCourse(course, PUBLIC_COURSES_BY_ID);
+                });
+            }
+            return resp;
+        });
+    };
+    const getInstructorCourses = () => Array.from(COURSES_INSTRUCTORS_BY_ID.values());
+    const refreshInstructorCourses = () => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/instructors/${user?.id}/courses`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.courses.forEach(course => {
+                    toCourse(course, COURSES_INSTRUCTORS_BY_ID);
+                });
+            }
+            return resp;
+        });
+    };
+    const getCoursesEnrollments = () => Array.from(COURSES_ENROLLMENTS_BY_ID.values());
+    const refreshCoursesEnrollments = () => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/enrollments/me`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.enrollments.forEach(enrollment => {
+                    toCourse(enrollment, COURSES_ENROLLMENTS_BY_ID);
+                });
+            }
+            return resp;
+        });
+    };
+    const confirmCourseItemCompletion = (courseId, itemType, itemId, completed) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${courseId}/types/${itemType}/items/${itemId}/complete`,
+            method: 'PUT',
+            body: {
+                completed,
+            },
+        });
+    };
+    const setCourseItems = (courseId, itemIds) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/courses/${courseId}/items`,
+            method: 'PUT',
+            body: {
+                itemIds,
+            },
+        });
+    };
+    // Surveys ---------------------------------------------------------------------
+    const getUserSurveys = (userId) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/surveys/users/${userId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success && resp.surveys) {
+                const surveyArray = resp.surveys.map(survey => asSurvey(survey));
+                const surveysMap = new Map();
+                surveyArray.forEach(survey => surveysMap.set(survey.name, survey));
+                resp.surveys = surveyArray;
+                resp.surveysMap = surveysMap;
+            }
+            return resp;
+        });
+    };
+    // Inbounds ---------------------------------------------------------------------
+    const toInbound = (u) => {
+        if (u) {
+            const inbound = asInbound(u);
+            INBOUNDS_BY_ID.set(inbound.id, inbound);
+            INBOUNDS_BY_HANDLE.set(inbound.handle, inbound);
+            return inbound;
+        }
+    };
+    const getInbound = (id) => INBOUNDS_BY_ID.get(id);
+    const getInboundByHandle = (handle) => INBOUNDS_BY_HANDLE.get(handle);
+    const refreshInbound = (userId) => {
+        return requestDatalayer({
+            url: `${configuration.inboundsRunUrl}/api/inbounds/v1/inbounds/${userId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                toInbound(resp.user);
+            }
+            return resp;
+        });
+    };
+    const getInbounds = () => {
+        return requestDatalayer({
+            url: `${configuration.inboundsRunUrl}/api/inbounds/v1/inbounds`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const inbounds = resp.inbounds.map(user => toInbound(user));
+                resp.inbounds = inbounds;
+            }
+            return resp;
+        });
+    };
+    // Outbounds ---------------------------------------------------------------------
+    const toOutbound = (u) => {
+        if (u) {
+            const user = asOutbound(u);
+            OUTBOUNDS_BY_ID.set(user.id, user);
+            return user;
+        }
+    };
+    const getOutbound = (id) => OUTBOUNDS_BY_ID.get(id);
+    const refreshOutbound = (outboundId) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/${outboundId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const outbound = toOutbound(resp.outbound);
+                resp.outbound = outbound;
+            }
+            return resp;
+        });
+    };
+    const getOutbounds = () => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const outbounds = resp.outbounds.map(outbound => toOutbound(outbound));
+                resp.outbounds = outbounds;
+            }
+            return resp;
+        });
+    };
+    const draftBulkEmailsOutbounds = (params) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/emails/bulk/draft`,
+            method: 'POST',
+            body: params,
+        });
+    };
+    const tryBulkEmailsOutbounds = (outboundId) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/${outboundId}/try`,
+            method: 'POST',
+            body: {},
+        });
+    };
+    const launchBulkEmailsOutbounds = (outboundId) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/${outboundId}/launch`,
+            method: 'POST',
+            body: {},
+        });
+    };
+    const sendOutboundEmailToUser = (userId, recipient, subject, content) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/email`,
+            method: 'POST',
+            body: {
+                userId,
+                recipient,
+                subject,
+                content,
+            },
+        });
+    };
+    const enableUserMFA = () => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/mfa`,
+            method: 'PUT',
+        });
+    };
+    const disableUserMFA = () => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/mfa`,
+            method: 'DELETE',
+        });
+    };
+    const validateUserMFACode = (userUid, code) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/mfa`,
+            method: 'POST',
+            body: {
+                userUid,
+                code,
+            },
+        });
+    };
+    const subscribeUserToOutbounds = (userId) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/outbounds/users/${userId}`,
+            method: 'PUT',
+        });
+    };
+    const unsubscribeUserFromOutbounds = (userId) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/outbounds/users/${userId}`,
+            method: 'DELETE',
+        });
+    };
+    const unsubscribeContactFromOutbounds = (contactId) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/contacts/unsubscribe/${contactId}`,
+            method: 'GET',
+        });
+    };
+    const unsubscribeInviteeFromOutbounds = (token) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/unsubscribe/${token}`,
+            method: 'GET',
+        });
+    };
+    const deleteOutbound = (outboundId) => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/outbounds/${outboundId}`,
+            method: 'DELETE',
+        });
+    };
+    // Items --------------------------------------------------------------
+    const toItem = (item) => {
+        if (!item.type_s) {
+            console.error('No type_s found on item', item);
+            return {};
+        }
+        switch (item.type_s) {
+            case 'assignment':
+                return toAssignment(item);
+            case 'cell':
+                return toCell(item);
+            case 'dataset':
+                return toDataset(item);
+            case 'document':
+                return toDocument(item);
+            case 'exercise':
+                return toExercise(item);
+            case 'lesson':
+                return toLesson(item);
+            case 'notebook':
+                return toNotebook(item);
+            case 'page':
+                return toPage(item);
+            default:
+                return {};
+        }
+    };
+    const clearCachedPublicItems = () => PUBLIC_ITEMS_BY_ID.clear();
+    const getPublicItems = () => Array.from(PUBLIC_ITEMS_BY_ID.values());
+    const refreshPublicItems = () => {
+        return requestDatalayer({
+            url: `${configuration.libraryRunUrl}/api/library/v1/items/public`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.items.forEach(i => {
+                    const item = toItem(i);
+                    PUBLIC_ITEMS_BY_ID.set(item.id, item);
+                });
+            }
+            return resp;
+        });
+    };
+    const getSpaceItems = () => Array.from(SPACE_ITEMS_CACHE.values());
+    const refreshSpaceItems = (spaceId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${spaceId}/items`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                if (resp.items) {
+                    asArray(resp.items).forEach(itm => {
+                        const item = toItem(itm);
+                        SPACE_ITEMS_CACHE.set(item.id, item);
+                    });
+                }
+            }
+            return resp;
+        });
+    };
+    const makeItemPublic = (id) => {
+        return requestDatalayer({
+            url: `${configuration.libraryRunUrl}/api/library/v1/items/${id}/public`,
+            method: 'PUT',
+        });
+    };
+    const makeItemPrivate = (id) => {
+        return requestDatalayer({
+            url: `${configuration.libraryRunUrl}/api/library/v1/items/${id}/private`,
+            method: 'PUT',
+        });
+    };
+    const deleteItem = (itemId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${itemId}`,
+            method: 'DELETE',
+        }).then(resp => {
+            if (resp.success) {
+                SPACE_ASSIGNMENTS_BY_ID.delete(itemId);
+                SPACE_CELLS_BY_ID.delete(itemId);
+                SPACE_DATASETS_BY_ID.delete(itemId);
+                SPACE_DOCUMENTS_BY_ID.delete(itemId);
+                SPACE_ENVIRONMENTS_BY_ID.delete(itemId);
+                SPACE_EXERCISES_BY_ID.delete(itemId);
+                SPACE_ITEMS_CACHE.delete(itemId);
+                SPACE_LESSONS_BY_ID.delete(itemId);
+                SPACE_NOTEBOOKS_BY_ID.delete(itemId);
+            }
+            return resp;
+        });
+    };
+    // Search ------------------------------------------------------------------
+    const searchPublicItems = (opts = DEFAULT_SEARCH_OPTS) => {
+        const { q, types, max } = opts;
+        const queryArgs = {
+            q,
+            types: `${types.join(' ')}`,
+            max: max.toFixed(0).toString(),
+            public: 'true',
+        };
+        return requestDatalayer({
+            url: `${configuration.libraryRunUrl}/api/library/v1/search${URLExt.objectToQueryString(queryArgs)}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const items = new Array();
+                resp.items.forEach(i => {
+                    const item = toItem(i);
+                    items.push(item);
+                });
+                resp.items = items;
+            }
+            return resp;
+        });
+    };
+    // Datasets ------------------------------------------------------------------
+    const toDataset = raw_dataset => {
+        const owner = newUserMock();
+        USERS_BY_ID.set(owner.id, owner);
+        const dataset = {
+            id: raw_dataset.uid,
+            type: 'dataset',
+            name: raw_dataset.name_t,
+            description: raw_dataset.description_t,
+            fileName: raw_dataset.file_name_s,
+            datasetExtension: raw_dataset.dataset_extension_s,
+            contentLength: raw_dataset.content_length_i,
+            contentType: raw_dataset.content_type_s,
+            mimeType: raw_dataset.mimetype_s,
+            path: raw_dataset.s3_path_s,
+            cdnUrl: raw_dataset.cdn_url_s,
+            creationDate: new Date(raw_dataset.creation_ts_dt),
+            public: raw_dataset.public_b ?? false,
+            lastPublicationDate: raw_dataset.creation_ts_dt
+                ? new Date(raw_dataset.creation_ts_dt)
+                : undefined,
+            owner,
+            space: {
+                handle: raw_dataset.handle_s,
+            },
+            organization: {
+                handle: raw_dataset.handle_s,
+            },
+        };
+        SPACE_DATASETS_BY_ID.set(dataset.id, dataset);
+        return dataset;
+    };
+    const getDataset = id => SPACE_DATASETS_BY_ID.get(id);
+    const refreshDataset = (id) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${id}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const d = resp.item;
+                if (d) {
+                    toDataset(d);
+                }
+            }
+            return resp;
+        });
+    };
+    const getSpaceDatasets = () => Array.from(SPACE_DATASETS_BY_ID.values());
+    const refreshSpaceDatasets = (space, organization) => {
+        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/dataset`;
+        return requestDatalayer({
+            url,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.items.forEach(d => {
+                    toDataset(d);
+                });
+            }
+            return resp;
+        });
+    };
+    const updateDataset = (id, name, description) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/datasets/${id}`,
+            method: 'PUT',
+            body: {
+                name,
+                description,
+            },
+        });
+    };
+    // Cells ------------------------------------------------------------------
+    const toCell = cl => {
+        const owner = newUserMock();
+        USERS_BY_ID.set(owner.id, owner);
+        const cell = {
+            id: cl.uid,
+            type: 'cell',
+            name: cl.name_t,
+            description: cl.description_t,
+            source: cl.source_t,
+            creationDate: new Date(cl.creation_ts_dt),
+            public: cl.public_b ?? false,
+            lastPublicationDate: cl.last_publication_ts_dt
+                ? new Date(cl.last_publication_ts_dt)
+                : undefined,
+            outputshotUrl: cl.outputshot_url_s || '',
+            outputshotData: OUTPUTSHOT_PLACEHOLDER_DEFAULT_SVG,
+            owner,
+            space: {
+                handle: cl.handle_s,
+            },
+            organization: {
+                handle: cl.handle_s,
+            },
+        };
+        SPACE_CELLS_BY_ID.set(cell.id, cell);
+        return cell;
+    };
+    const getCell = (id) => SPACE_CELLS_BY_ID.get(id);
+    const refreshCell = (id) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${id}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const cell = resp.item;
+                if (cell) {
+                    toCell(cell);
+                }
+            }
+            return resp;
+        });
+    };
+    const getSpaceCells = () => Array.from(SPACE_CELLS_BY_ID.values());
+    const refreshSpaceCells = (space, organization) => {
+        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/cell`;
+        return requestDatalayer({
+            url,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.items.forEach(cell => {
+                    toCell(cell);
+                });
+            }
+            return resp;
+        });
+    };
+    const updateCell = (cell) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/cells/${cell.id}`,
+            method: 'PUT',
+            body: cell,
+        });
+    };
+    const cloneCell = (cellId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/cells/${cellId}/clone`,
+            method: 'POST',
+        }).then(resp => {
+            if (resp.success) {
+                toCell(resp.cell);
+            }
+            return resp;
+        });
+    };
+    // Notebooks ------------------------------------------------------------------
+    const toNotebook = raw_notebook => {
+        const owner = newUserMock();
+        USERS_BY_ID.set(owner.id, owner);
+        const notebook = {
+            id: raw_notebook.uid,
+            type: 'notebook',
+            name: raw_notebook.name_t,
+            description: raw_notebook.description_t,
+            nbformat: raw_notebook.model_s
+                ? JSON.parse(raw_notebook.model_s)
+                : undefined,
+            public: raw_notebook.public_b ?? false,
+            creationDate: new Date(raw_notebook.creation_ts_dt),
+            lastUpdateDate: raw_notebook.last_update_ts_dt
+                ? new Date(raw_notebook.last_update_ts_dt)
+                : undefined,
+            lastPublicationDate: raw_notebook.creation_ts_dt
+                ? new Date(raw_notebook.creation_ts_dt)
+                : undefined,
+            datasets: [],
+            owner,
+            space: {
+                handle: raw_notebook.handle_s,
+            },
+            organization: {
+                handle: raw_notebook.handle_s,
+            },
+        };
+        SPACE_NOTEBOOKS_BY_ID.set(notebook.id, notebook);
+        return notebook;
+    };
+    const getNotebook = notebookId => SPACE_NOTEBOOKS_BY_ID.get(notebookId);
+    const refreshNotebook = (notebookId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${notebookId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const notebook = resp.notebook;
+                if (notebook) {
+                    toNotebook(notebook);
+                }
+            }
+            return resp;
+        });
+    };
+    const getSpaceNotebooks = () => Array.from(SPACE_NOTEBOOKS_BY_ID.values());
+    const getSpaceNotebook = id => SPACE_NOTEBOOKS_BY_ID.get(id);
+    const refreshSpaceNotebooks = (space, organization) => {
+        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/notebook`;
+        return requestDatalayer({
+            url,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.items.forEach(n => {
+                    toNotebook(n);
+                });
+            }
+            return resp;
+        });
+    };
+    const cloneNotebook = (notebookId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${notebookId}/clone`,
+            method: 'POST',
+        }).then(resp => {
+            if (resp.success) {
+                toNotebook(resp.notebook);
+            }
+            return resp;
+        });
+    };
+    const createNotebook = async (spaceId, name, description, notebookType = 'notebook') => {
+        // Create FormData for the upload
+        const formData = new FormData();
+        formData.append('spaceId', spaceId);
+        formData.append('notebookType', notebookType);
+        formData.append('name', name);
+        formData.append('description', description || '');
+        try {
+            const resp = await uploadNotebook(formData);
+            if (resp.success) {
+                if (resp.notebook) {
+                    toNotebook(resp.notebook);
+                }
+            }
+            return resp;
+        }
+        catch (error) {
+            console.error('Failed to create notebook:', error);
+            return { success: false, error };
+        }
+    };
+    const updateNotebook = (id, name, description) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${id}`,
+            method: 'PUT',
+            body: {
+                name,
+                description,
+            },
+        });
+    };
+    const updateNotebookModel = (notebookId, nbformat) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${notebookId}/model`,
+            method: 'PUT',
+            body: {
+                nbformat,
+            },
+        });
+    };
+    // Documents ------------------------------------------------------------------
+    const toDocument = doc => {
+        const owner = newUserMock();
+        USERS_BY_ID.set(owner.id, owner);
+        const document = {
+            id: doc.uid,
+            type: 'document',
+            name: doc.name_t,
+            description: doc.description_t,
+            model: doc.model_s ? JSON.parse(doc.model_s) : undefined,
+            public: doc.public_b ?? false,
+            creationDate: new Date(doc.creation_ts_dt),
+            lastUpdateDate: doc.last_update_ts_dt
+                ? new Date(doc.last_update_ts_dt)
+                : undefined,
+            lastPublicationDate: doc.creation_ts_dt
+                ? new Date(doc.creation_ts_dt)
+                : undefined,
+            owner,
+            space: {
+                handle: doc.handle_s,
+            },
+            organization: {
+                handle: doc.handle_s,
+            },
+        };
+        SPACE_DOCUMENTS_BY_ID.set(document.id, document);
+        return document;
+    };
+    const getDocument = id => SPACE_DOCUMENTS_BY_ID.get(id);
+    const refreshDocument = (id) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/lexicals/${id}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const document = resp.document;
+                if (document) {
+                    toDocument(document);
+                }
+            }
+            return resp;
+        });
+    };
+    const getSpaceDocuments = () => Array.from(SPACE_DOCUMENTS_BY_ID.values());
+    const getSpaceDocument = id => SPACE_DOCUMENTS_BY_ID.get(id);
+    const refreshSpaceDocuments = (space, organization) => {
+        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/document`;
+        return requestDatalayer({
+            url,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.items.forEach(n => {
+                    toDocument(n);
+                });
+            }
+            return resp;
+        });
+    };
+    const cloneDocument = (documentId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/lexicals/${documentId}/clone`,
+            method: 'POST',
+        }).then(resp => {
+            if (resp.success) {
+                toDocument(resp.document);
+            }
+            return resp;
+        });
+    };
+    const updateDocument = (id, name, description) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/lexicals/${id}`,
+            method: 'PUT',
+            body: {
+                name,
+                description,
+            },
+        });
+    };
+    const updateDocumentModel = (id, model) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/lexicals/${id}/model`,
+            method: 'PUT',
+            body: {
+                model,
+            },
+        });
+    };
+    // Environments ------------------------------------------------------------------
+    const toEnvironment = (env, cache) => {
+        const owner = newUserMock();
+        USERS_BY_ID.set(owner.id, owner);
+        const environment = {
+            id: env.uid,
+            type: 'environment',
+            name: env.name_t,
+            description: env.description_t,
+            creationDate: new Date(env.creation_ts_dt),
+            public: env.public_b ?? false,
+            lastPublicationDate: env.creation_ts_dt
+                ? new Date(env.creation_ts_dt)
+                : undefined,
+            owner,
+            space: {
+                handle: env.handle_s,
+            },
+            organization: {
+                handle: env.handle_s,
+            },
+        };
+        cache.set(environment.id, environment);
+        return environment;
+    };
+    const getEnvironment = (id) => SPACE_ENVIRONMENTS_BY_ID.get(id);
+    const refreshEnvironment = (id) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${id}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const env = resp.item;
+                if (env) {
+                    toEnvironment(env, SPACE_ENVIRONMENTS_BY_ID);
+                }
+            }
+            return resp;
+        });
+    };
+    const getSpaceEnvironments = () => Array.from(SPACE_ENVIRONMENTS_BY_ID.values());
+    const refreshSpaceEnvironments = (space, organization) => {
+        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/environment`;
+        return requestDatalayer({
+            url,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.items.forEach(d => {
+                    toEnvironment(d, SPACE_ENVIRONMENTS_BY_ID);
+                });
+            }
+            return resp;
+        });
+    };
+    // Lessons ------------------------------------------------------------------
+    const toLesson = raw_lesson => {
+        const owner = newUserMock();
+        USERS_BY_ID.set(owner.id, owner);
+        const lesson = {
+            id: raw_lesson.uid,
+            type: 'lesson',
+            name: raw_lesson.name_t,
+            description: raw_lesson.description_t,
+            nbformat: raw_lesson.model_s ? JSON.parse(raw_lesson.model_s) : undefined,
+            public: raw_lesson.public_b ?? false,
+            creationDate: new Date(raw_lesson.creation_ts_dt),
+            lastUpdateDate: raw_lesson.last_update_ts_dt
+                ? new Date(raw_lesson.last_update_ts_dt)
+                : undefined,
+            lastPublicationDate: raw_lesson.creation_ts_dt
+                ? new Date(raw_lesson.creation_ts_dt)
+                : undefined,
+            owner,
+            space: {
+                handle: raw_lesson.handle_s,
+            },
+            organization: {
+                handle: raw_lesson.handle_s,
+            },
+            datasets: [],
+        };
+        SPACE_LESSONS_BY_ID.set(lesson.id, lesson);
+        return lesson;
+    };
+    const getLesson = id => SPACE_LESSONS_BY_ID.get(id);
+    const refreshLesson = (id) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/lessons/${id}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const lesson = resp.lesson;
+                if (lesson) {
+                    toLesson(lesson);
+                }
+            }
+            return resp;
+        });
+    };
+    const getSpaceLessons = () => Array.from(SPACE_LESSONS_BY_ID.values());
+    const getSpaceLesson = id => SPACE_LESSONS_BY_ID.get(id);
+    const refreshSpaceLessons = (space, organization) => {
+        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/lesson`;
+        return requestDatalayer({
+            url,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.items.forEach(n => {
+                    toLesson(n);
+                });
+            }
+            return resp;
+        });
+    };
+    const cloneLesson = (lessonId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${lessonId}/clone`,
+            method: 'POST',
+        }).then(resp => {
+            if (resp.success) {
+                toLesson(resp.notebook);
+            }
+            return resp;
+        });
+    };
+    // Exercises ------------------------------------------------------------------
+    const toExercise = (ex) => {
+        const owner = newUserMock();
+        USERS_BY_ID.set(owner.id, owner);
+        const exercise = {
+            id: ex.uid,
+            type: 'exercise',
+            name: ex.name_t,
+            description: ex.description_t,
+            help: ex.help_t,
+            codePre: ex.code_pre_t,
+            codeQuestion: ex.code_question_t,
+            codeSolution: ex.code_solution_t,
+            codeTest: ex.code_test_t,
+            public: ex.public_b ?? false,
+            creationDate: new Date(ex.creation_ts_dt),
+            lastUpdateDate: ex.last_update_ts_dt
+                ? new Date(ex.last_update_ts_dt)
+                : undefined,
+            lastPublicationDate: ex.creation_ts_dt
+                ? new Date(ex.creation_ts_dt)
+                : undefined,
+            owner,
+            space: {
+                handle: ex.handle_s,
+            },
+            organization: {
+                handle: ex.handle_s,
+            },
+            datasets: [],
+        };
+        SPACE_EXERCISES_BY_ID.set(exercise.id, exercise);
+        return exercise;
+    };
+    const getExercise = (id) => SPACE_EXERCISES_BY_ID.get(id);
+    const refreshExercise = (id) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/spaces/items/${id}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const exercise = resp.item;
+                if (exercise) {
+                    toExercise(exercise);
+                }
+            }
+            return resp;
+        });
+    };
+    const getSpaceExercises = () => {
+        return Array.from(SPACE_EXERCISES_BY_ID.values());
+    };
+    const refreshSpaceExercises = (space, organization) => {
+        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/exercise`;
+        return requestDatalayer({
+            url,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.items.forEach(d => {
+                    toExercise(d);
+                });
+            }
+            return resp;
+        });
+    };
+    const cloneExercise = (exerciseId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/exercises/${exerciseId}/clone`,
+            method: 'POST',
+        }).then(resp => {
+            if (resp.success) {
+                toExercise(resp.exercise);
+            }
+            return resp;
+        });
+    };
+    const updateExercise = ({ id, name, description, help, codePre, codeSolution, codeQuestion, codeTest, }) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/exercises/${id}`,
+            method: 'PUT',
+            body: {
+                name,
+                description,
+                help,
+                codePre,
+                codeSolution,
+                codeQuestion,
+                codeTest,
+            },
+        });
+    };
+    const updateExercisePoints = (id, codeStudent, points) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/exercises/${id}/points`,
+            method: 'PUT',
+            body: {
+                codeStudent,
+                points,
+            },
+        });
+    };
+    // Assignments ------------------------------------------------------------------
+    const toAssignment = (raw_assignment) => {
+        const owner = newUserMock();
+        USERS_BY_ID.set(owner.id, owner);
+        let studentItem = undefined;
+        if (raw_assignment.student_items) {
+            raw_assignment.student_items.forEach(student_item => {
+                studentItem = {
+                    id: student_item.uid,
+                    type: 'student_item',
+                    itemId: student_item.item_uid,
+                    itemType: student_item.item_type_s,
+                    nbgrades: student_item.nbgrades,
+                    nbgradesTotalPoints: student_item.nbgrades_total_points_f,
+                    nbgradesTotalScore: student_item.nbgrades_total_score_f,
+                };
+            });
+        }
+        USERS_BY_ID.set(owner.id, owner);
+        const assignment = {
+            id: raw_assignment.uid,
+            type: 'assignment',
+            name: raw_assignment.name_t,
+            description: raw_assignment.description_t,
+            nbformat: raw_assignment.model_s
+                ? JSON.parse(raw_assignment.model_s)
+                : undefined,
+            public: raw_assignment.public_b ?? false,
+            creationDate: new Date(raw_assignment.creation_ts_dt),
+            lastUpdateDate: raw_assignment.last_update_ts_dt
+                ? new Date(raw_assignment.last_update_ts_dt)
+                : undefined,
+            lastPublicationDate: raw_assignment.creation_ts_dt
+                ? new Date(raw_assignment.creation_ts_dt)
+                : undefined,
+            studentItem,
+            datasets: [],
+            owner,
+            space: {
+                handle: raw_assignment.handle_s,
+            },
+            organization: {
+                handle: raw_assignment.handle_s,
+            },
+        };
+        SPACE_ASSIGNMENTS_BY_ID.set(assignment.id, assignment);
+        STUDENT_ASSIGNMENTS_BY_ID.set(assignment.id, assignment);
+        return assignment;
+    };
+    const getAssignment = assignmentId => SPACE_ASSIGNMENTS_BY_ID.get(assignmentId);
+    const refreshAssignment = (assignmentId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const assignment = resp.assignment;
+                if (assignment) {
+                    toAssignment(assignment);
+                }
+            }
+            return resp;
+        });
+    };
+    const getAssignmentForStudent = (assignmentId) => STUDENT_ASSIGNMENTS_BY_ID.get(assignmentId);
+    const refreshAssignmentForStudent = (courseId, user, assignmentId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}/courses/${courseId}/students/${user.id}`,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                const assignment = resp.assignment;
+                if (assignment) {
+                    toAssignment(assignment);
+                }
+            }
+            return resp;
+        });
+    };
+    const resetAssignmentForStudent = (courseId, user, assignmentId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}/reset`,
+            method: 'POST',
+        }).then(resp => {
+            if (resp.success) {
+                const assignment = resp.assignment;
+                if (assignment) {
+                    toAssignment(assignment);
+                }
+            }
+            return resp;
+        });
+    };
+    const gradeAssignmentForStudent = (courseId, user, assignmentId, model) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}/students/${user.id}/grade`,
+            method: 'PUT',
+            body: {
+                model,
+            },
+        }).then(resp => {
+            if (resp.success) {
+                const assignment = resp.assignment;
+                if (assignment) {
+                    toAssignment(assignment);
+                }
+            }
+            return resp;
+        });
+    };
+    const getSpaceAssignments = () => Array.from(SPACE_ASSIGNMENTS_BY_ID.values());
+    const getSpaceAssignment = id => SPACE_ASSIGNMENTS_BY_ID.get(id);
+    const refreshSpaceAssignments = (space, organization) => {
+        const url = `${configuration.spacerRunUrl}/api/spacer/v1/spaces/${space.id}/items/types/assignment`;
+        return requestDatalayer({
+            url,
+            method: 'GET',
+        }).then(resp => {
+            if (resp.success) {
+                resp.items.forEach(n => {
+                    toAssignment(n);
+                });
+            }
+            return resp;
+        });
+    };
+    const cloneAssignment = (assignmentId) => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/notebooks/${assignmentId}/clone`,
+            method: 'POST',
+        }).then(resp => {
+            if (resp.success) {
+                toAssignment(resp.notebook);
+            }
+            return resp;
+        });
+    };
+    const getAssignmentStudentVersion = assignmentId => {
+        return requestDatalayer({
+            url: `${configuration.spacerRunUrl}/api/spacer/v1/assignments/${assignmentId}/student_version`,
+            method: 'GET',
+        });
+    };
+    // Prices -------------------------------------------------------------------
+    const refreshStripePrices = () => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/stripe/v1/prices`,
+            method: 'GET',
+        });
+    };
+    // Checkout -------------------------------------------------------------------
+    const createCheckoutSession = (product, location) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/stripe/v1/checkout/session`,
+            method: 'POST',
+            body: {
+                price_id: product?.id,
+                return_url: `${location.protocol}//${location.host}${location.pathname.split('/').slice(0, -1).join('/')}`,
+            },
+        })
+            .then(data => data.client_secret)
+            .catch(error => {
+            console.error('Failed to create Stripe checkout session.', error);
+        });
+    };
+    // Credits -------------------------------------------------------------------
+    const burnCredit = credits => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/usage/credits`,
+            method: 'DELETE',
+            body: {
+                credits,
+            },
+        });
+    };
+    const getUserCredits = userId => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/usage/credits/users/${userId}`,
+            method: 'GET',
+        });
+    };
+    const updateUserCredits = (userId, credits, brand) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/usage/credits/users/${userId}`,
+            method: 'PUT',
+            body: {
+                credits,
+                brand,
+            },
+        });
+    };
+    const updateUserCreditsQuota = (userId, quota) => {
+        return requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/usage/quota`,
+            method: 'PUT',
+            body: {
+                user_uid: userId,
+                quota,
+                reset: '0',
+            },
+        });
+    };
+    // Usages -------------------------------------------------------------------
+    /**
+     * Get user usages
+     */
+    const getUsages = async () => {
+        const data = await requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/usage/user`,
+            method: 'GET',
+        });
+        data.usages = (data.usages ?? []).map(u => asUsage(u));
+        return data;
+    };
+    /**
+     * Get user usages
+     */
+    const getUsagesForUser = async (userId) => {
+        const data = await requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/usage/users/${userId}`,
+            method: 'GET',
+        });
+        data.usages = (data.usages ?? []).map(u => asUsage(u));
+        return data;
+    };
+    /**
+     * Get platform usages
+     */
+    const getPlatformUsages = async () => {
+        const data = await requestDatalayer({
+            url: `${configuration.iamRunUrl}/api/iam/v1/usage/platform`,
+            method: 'GET',
+        });
+        data.usages = (data.usages ?? []).map(u => asUsage(u));
+        return data;
+    };
+    // Support ------------------------------------------------------------------
+    const requestPlatformSupport = (subject, message, email, brand) => {
+        return requestDatalayer({
+            url: `${configuration.supportRunUrl}/api/support/v1/support/request`,
+            method: 'POST',
+            body: {
+                subject,
+                message,
+                email,
+                brand,
+            },
+        });
+    };
+    const requestPlatformSupport2 = (accountHandle, firstName, lastName, email, message) => {
+        return requestDatalayer({
+            url: `${configuration.supportRunUrl}/api/support/v1/support/request2`,
+            method: 'POST',
+            body: {
+                accountHandle,
+                firstName,
+                lastName,
+                email,
+                message,
+            },
+        });
+    };
+    // Growth ------------------------------------------------------------------
+    const getGrowthKPI = () => {
+        return requestDatalayer({
+            url: `${configuration.growthRunUrl}/api/growth/v1/kpis`,
+            method: 'GET',
+        });
+    };
+    // --------------------------------------------------------------------------
+    return {
+        // Authentication & Profile
+        login,
+        logout,
+        getMe,
+        updateMe,
+        whoami,
+        requestJoin,
+        requestJoinToken,
+        joinWithInvite,
+        confirmJoinWithToken,
+        changePassword,
+        createTokenForPasswordChange,
+        confirmPassworkWithToken,
+        requestEmailUpdate,
+        confirmEmailUpdate,
+        getOAuth2AuthorizationURL,
+        getOAuth2AuthorizationLinkURL,
+        getGitHubProfile,
+        getLinkedinProfile,
+        postLinkedinShare,
+        postLinkedinShareWithUpload,
+        registerToWaitingList,
+        // Proxy
+        proxyGET,
+        proxyPOST,
+        proxyPUT,
+        // Users
+        getUser,
+        getUserByHandle,
+        searchUsers,
+        refreshUser,
+        assignRoleToUser,
+        unassignRoleFromUser,
+        updateUserOnboarding,
+        updateUserSettings,
+        getUserCredits,
+        updateUserCredits,
+        updateUserCreditsQuota,
+        getUserSurveys,
+        getUsages,
+        getUsagesForUser,
+        // Organizations
+        createOrganization,
+        getOrganizationById,
+        getOrganizationByHandle,
+        getUserOrganizations,
+        getUserOrganizationById,
+        updateOrganization,
+        refreshOrganization,
+        refreshUserOrganizations,
+        addMemberToOrganization,
+        removeMemberFromOrganization,
+        addRoleToOrganizationMember,
+        removeRoleFromOrganizationMember,
+        clearCachedOrganizations,
+        // Teams
+        createTeam,
+        getTeamById,
+        getTeamByHandle,
+        getTeamsByOrganizationId,
+        updateTeam,
+        refreshTeam,
+        refreshTeams,
+        addMemberToTeam,
+        removeMemberFromTeam,
+        addRoleToTeamMember,
+        removeRoleFromTeamMember,
+        clearCachedTeams,
+        // Schools
+        getSchools,
+        refreshSchools,
+        // Spaces
+        createSpace,
+        getOrganizationSpace,
+        getOrganizationSpaceByHandle,
+        getOrganizationSpaces,
+        getUserSpace,
+        getUserSpaceByHandle,
+        getUserSpaces,
+        updateSpace,
+        updateOrganizationSpace,
+        refreshOrganizationSpace,
+        refreshOrganizationSpaces,
+        refreshUserSpace,
+        refreshUserSpaces,
+        refreshLayout,
+        exportSpace,
+        addMemberToOrganizationSpace,
+        removeMemberFromOrganizationSpace,
+        makeSpacePublic,
+        makeSpacePrivate,
+        // Courses
+        getCourse,
+        updateCourse,
+        refreshCourse,
+        getPublicCourses,
+        refreshPublicCourses,
+        getInstructorCourses,
+        refreshInstructorCourses,
+        getCoursesEnrollments,
+        refreshCoursesEnrollments,
+        enrollStudentToCourse,
+        removeStudentFromCourse,
+        getStudent,
+        refreshStudent,
+        confirmCourseItemCompletion,
+        setCourseItems,
+        // Notebooks
+        createNotebook,
+        getNotebook,
+        getSpaceNotebook,
+        getSpaceNotebooks,
+        updateNotebook,
+        updateNotebookModel,
+        cloneNotebook,
+        refreshNotebook,
+        refreshSpaceNotebooks,
+        // Documents
+        getDocument,
+        getSpaceDocument,
+        getSpaceDocuments,
+        updateDocument,
+        updateDocumentModel,
+        cloneDocument,
+        refreshDocument,
+        refreshSpaceDocuments,
+        // Cells
+        getCell,
+        getSpaceCells,
+        updateCell,
+        cloneCell,
+        refreshCell,
+        refreshSpaceCells,
+        // Datasets
+        getDataset,
+        getSpaceDatasets,
+        updateDataset,
+        refreshDataset,
+        refreshSpaceDatasets,
+        // Environments
+        getEnvironment,
+        getSpaceEnvironments,
+        refreshEnvironment,
+        refreshSpaceEnvironments,
+        // Lessons
+        getLesson,
+        getSpaceLesson,
+        getSpaceLessons,
+        cloneLesson,
+        refreshLesson,
+        refreshSpaceLessons,
+        // Exercises
+        getExercise,
+        getSpaceExercises,
+        updateExercise,
+        updateExercisePoints,
+        cloneExercise,
+        refreshExercise,
+        refreshSpaceExercises,
+        // Assignments
+        getAssignment,
+        getAssignmentForStudent,
+        getAssignmentStudentVersion,
+        getSpaceAssignment,
+        getSpaceAssignments,
+        cloneAssignment,
+        refreshAssignment,
+        refreshAssignmentForStudent,
+        refreshSpaceAssignments,
+        gradeAssignmentForStudent,
+        resetAssignmentForStudent,
+        // Items (Generic)
+        getPublicItems,
+        getSpaceItems,
+        searchPublicItems,
+        makeItemPublic,
+        makeItemPrivate,
+        deleteItem,
+        refreshPublicItems,
+        refreshSpaceItems,
+        clearCachedPublicItems,
+        clearCachedItems,
+        // Pages
+        createPage,
+        getPage,
+        getPages,
+        updatePage,
+        deletePage,
+        refreshPage,
+        refreshPages,
+        clearCachedPages,
+        // Datasources
+        createDatasource,
+        getDatasource,
+        getDatasources,
+        updateDatasource,
+        refreshDatasource,
+        refreshDatasources,
+        clearCachedDatasources,
+        // Secrets
+        createSecret,
+        getSecret,
+        getSecrets,
+        updateSecret,
+        deleteSecret,
+        refreshSecret,
+        refreshSecrets,
+        clearCachedSecrets,
+        // Tokens
+        createToken,
+        getToken,
+        getTokens,
+        updateToken,
+        refreshToken,
+        refreshTokens,
+        clearCachedTokens,
+        // Invites
+        requestInvite,
+        sendInvite,
+        getInvite,
+        getInvites,
+        putInvite,
+        refreshInvite,
+        refreshInvites,
+        refreshAccount,
+        clearCachedInvites,
+        // Contacts
+        createContact,
+        getContactById,
+        getContactByHandle,
+        updateContact,
+        deleteContact,
+        searchContacts,
+        refreshContact,
+        assignTagToContact,
+        unassignTagFromContact,
+        sendInviteToContact,
+        enrichContactEmail,
+        enrichContactLinkedin,
+        sendLinkedinConnectionRequest,
+        linkUserWithContact,
+        unlinkUserFromContact,
+        // Inbounds
+        getInbound,
+        getInboundByHandle,
+        getInbounds,
+        refreshInbound,
+        toInbound,
+        // Outbounds
+        getOutbound,
+        getOutbounds,
+        refreshOutbound,
+        draftBulkEmailsOutbounds,
+        tryBulkEmailsOutbounds,
+        launchBulkEmailsOutbounds,
+        sendOutboundEmailToUser,
+        deleteOutbound,
+        subscribeUserToOutbounds,
+        unsubscribeUserFromOutbounds,
+        unsubscribeContactFromOutbounds,
+        unsubscribeInviteeFromOutbounds,
+        toOutbound,
+        // MFA
+        enableUserMFA,
+        disableUserMFA,
+        validateUserMFACode,
+        // Checkout & Credits
+        createCheckoutSession,
+        burnCredit,
+        refreshStripePrices,
+        // Support & Growth
+        requestPlatformSupport,
+        requestPlatformSupport2,
+        getGrowthKPI,
+        getPlatformUsages,
+        // Cache Management
+        clearAllCaches,
+        // Upload
+        notebookUploadLoading,
+        notebookUploadProgress,
+        resetNotebookUpload,
+    };
+};
+export default useCache0;
diff --git a/node_modules/@datalayer/core/lib/hooks/useIAM.js b/node_modules/@datalayer/core/lib/hooks/useIAM.js
index 4d0194e..8ce4af3 100644
--- a/node_modules/@datalayer/core/lib/hooks/useIAM.js
+++ b/node_modules/@datalayer/core/lib/hooks/useIAM.js
@@ -14,7 +14,9 @@ export const useIAM = (props = { user: undefined, token: undefined }) => {
     const layoutStore = useLayoutStore();
     const organizationStore = useOrganizationStore();
     const spaceStore = useSpaceStore();
-    const { clearAllCaches, whoami } = useCache();
+    const { useWhoami, useLogout } = useCache();
+    const { data: whoamiData } = useWhoami();
+    const logoutMutation = useLogout();
     const loginAndNavigate = async (token, logout, refresh, navigate, homeRoute) => {
         try {
             const resp = await requestDatalayerAPI({
@@ -60,27 +62,26 @@ export const useIAM = (props = { user: undefined, token: undefined }) => {
         layoutStore.reset();
         organizationStore.updateOrganizations([]);
         spaceStore.updateSpaces([]);
-        clearAllCaches();
+        // Call TanStack Query logout mutation which will clear all caches
+        logoutMutation.mutate();
         setIAMState({ user: ANONYMOUS_USER, token: ANONYMOUS_USER_TOKEN });
     };
     useEffect(() => {
-        if (token) {
-            whoami().then(resp => {
-                if (resp.success) {
-                    const user = asUser(resp.profile);
-                    setIAMState({ user, token });
-                    iamStore.setLogin(user, token);
-                    // TODO centralize user settings management.
-                    const aiagentsRunUrl = user.settings?.aiAgentsUrl;
-                    if (aiagentsRunUrl) {
-                        coreStore.getState().setConfiguration({
-                            aiagentsRunUrl,
-                        });
-                    }
+        if (token && whoamiData) {
+            if (whoamiData.success) {
+                const user = asUser(whoamiData.profile);
+                setIAMState({ user, token });
+                iamStore.setLogin(user, token);
+                // TODO centralize user settings management.
+                const aiagentsRunUrl = user.settings?.aiAgentsUrl;
+                if (aiagentsRunUrl) {
+                    coreStore.getState().setConfiguration({
+                        aiagentsRunUrl,
+                    });
                 }
-            });
+            }
         }
-    }, []);
+    }, [token, whoamiData, iamStore]);
     return {
         user: iamState.user,
         token: iamState.token,
diff --git a/node_modules/@datalayer/core/lib/models/PageTag.d.ts b/node_modules/@datalayer/core/lib/models/PageTag.d.ts
index d98c76b..6659cdb 100644
--- a/node_modules/@datalayer/core/lib/models/PageTag.d.ts
+++ b/node_modules/@datalayer/core/lib/models/PageTag.d.ts
@@ -15,5 +15,5 @@ export type PageTag = {
 export declare const PAGE_TAGE_NONE: PageTag;
 export declare const PAGE_TAGS: PageTag[];
 export declare const PAGE_TAGS_BY_NAME_MAP: Map<PageTagName | undefined, PageTag>;
-export declare const PAGE_TAGS_BY_COLOR_MAP: Map<"blue" | "coral" | "gray" | "green" | "indigo" | "lime" | "orange" | "pink" | "purple" | "red" | "teal" | "yellow" | "default" | "lemon", PageTag>;
+export declare const PAGE_TAGS_BY_COLOR_MAP: Map<"default" | "yellow" | "blue" | "coral" | "green" | "gray" | "indigo" | "lemon" | "lime" | "orange" | "pink" | "purple" | "red" | "teal", PageTag>;
 export {};
diff --git a/node_modules/@datalayer/core/lib/models/Runtime.d.ts b/node_modules/@datalayer/core/lib/models/Runtime.d.ts
index bba3025..fb5bc46 100644
--- a/node_modules/@datalayer/core/lib/models/Runtime.d.ts
+++ b/node_modules/@datalayer/core/lib/models/Runtime.d.ts
@@ -21,6 +21,55 @@ export type IRuntimeLocation = 'browser' | 'local' | string;
  */
 export interface IRuntimeModel extends IRuntimePod, Kernel.IModel {
 }
+/**
+ * Runtime pod.
+ */
+export interface IRuntimePod {
+    /**
+     * Environment display name
+     */
+    environment_title: string;
+    /**
+     * Environment name
+     */
+    environment_name: string;
+    /**
+     * Runtime name
+     */
+    pod_name: string;
+    /**
+     * Runtime ingress URL
+     */
+    ingress: string;
+    /**
+     * Runtime user given name
+     */
+    given_name: string;
+    /**
+     * Runtime type
+     */
+    type: IRuntimeType;
+    /**
+     * Server authentication token
+     */
+    token: string;
+    /**
+     * Credits burning rate per second
+     */
+    burning_rate: number;
+    /**
+     * Kernel reservation ID
+     */
+    reservation_id?: string;
+    /**
+     * Runtime usage starting timestamp
+     */
+    started_at: string;
+    /**
+     * Runtime credits reservation expiration timestamp
+     */
+    expired_at?: string;
+}
 /**
  * Runtime description.
  */
@@ -72,52 +121,3 @@ export type IRuntimeType = 'notebook' | 'cell';
  * Runtime optional capabilities.
  */
 export type IRuntimeCapabilities = 'user_storage';
-/**
- * Runtime pod.
- */
-export interface IRuntimePod {
-    /**
-     * Environment display name
-     */
-    environment_title: string;
-    /**
-     * Environment name
-     */
-    environment_name: string;
-    /**
-     * Runtime name
-     */
-    pod_name: string;
-    /**
-     * Runtime ingress URL
-     */
-    ingress: string;
-    /**
-     * Runtime user given name
-     */
-    given_name: string;
-    /**
-     * Runtime type
-     */
-    type: IRuntimeType;
-    /**
-     * Server authentication token
-     */
-    token: string;
-    /**
-     * Credits burning rate per second
-     */
-    burning_rate: number;
-    /**
-     * Kernel reservation ID
-     */
-    reservation_id?: string;
-    /**
-     * Runtime usage starting timestamp
-     */
-    started_at: string;
-    /**
-     * Runtime credits reservation expiration timestamp
-     */
-    expired_at?: string;
-}
diff --git a/node_modules/@datalayer/core/lib/stateful/index.d.ts b/node_modules/@datalayer/core/lib/stateful/index.d.ts
index d7e72b7..852df12 100644
--- a/node_modules/@datalayer/core/lib/stateful/index.d.ts
+++ b/node_modules/@datalayer/core/lib/stateful/index.d.ts
@@ -1,3 +1,2 @@
 export * from './jupyter';
 export * from './runtimes';
-export * from '../api/DatalayerApi';
diff --git a/node_modules/@datalayer/core/lib/stateful/index.js b/node_modules/@datalayer/core/lib/stateful/index.js
index a669052..a87897a 100644
--- a/node_modules/@datalayer/core/lib/stateful/index.js
+++ b/node_modules/@datalayer/core/lib/stateful/index.js
@@ -4,4 +4,3 @@
  */
 export * from './jupyter';
 export * from './runtimes';
-export * from '../api/DatalayerApi';
diff --git a/node_modules/@datalayer/core/lib/stateful/runtimes/actions.d.ts b/node_modules/@datalayer/core/lib/stateful/runtimes/actions.d.ts
index 15d7a6c..7a94894 100644
--- a/node_modules/@datalayer/core/lib/stateful/runtimes/actions.d.ts
+++ b/node_modules/@datalayer/core/lib/stateful/runtimes/actions.d.ts
@@ -1,4 +1,4 @@
-import { IRuntimeOptions } from '..';
+import { IRuntimeOptions } from '../../api';
 import type { IRuntimeSnapshot, IDatalayerEnvironment, IRuntimePod } from '../../models';
 /**
  * Get available Environments.
diff --git a/node_modules/@datalayer/core/lib/stateful/runtimes/actions.js b/node_modules/@datalayer/core/lib/stateful/runtimes/actions.js
index 5227089..f33ee9a 100644
--- a/node_modules/@datalayer/core/lib/stateful/runtimes/actions.js
+++ b/node_modules/@datalayer/core/lib/stateful/runtimes/actions.js
@@ -8,7 +8,7 @@
 import { URLExt } from '@jupyterlab/coreutils';
 import { PromiseDelegate } from '@lumino/coreutils';
 import { Upload } from 'tus-js-client';
-import { requestDatalayerAPI, } from '..';
+import { requestDatalayerAPI, } from '../../api';
 import { asRuntimeSnapshot } from '../../models';
 import { iamStore, runtimesStore } from '../../state';
 import { sleep } from '../../utils';
diff --git a/node_modules/@datalayer/core/lib/stories/Configure.mdx b/node_modules/@datalayer/core/lib/stories/Configure.mdx
new file mode 100644
index 0000000..55c21a8
--- /dev/null
+++ b/node_modules/@datalayer/core/lib/stories/Configure.mdx
@@ -0,0 +1,364 @@
+import { Meta } from "@storybook/addon-docs/blocks";
+
+import Github from "./assets/github.svg";
+import Discord from "./assets/discord.svg";
+import Youtube from "./assets/youtube.svg";
+import Tutorials from "./assets/tutorials.svg";
+import Styling from "./assets/styling.png";
+import Context from "./assets/context.png";
+import Assets from "./assets/assets.png";
+import Docs from "./assets/docs.png";
+import Share from "./assets/share.png";
+import FigmaPlugin from "./assets/figma-plugin.png";
+import Testing from "./assets/testing.png";
+import Accessibility from "./assets/accessibility.png";
+import Theming from "./assets/theming.png";
+import AddonLibrary from "./assets/addon-library.png";
+
+export const RightArrow = () => <svg 
+    viewBox="0 0 14 14" 
+    width="8px" 
+    height="14px" 
+    style={{ 
+      marginLeft: '4px',
+      display: 'inline-block',
+      shapeRendering: 'inherit',
+      verticalAlign: 'middle',
+      fill: 'currentColor',
+      'path fill': 'currentColor'
+    }}
+>
+  <path d="m11.1 7.35-5.5 5.5a.5.5 0 0 1-.7-.7L10.04 7 4.9 1.85a.5.5 0 1 1 .7-.7l5.5 5.5c.2.2.2.5 0 .7Z" />
+</svg>
+
+<Meta title="Configure your project" />
+
+<div className="sb-container">
+  <div className='sb-section-title'>
+    # Configure your project
+
+    Because Storybook works separately from your app, you'll need to configure it for your specific stack and setup. Below, explore guides for configuring Storybook with popular frameworks and tools. If you get stuck, learn how you can ask for help from our community.
+  </div>
+  <div className="sb-section">
+    <div className="sb-section-item">
+      <img
+        src={Styling}
+        alt="A wall of logos representing different styling technologies"
+      />
+      <h4 className="sb-section-item-heading">Add styling and CSS</h4>
+      <p className="sb-section-item-paragraph">Like with web applications, there are many ways to include CSS within Storybook. Learn more about setting up styling within Storybook.</p>
+      <a
+        href="https://storybook.js.org/docs/configure/styling-and-css/?renderer=react"
+        target="_blank"
+      >Learn more<RightArrow /></a>
+    </div>
+    <div className="sb-section-item">
+      <img
+        src={Context}
+        alt="An abstraction representing the composition of data for a component"
+      />
+      <h4 className="sb-section-item-heading">Provide context and mocking</h4>
+      <p className="sb-section-item-paragraph">Often when a story doesn't render, it's because your component is expecting a specific environment or context (like a theme provider) to be available.</p>
+      <a
+        href="https://storybook.js.org/docs/writing-stories/decorators/?renderer=react#context-for-mocking"
+        target="_blank"
+      >Learn more<RightArrow /></a>
+    </div>
+    <div className="sb-section-item">
+      <img src={Assets} alt="A representation of typography and image assets" />
+      <div>
+        <h4 className="sb-section-item-heading">Load assets and resources</h4>
+        <p className="sb-section-item-paragraph">To link static files (like fonts) to your projects and stories, use the
+        `staticDirs` configuration option to specify folders to load when
+        starting Storybook.</p>
+        <a
+          href="https://storybook.js.org/docs/configure/images-and-assets/?renderer=react"
+          target="_blank"
+        >Learn more<RightArrow /></a>
+      </div>
+    </div>
+  </div>
+</div>
+<div className="sb-container">
+  <div className='sb-section-title'>
+    # Do more with Storybook
+
+    Now that you know the basics, let's explore other parts of Storybook that will improve your experience. This list is just to get you started. You can customise Storybook in many ways to fit your needs.
+  </div>
+
+  <div className="sb-section">
+    <div className="sb-features-grid">
+      <div className="sb-grid-item">
+        <img src={Docs} alt="A screenshot showing the autodocs tag being set, pointing a docs page being generated" />
+        <h4 className="sb-section-item-heading">Autodocs</h4>
+        <p className="sb-section-item-paragraph">Auto-generate living,
+          interactive reference documentation from your components and stories.</p>
+        <a
+          href="https://storybook.js.org/docs/writing-docs/autodocs/?renderer=react"
+          target="_blank"
+        >Learn more<RightArrow /></a>
+      </div>
+      <div className="sb-grid-item">
+        <img src={Share} alt="A browser window showing a Storybook being published to a chromatic.com URL" />
+        <h4 className="sb-section-item-heading">Publish to Chromatic</h4>
+        <p className="sb-section-item-paragraph">Publish your Storybook to review and collaborate with your entire team.</p>
+        <a
+          href="https://storybook.js.org/docs/sharing/publish-storybook/?renderer=react#publish-storybook-with-chromatic"
+          target="_blank"
+        >Learn more<RightArrow /></a>
+      </div>
+      <div className="sb-grid-item">
+        <img src={FigmaPlugin} alt="Windows showing the Storybook plugin in Figma" />
+        <h4 className="sb-section-item-heading">Figma Plugin</h4>
+        <p className="sb-section-item-paragraph">Embed your stories into Figma to cross-reference the design and live
+          implementation in one place.</p>
+        <a
+          href="https://storybook.js.org/docs/sharing/design-integrations/?renderer=react#embed-storybook-in-figma-with-the-plugin"
+          target="_blank"
+        >Learn more<RightArrow /></a>
+      </div>
+      <div className="sb-grid-item">
+        <img src={Testing} alt="Screenshot of tests passing and failing" />
+        <h4 className="sb-section-item-heading">Testing</h4>
+        <p className="sb-section-item-paragraph">Use stories to test a component in all its variations, no matter how
+          complex.</p>
+        <a
+          href="https://storybook.js.org/docs/writing-tests/?renderer=react"
+          target="_blank"
+        >Learn more<RightArrow /></a>
+      </div>
+      <div className="sb-grid-item">
+        <img src={Accessibility} alt="Screenshot of accessibility tests passing and failing" />
+        <h4 className="sb-section-item-heading">Accessibility</h4>
+        <p className="sb-section-item-paragraph">Automatically test your components for a11y issues as you develop.</p>
+        <a
+          href="https://storybook.js.org/docs/writing-tests/accessibility-testing/?renderer=react"
+          target="_blank"
+        >Learn more<RightArrow /></a>
+      </div>
+      <div className="sb-grid-item">
+        <img src={Theming} alt="Screenshot of Storybook in light and dark mode" />
+        <h4 className="sb-section-item-heading">Theming</h4>
+        <p className="sb-section-item-paragraph">Theme Storybook's UI to personalize it to your project.</p>
+        <a
+          href="https://storybook.js.org/docs/configure/theming/?renderer=react"
+          target="_blank"
+        >Learn more<RightArrow /></a>
+      </div>
+    </div>
+  </div>
+</div>
+<div className='sb-addon'>
+  <div className='sb-addon-text'>
+    <h4>Addons</h4>
+    <p className="sb-section-item-paragraph">Integrate your tools with Storybook to connect workflows.</p>
+    <a
+        href="https://storybook.js.org/addons/"
+        target="_blank"
+      >Discover all addons<RightArrow /></a>
+  </div>
+  <div className='sb-addon-img'>
+    <img src={AddonLibrary} alt="Integrate your tools with Storybook to connect workflows." />
+  </div>
+</div>
+
+<div className="sb-section sb-socials">
+    <div className="sb-section-item">
+      <img src={Github} alt="Github logo" className="sb-explore-image"/>
+      Join our contributors building the future of UI development.
+
+      <a
+        href="https://github.com/storybookjs/storybook"
+        target="_blank"
+      >Star on GitHub<RightArrow /></a>
+    </div>
+    <div className="sb-section-item">
+      <img src={Discord} alt="Discord logo" className="sb-explore-image"/>
+      <div>
+        Get support and chat with frontend developers.
+
+        <a
+          href="https://discord.gg/storybook"
+          target="_blank"
+        >Join Discord server<RightArrow /></a>
+      </div>
+    </div>
+    <div className="sb-section-item">
+      <img src={Youtube} alt="Youtube logo" className="sb-explore-image"/>
+      <div>
+        Watch tutorials, feature previews and interviews.
+
+        <a
+          href="https://www.youtube.com/@chromaticui"
+          target="_blank"
+        >Watch on YouTube<RightArrow /></a>
+      </div>
+    </div>
+    <div className="sb-section-item">
+      <img src={Tutorials} alt="A book" className="sb-explore-image"/>
+      <p>Follow guided walkthroughs on for key workflows.</p>
+
+      <a
+          href="https://storybook.js.org/tutorials/"
+          target="_blank"
+        >Discover tutorials<RightArrow /></a>
+    </div>
+</div>
+
+<style>
+  {`
+  .sb-container {
+    margin-bottom: 48px;
+  }
+
+  .sb-section {
+    width: 100%;
+    display: flex;
+    flex-direction: row;
+    gap: 20px;
+  }
+
+  img {
+    object-fit: cover;
+  }
+
+  .sb-section-title {
+    margin-bottom: 32px;
+  }
+
+  .sb-section a:not(h1 a, h2 a, h3 a) {
+    font-size: 14px;
+  }
+
+  .sb-section-item, .sb-grid-item {
+    flex: 1;
+    display: flex;
+    flex-direction: column;
+  }
+
+  .sb-section-item-heading {
+    padding-top: 20px !important;
+    padding-bottom: 5px !important;
+    margin: 0 !important;
+  }
+  .sb-section-item-paragraph {
+    margin: 0;
+    padding-bottom: 10px;
+  }
+
+  .sb-chevron {
+    margin-left: 5px;
+  }
+
+  .sb-features-grid {
+    display: grid;
+    grid-template-columns: repeat(2, 1fr);
+    grid-gap: 32px 20px;
+  }
+
+  .sb-socials {
+    display: grid;
+    grid-template-columns: repeat(4, 1fr);
+  }
+
+  .sb-socials p {
+    margin-bottom: 10px;
+  }
+
+  .sb-explore-image {
+    max-height: 32px;
+    align-self: flex-start;
+  }
+
+  .sb-addon {
+    width: 100%;
+    display: flex;
+    align-items: center;
+    position: relative;
+    background-color: #EEF3F8;
+    border-radius: 5px;
+    border: 1px solid rgba(0, 0, 0, 0.05);
+    background: #EEF3F8;
+    height: 180px;
+    margin-bottom: 48px;
+    overflow: hidden;
+  }
+
+  .sb-addon-text {
+    padding-left: 48px;
+    max-width: 240px;
+  }
+
+  .sb-addon-text h4 {
+    padding-top: 0px;
+  }
+
+  .sb-addon-img {
+    position: absolute;
+    left: 345px;
+    top: 0;
+    height: 100%;
+    width: 200%;
+    overflow: hidden;
+  }
+
+  .sb-addon-img img {
+    width: 650px;
+    transform: rotate(-15deg);
+    margin-left: 40px;
+    margin-top: -72px;
+    box-shadow: 0 0 1px rgba(255, 255, 255, 0);
+    backface-visibility: hidden;
+  }
+
+  @media screen and (max-width: 800px) {
+    .sb-addon-img {
+      left: 300px;
+    }
+  }
+
+  @media screen and (max-width: 600px) {
+    .sb-section {
+      flex-direction: column;
+    }
+
+    .sb-features-grid {
+      grid-template-columns: repeat(1, 1fr);
+    }
+
+    .sb-socials {
+      grid-template-columns: repeat(2, 1fr);
+    }
+
+    .sb-addon {
+      height: 280px;
+      align-items: flex-start;
+      padding-top: 32px;
+      overflow: hidden;
+    }
+
+    .sb-addon-text {
+      padding-left: 24px;
+    }
+
+    .sb-addon-img {
+      right: 0;
+      left: 0;
+      top: 130px;
+      bottom: 0;
+      overflow: hidden;
+      height: auto;
+      width: 124%;
+    }
+
+    .sb-addon-img img {
+      width: 1200px;
+      transform: rotate(-12deg);
+      margin-left: 0;
+      margin-top: 48px;
+      margin-bottom: -40px;
+      margin-left: -24px;
+    }
+  }
+  `}
+</style>
diff --git a/node_modules/@datalayer/core/lib/stories/assets/avif-test-image.avif b/node_modules/@datalayer/core/lib/stories/assets/avif-test-image.avif
new file mode 100644
index 0000000..530709b
Binary files /dev/null and b/node_modules/@datalayer/core/lib/stories/assets/avif-test-image.avif differ
